<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Navigation Mesh - Nightshade Game Engine</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nightshade Game Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="navigation-mesh"><a class="header" href="#navigation-mesh">Navigation Mesh</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/navmesh">NavMesh</a></p>
</blockquote>
<p>AI pathfinding using Recast navigation mesh generation, A*/Dijkstra/Greedy pathfinding, funnel path smoothing, and agent movement with local avoidance.</p>
<h2 id="how-navigation-meshes-work"><a class="header" href="#how-navigation-meshes-work">How Navigation Meshes Work</a></h2>
<p>A navigation mesh (navmesh) is a set of convex polygons (usually triangles) that represent the walkable surfaces of a level. Instead of testing every point in the world for walkability, AI agents pathfind through connected triangles, then smooth the resulting path through shared edges.</p>
<h3 id="navmesh-generation-recast-pipeline"><a class="header" href="#navmesh-generation-recast-pipeline">Navmesh Generation (Recast Pipeline)</a></h3>
<p>Nightshade uses the Recast algorithm (via the <code>rerecast</code> crate) to automatically generate a navmesh from world geometry. The pipeline has 13 steps:</p>
<ol>
<li><strong>Build trimesh</strong> - Collect all mesh vertices and indices from the scene</li>
<li><strong>Mark walkable triangles</strong> - Classify each triangle by its slope angle against the walkable threshold</li>
<li><strong>Create heightfield</strong> - Rasterize the scene into a voxel grid with configurable cell size and height</li>
<li><strong>Rasterize triangles</strong> - Project each walkable triangle into the heightfield</li>
<li><strong>Filter obstacles</strong> - Remove low-hanging obstacles, ledge spans, and low-height spans that agents can't traverse</li>
<li><strong>Compact heightfield</strong> - Convert to a more efficient representation for region building</li>
<li><strong>Erode walkable area</strong> - Shrink walkable areas by the agent radius to prevent wall clipping</li>
<li><strong>Build distance field</strong> - Compute the distance from each cell to the nearest boundary</li>
<li><strong>Create regions</strong> - Group connected cells into regions using watershed partitioning. <code>min_region_size</code> (default 8) filters tiny regions, <code>merge_region_size</code> (default 20) combines small adjacent regions</li>
<li><strong>Build contours</strong> - Trace region boundaries into simplified contour polygons, controlled by <code>max_simplification_error</code></li>
<li><strong>Convert to polygon mesh</strong> - Triangulate contours into convex polygons (up to <code>max_vertices_per_polygon</code>, default 6)</li>
<li><strong>Generate detail mesh</strong> - Add interior detail vertices for height accuracy, controlled by <code>detail_sample_dist</code> and <code>detail_sample_max_error</code></li>
<li><strong>Convert to NavMeshWorld</strong> - Build the engine's navmesh data structure with adjacency and spatial hash</li>
</ol>
<h3 id="pathfinding-algorithms"><a class="header" href="#pathfinding-algorithms">Pathfinding Algorithms</a></h3>
<p>Three algorithms are available:</p>
<p><strong>A*</strong> (default) - Explores nodes ordered by <code>f = g + h</code> where <code>g</code> is the cost so far and <code>h</code> is the heuristic (straight-line distance to goal). Finds the optimal path efficiently by prioritizing nodes closer to the destination.</p>
<p><strong>Dijkstra</strong> - Explores nodes ordered only by <code>g</code> cost, ignoring direction to goal. Explores more nodes but guarantees the shortest path even with complex cost functions.</p>
<p><strong>Greedy Best-First</strong> - Explores nodes ordered only by heuristic <code>h</code>, ignoring path cost. Very fast but may not find optimal paths, especially around concave obstacles.</p>
<p>All three operate on the triangle adjacency graph, where edges connect triangles that share an edge and costs are the distances between triangle centers.</p>
<h3 id="funnel-algorithm-path-smoothing"><a class="header" href="#funnel-algorithm-path-smoothing">Funnel Algorithm (Path Smoothing)</a></h3>
<p>Raw paths through the navmesh are sequences of triangle centers, which zig-zag unnecessarily. The <strong>funnel algorithm</strong> produces smooth, natural-looking paths:</p>
<ol>
<li><strong>Portal collection</strong> - Extract the shared edges (portals) between consecutive triangles in the path</li>
<li><strong>Funnel narrowing</strong> - Maintain a funnel (left and right boundaries) that starts wide at the first portal. As you advance through portals, narrow the funnel. When a portal would flip the funnel inside-out, emit the funnel apex as a waypoint and restart</li>
<li><strong>Simplification</strong> - Remove waypoints that don't improve the path within an epsilon tolerance (collinear point removal)</li>
</ol>
<p>The result is the shortest path through the triangle corridor that doesn't cross any triangle boundaries.</p>
<h3 id="agent-movement-system"><a class="header" href="#agent-movement-system">Agent Movement System</a></h3>
<p>Five systems run each frame via <code>run_navmesh_systems</code>:</p>
<ol>
<li><strong>Triangle tracking</strong> - Finds which navmesh triangle each agent currently occupies using point-in-triangle tests with barycentric coordinates</li>
<li><strong>Path processing</strong> - Agents in <code>PathPending</code> state get their path computed, smoothed, and simplified. State transitions to <code>Moving</code> or <code>NoPath</code></li>
<li><strong>Local avoidance</strong> - Repulsive forces between nearby agents (within <code>agent_radius * 2.5</code>) prevent crowding. Avoidance velocity is blended at 25% with the primary movement direction</li>
<li><strong>Movement</strong> - Advances agents along waypoints at their configured speed. Samples navmesh height at each new position using barycentric interpolation for vertical alignment. Maximum step height of 1.0 unit prevents teleporting through terrain</li>
<li><strong>Surface snapping</strong> - Idle and arrived agents are snapped to the navmesh surface when their Y position drifts more than 0.01 units</li>
</ol>
<h2 id="enabling-navmesh"><a class="header" href="#enabling-navmesh">Enabling NavMesh</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "navmesh"] }
</code></pre>
<h2 id="generating-a-navmesh"><a class="header" href="#generating-a-navmesh">Generating a NavMesh</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::navmesh::*;

fn setup_navmesh(world: &amp;mut World) {
    let config = RecastNavMeshConfig::default();
    generate_navmesh_recast(world, &amp;config);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navmesh-configuration"><a class="header" href="#navmesh-configuration">NavMesh Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RecastNavMeshConfig {
    pub agent_radius: f32,              // Character collision radius (0.4)
    pub agent_height: f32,              // Character height (1.8)
    pub cell_size_fraction: f32,        // XZ voxel resolution divisor (3.0)
    pub cell_height_fraction: f32,      // Y voxel resolution divisor (6.0)
    pub walkable_climb: f32,            // Max step height (0.4)
    pub walkable_slope_angle: f32,      // Max walkable slope in degrees (45)
    pub min_region_size: i32,           // Min region area (8)
    pub merge_region_size: i32,         // Region merge threshold (20)
    pub max_simplification_error: f32,  // Contour simplification (1.3)
    pub max_vertices_per_polygon: i32,  // Polygon complexity (6)
    pub detail_sample_dist: f32,        // Detail mesh sampling (6.0)
    pub detail_sample_max_error: f32,   // Detail mesh error (1.0)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-state-machine"><a class="header" href="#agent-state-machine">Agent State Machine</a></h2>
<pre><code>Idle → PathPending → Moving → Arrived
              ↓
           NoPath
</code></pre>
<h2 id="creating-agents"><a class="header" href="#creating-agents">Creating Agents</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let agent = spawn_navmesh_agent(world, position, speed);
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-destinations"><a class="header" href="#setting-destinations">Setting Destinations</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_agent_destination(world, agent, target_position);
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-navigation-system"><a class="header" href="#running-the-navigation-system">Running the Navigation System</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    run_navmesh_systems(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-agent-status"><a class="header" href="#checking-agent-status">Checking Agent Status</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match get_agent_state(world, agent) {
    NavMeshAgentState::Idle =&gt; { /* waiting */ }
    NavMeshAgentState::PathPending =&gt; { /* computing */ }
    NavMeshAgentState::Moving =&gt; { /* walking */ }
    NavMeshAgentState::Arrived =&gt; { /* at destination */ }
    NavMeshAgentState::NoPath =&gt; { /* unreachable */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="patrol-behavior"><a class="header" href="#patrol-behavior">Patrol Behavior</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PatrolBehavior {
    waypoints: Vec&lt;Vec3&gt;,
    current_waypoint: usize,
}

fn update_patrol(world: &amp;mut World, agent: Entity, patrol: &amp;mut PatrolBehavior) {
    if matches!(get_agent_state(world, agent), NavMeshAgentState::Arrived) {
        patrol.current_waypoint = (patrol.current_waypoint + 1) % patrol.waypoints.len();
        set_agent_destination(world, agent, patrol.waypoints[patrol.current_waypoint]);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization"><a class="header" href="#debug-visualization">Debug Visualization</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_navmesh_debug_draw(world, true);
<span class="boring">}</span></code></pre></pre>
<p>The debug visualization draws:</p>
<ul>
<li>Navmesh triangles as green wireframe (offset 0.15 units above surface)</li>
<li>Agent paths as yellow lines between waypoints</li>
<li>Current path segment as cyan from agent to next waypoint</li>
<li>Waypoints as orange crosses</li>
<li>Destination as a magenta diamond marker with a vertical pole</li>
</ul>
<h2 id="navmeshworld-resource"><a class="header" href="#navmeshworld-resource">NavMeshWorld Resource</a></h2>
<p>The generated navmesh is stored in <code>world.resources.navmesh</code> as a <code>NavMeshWorld</code>:</p>
<ul>
<li><strong>Vertices</strong> - All navmesh vertex positions</li>
<li><strong>Triangles</strong> - Walkable triangles with center, normal, area, and edge indices</li>
<li><strong>Edges</strong> - Triangle edges with indices of the two triangles they belong to (for portal detection)</li>
<li><strong>Adjacency</strong> - <code>HashMap&lt;usize, Vec&lt;NavMeshConnection&gt;&gt;</code> mapping each triangle to its neighbors with traversal costs</li>
<li><strong>Spatial Hash</strong> - Grid-based spatial index for fast point-in-triangle queries</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="particles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="grass.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="particles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="grass.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
