<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nightshade Game Engine</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nightshade Game Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p><strong><a href="https://matthewberger.dev/nightshade">View the Gallery</a></strong> - See live demos of Nightshade's features running in your browser.</p>
</blockquote>
<p><strong>Nightshade</strong> is a modern game engine written in Rust, designed for creating 3D games and interactive applications. It provides a complete toolkit for game development including rendering, physics, audio, animation, and more.</p>
<h2 id="what-is-nightshade"><a class="header" href="#what-is-nightshade">What is Nightshade?</a></h2>
<p>Nightshade is a batteries-included game engine that handles the complexity of modern 3D graphics while remaining approachable for developers of all skill levels. Whether you're building a simple visualizer, a physics playground, or a complete 3D game, Nightshade provides the foundation you need.</p>
<p>The engine is built on top of industry-standard libraries:</p>
<ul>
<li><strong>wgpu</strong> for cross-platform GPU access (Vulkan, Metal, DirectX 12, WebGPU)</li>
<li><strong>Rapier3D</strong> for physics simulation</li>
<li><strong>Kira</strong> for audio playback and spatial sound</li>
<li><strong>egui</strong> for immediate-mode UI</li>
<li><strong>glTF</strong> for 3D model loading</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<ul>
<li><strong>Physically Based Rendering (PBR)</strong> - Metallic-roughness workflow with support for all standard texture maps</li>
<li><strong>Dynamic Lighting</strong> - Directional, point, and spot lights with real-time shadows</li>
<li><strong>Post-Processing</strong> - Bloom, SSAO, depth of field, tonemapping, and custom effects</li>
<li><strong>Skeletal Animation</strong> - Smooth blending and crossfading between animations</li>
<li><strong>Particle Systems</strong> - GPU-accelerated particles with configurable emitters</li>
<li><strong>Terrain</strong> - Procedural generation with tessellation and LOD</li>
<li><strong>Grass</strong> - Thousands of interactive grass blades with wind simulation</li>
</ul>
<h3 id="physics"><a class="header" href="#physics">Physics</a></h3>
<ul>
<li><strong>Rigid Body Dynamics</strong> - Dynamic, kinematic, and static bodies</li>
<li><strong>Collision Shapes</strong> - Box, sphere, capsule, cylinder, convex hull, trimesh, heightfield</li>
<li><strong>Character Controllers</strong> - Built-in player movement with slopes, steps, and jumping</li>
<li><strong>Physics Joints</strong> - Fixed, revolute, prismatic, spherical, rope, and spring joints</li>
<li><strong>Raycasting</strong> - Query the physics world for line-of-sight and hit detection</li>
</ul>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<ul>
<li><strong>Sound Playback</strong> - WAV, OGG, MP3, FLAC support</li>
<li><strong>Spatial Audio</strong> - 3D positioned sound sources with distance attenuation</li>
<li><strong>FFT Analysis</strong> - Real-time spectral analysis for music visualizers</li>
</ul>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<ul>
<li><strong>Keyboard &amp; Mouse</strong> - Full key detection with press/release states</li>
<li><strong>Gamepad</strong> - Controller support with analog sticks, triggers, and rumble</li>
<li><strong>Cursor Control</strong> - Lock and hide cursor for FPS-style games</li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><strong>Navigation Mesh</strong> - AI pathfinding with Recast integration</li>
<li><strong>Debug Rendering</strong> - Lines, boxes, spheres for visualization</li>
<li><strong>HUD Text</strong> - Screen-space text rendering with anchoring</li>
<li><strong>Screenshot Capture</strong> - Save frames to PNG</li>
<li><strong>Developer Console</strong> - In-game command console with custom commands</li>
</ul>
<h3 id="platform"><a class="header" href="#platform">Platform</a></h3>
<ul>
<li><strong>OpenXR VR</strong> - Virtual reality with head/hand tracking and locomotion</li>
<li><strong>Steam</strong> - Achievements, stats, multiplayer, and friends integration</li>
<li><strong>Webview</strong> - Host web frontends (Leptos, Yew) with bidirectional IPC</li>
<li><strong>Mosaic</strong> - Multi-pane desktop application framework with dockable widgets</li>
<li><strong>WASM Plugins</strong> - Extend the engine with WebAssembly plugins</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Nightshade follows a simple architecture centered around the <code>State</code> trait and the <code>World</code> container:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                      Your Game (State)                       │
├─────────────────────────────────────────────────────────────┤
│  initialize()  │  run_systems()  │  ui()  │  input handlers │
└────────────────┴─────────────────┴────────┴─────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                          World                               │
├──────────────────┬──────────────────┬───────────────────────┤
│     Entities     │    Components    │      Resources        │
│  (unique IDs)    │  (data arrays)   │  (global singletons)  │
└──────────────────┴──────────────────┴───────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌───────────────┐    ┌───────────────┐    ┌───────────────┐
│   Renderer    │    │    Physics    │    │     Audio     │
│    (wgpu)     │    │   (Rapier)    │    │    (Kira)     │
└───────────────┘    └───────────────┘    └───────────────┘
</code></pre>
<h3 id="the-game-loop"><a class="header" href="#the-game-loop">The Game Loop</a></h3>
<p>Each frame, Nightshade:</p>
<ol>
<li>Processes window and input events</li>
<li>Calls your <code>run_systems()</code> method</li>
<li>Updates physics simulation</li>
<li>Propagates transform hierarchies</li>
<li>Renders the scene</li>
<li>Presents to the screen</li>
</ol>
<p>You control game logic in <code>run_systems()</code>, and the engine handles everything else.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>Nightshade follows these core principles:</p>
<h3 id="simplicity"><a class="header" href="#simplicity">Simplicity</a></h3>
<p>The API surface is minimal and consistent. Common tasks like spawning entities, loading models, and handling input should be intuitive. If something feels overly complex, it's probably a bug.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>The engine uses data-oriented design throughout. The ECS stores components in contiguous arrays for cache-friendly access. The renderer batches draw calls and uses GPU instancing where possible.</p>
<h3 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h3>
<p>Feature flags let you include only what you need. Building a simple visualizer? Just use <code>engine</code>. Need physics? Add <code>physics</code>. Everything is opt-in.</p>
<h3 id="cross-platform"><a class="header" href="#cross-platform">Cross-Platform</a></h3>
<p>Write once, run everywhere. The same code runs on Windows, macOS, Linux, and WebAssembly. The engine automatically selects the appropriate graphics backend.</p>
<h2 id="when-to-use-nightshade"><a class="header" href="#when-to-use-nightshade">When to Use Nightshade</a></h2>
<p>Nightshade is well-suited for:</p>
<ul>
<li><strong>3D Games</strong> - Action games, platformers, simulations</li>
<li><strong>Visualizers</strong> - Music-reactive graphics, data visualization</li>
<li><strong>Prototypes</strong> - Quickly test game ideas</li>
<li><strong>Learning</strong> - Understanding game engine concepts</li>
</ul>
<p>Nightshade may not be ideal for:</p>
<ul>
<li><strong>2D-only games</strong> - Consider a dedicated 2D engine (though Nightshade does support sprites)</li>
<li><strong>Mobile</strong> - Not yet optimized for mobile platforms</li>
</ul>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>This documentation covers <strong>Nightshade</strong> using <strong>Rust 2024 Edition</strong>.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><a href="https://github.com/matthewjberger/nightshade">GitHub Repository</a> - Source code and issue tracker</li>
<li><a href="https://docs.rs/nightshade">API Documentation</a> - Generated API docs</li>
</ul>
<p>Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interactive-demo"><a class="header" href="#interactive-demo">Interactive Demo</a></h1>
<p>Experience Nightshade running directly in your browser via WebGPU.</p>
<div style="width: 100%; height: 500px; border: 1px solid #333; border-radius: 8px; overflow: hidden; margin: 20px 0;">
    <iframe
        src="demos/hello/index.html"
        style="width: 100%; height: 100%; border: none;"
        allow="fullscreen"
    ></iframe>
</div>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<ul>
<li><strong>Mouse Drag</strong>: Orbit the camera around the scene</li>
<li><strong>Scroll Wheel</strong>: Zoom in and out</li>
</ul>
<h2 id="what-youre-seeing"><a class="header" href="#what-youre-seeing">What You're Seeing</a></h2>
<p>This demo showcases several Nightshade features:</p>
<ul>
<li><strong>Primitives</strong>: A cube, sphere, and torus rendered with PBR materials</li>
<li><strong>Emissive Materials</strong>: Each object has emissive properties that create a glowing effect</li>
<li><strong>Bloom Post-Processing</strong>: The glow spreads beyond object boundaries</li>
<li><strong>Infinite Grid</strong>: A reference grid at ground level</li>
<li><strong>Nebula Skybox</strong>: A procedural space background</li>
<li><strong>Pan-Orbit Camera</strong>: Interactive camera controls</li>
<li><strong>Animation</strong>: Objects rotate and bob with smooth interpolation</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>This demo requires a browser with WebGPU support:</p>
<ul>
<li><strong>Chrome/Edge</strong>: Version 113+ (enabled by default)</li>
<li><strong>Firefox</strong>: Version 141+ (enabled by default)</li>
<li><strong>Safari</strong>: Version 18+ (Technology Preview)</li>
</ul>
<p>If you see a blank frame, your browser may not support WebGPU yet.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = "hello-nightshade"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade", features = ["egui"] }

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"

[profile.release]
opt-level = "z"
lto = true
</code></pre>
<h3 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(HelloNightshade::default())
}

#[derive(Default)]
struct HelloNightshade {
    cube: Option&lt;Entity&gt;,
    sphere: Option&lt;Entity&gt;,
    torus: Option&lt;Entity&gt;,
    time: f32,
}

impl State for HelloNightshade {
    fn title(&amp;self) -&gt; &amp;str {
        "Hello Nightshade"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.user_interface.enabled = false;
        world.resources.graphics.atmosphere = Atmosphere::Nebula;
        capture_procedural_atmosphere_ibl(world, Atmosphere::Nebula, 0.0);
        world.resources.graphics.bloom_enabled = true;
        world.resources.graphics.bloom_intensity = 0.15;
        world.resources.graphics.show_grid = true;

        let camera = spawn_pan_orbit_camera(
            world,
            Vec3::new(0.0, 0.0, 0.0),
            8.0,
            0.5,
            0.3,
            "Camera".to_string(),
        );
        world.resources.active_camera = Some(camera);

        spawn_sun(world);

        let cube = spawn_mesh_at(
            world,
            "Cube",
            Vec3::new(-3.0, 0.0, 0.0),
            Vec3::new(1.0, 1.0, 1.0),
        );
        spawn_material(
            world,
            cube,
            "CubeMaterial".to_string(),
            Material {
                base_color: [0.2, 0.6, 1.0, 1.0],
                metallic: 0.8,
                roughness: 0.2,
                emissive_factor: [0.1, 0.3, 0.5],
                emissive_strength: 2.0,
                ..Default::default()
            },
        );
        self.cube = Some(cube);

        let sphere = spawn_mesh_at(
            world,
            "Sphere",
            Vec3::new(0.0, 0.0, 0.0),
            Vec3::new(1.2, 1.2, 1.2),
        );
        spawn_material(
            world,
            sphere,
            "SphereMaterial".to_string(),
            Material {
                base_color: [1.0, 1.0, 1.0, 1.0],
                metallic: 1.0,
                roughness: 0.0,
                ..Default::default()
            },
        );
        self.sphere = Some(sphere);

        let torus = spawn_mesh_at(
            world,
            "Torus",
            Vec3::new(3.0, 0.0, 0.0),
            Vec3::new(0.8, 0.8, 0.8),
        );
        spawn_material(
            world,
            torus,
            "TorusMaterial".to_string(),
            Material {
                base_color: [0.3, 1.0, 0.4, 1.0],
                metallic: 0.7,
                roughness: 0.3,
                emissive_factor: [0.15, 0.5, 0.2],
                emissive_strength: 2.0,
                ..Default::default()
            },
        );
        self.torus = Some(torus);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        pan_orbit_camera_system(world);

        let dt = world.resources.window.timing.delta_time;
        self.time += dt;

        if let Some(entity) = self.cube {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.rotation = nalgebra_glm::quat_angle_axis(self.time * 0.8, &amp;Vec3::y())
                    * nalgebra_glm::quat_angle_axis(self.time * 0.5, &amp;Vec3::x());
                transform.translation.y = (self.time * 1.5).sin() * 0.5;
            }
            world.mark_local_transform_dirty(entity);
        }

        if let Some(entity) = self.sphere {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.rotation = nalgebra_glm::quat_angle_axis(self.time * 0.3, &amp;Vec3::y());
                let pulse = 1.0 + (self.time * 2.0).sin() * 0.1;
                transform.scale = Vec3::new(1.2 * pulse, 1.2 * pulse, 1.2 * pulse);
            }
            world.mark_local_transform_dirty(entity);
        }

        if let Some(entity) = self.torus {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.rotation = nalgebra_glm::quat_angle_axis(self.time * 1.2, &amp;Vec3::z())
                    * nalgebra_glm::quat_angle_axis(self.time * 0.7, &amp;Vec3::x());
                transform.translation.y = (self.time * 1.2 + 2.0).sin() * 0.5;
            }
            world.mark_local_transform_dirty(entity);
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust 1.90+</strong> with the 2024 edition</li>
<li>A graphics driver supporting Vulkan 1.2, Metal, or DirectX 12</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Clone the template repository:</p>
<pre><code class="language-bash">git clone https://github.com/matthewjberger/nightshade-template my-game
cd my-game
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">just run
</code></pre>
<p>You should see a 3D scene with a nebula skybox, a grid, and a pan-orbit camera.</p>
<h2 id="whats-in-the-template"><a class="header" href="#whats-in-the-template">What's in the Template</a></h2>
<p>The template gives you a working project with:</p>
<ul>
<li><code>src/main.rs</code> - A minimal Nightshade application with a camera, sun, and egui UI</li>
<li><code>Cargo.toml</code> - Nightshade dependency with <code>egui</code> feature enabled</li>
<li><code>justfile</code> - Build, run, lint, and deploy commands for native, WASM, VR, and Steam Deck</li>
<li><code>index.html</code> + <code>Trunk.toml</code> - WASM web build configuration</li>
<li><code>.github/workflows/</code> - CI (clippy, tests, WASM build) and GitHub Pages deployment</li>
<li><code>rust-toolchain</code> - Pinned Rust version with WASM target</li>
</ul>
<h2 id="starter-code"><a class="header" href="#starter-code">Starter Code</a></h2>
<p>The template's <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(Template)?;
    Ok(())
}

#[derive(Default)]
struct Template;

impl State for Template {
    fn title(&amp;self) -&gt; &amp;str { "Template" }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.user_interface.enabled = true;
        world.resources.graphics.show_grid = true;
        world.resources.graphics.atmosphere = Atmosphere::Nebula;
        spawn_sun(world);
        let camera_entity = spawn_pan_orbit_camera(
            world,
            Vec3::new(0.0, 0.0, 0.0),
            15.0,
            0.0,
            std::f32::consts::FRAC_PI_4,
            "Main Camera".to_string(),
        );
        world.resources.active_camera = Some(camera_entity);
    }

    fn ui(&amp;mut self, _world: &amp;mut World, ui_context: &amp;egui::Context) {
        egui::Window::new("Template").show(ui_context, |_ui| {});
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        pan_orbit_camera_system(world);
    }

    fn on_keyboard_input(
        &amp;mut self,
        world: &amp;mut World,
        key_code: KeyCode,
        key_state: KeyState,
    ) {
        if matches!((key_code, key_state), (KeyCode::KeyQ, KeyState::Pressed)) {
            world.resources.window.should_exit = true;
        }
    }
}</code></pre></pre>
<h2 id="justfile-commands"><a class="header" href="#justfile-commands">Justfile Commands</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>just run</code></td><td>Build and run in release mode</td></tr>
<tr><td><code>just run-wasm</code></td><td>Build for web and open in browser</td></tr>
<tr><td><code>just lint</code></td><td>Run clippy with warnings as errors</td></tr>
<tr><td><code>just test</code></td><td>Run the test suite</td></tr>
<tr><td><code>just build-wasm</code></td><td>Build WASM release only</td></tr>
<tr><td><code>just run-openxr</code></td><td>Run with VR headset support</td></tr>
</tbody></table>
</div>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>The template enables <code>egui</code> by default. Add more features in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { version = "0.6.70", features = ["egui", "physics", "audio"] }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>egui</code></td><td>Immediate-mode UI</td></tr>
<tr><td><code>physics</code></td><td>Rapier3D physics simulation</td></tr>
<tr><td><code>audio</code></td><td>Kira audio playback</td></tr>
<tr><td><code>gamepad</code></td><td>Gamepad input via gilrs</td></tr>
<tr><td><code>openxr</code></td><td>VR headset support</td></tr>
<tr><td><code>steam</code></td><td>Steamworks integration</td></tr>
<tr><td><code>scripting</code></td><td>WASM plugin system</td></tr>
</tbody></table>
</div>
<p>See the <a href="appendix-features.html">Feature Flags</a> appendix for the complete list.</p>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>DirectX 12 is the default backend. Ensure your graphics drivers are up to date.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>Metal is used automatically. No additional setup required.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Vulkan is required. Install Vulkan drivers for your GPU:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install vulkan-tools libvulkan-dev

# Fedora
sudo dnf install vulkan-tools vulkan-loader-devel

# Arch
sudo pacman -S vulkan-tools vulkan-icd-loader
</code></pre>
<h3 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h3>
<p>WebGPU support requires a compatible browser (Chrome 113+, Firefox 121+). The template includes <code>just run-wasm</code> which uses Trunk to build and serve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h1>
<p>Let's create a simple application that displays a 3D scene with a camera, lighting, and some cubes.</p>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>Every Nightshade application implements the <code>State</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(MyGame::default())
}

#[derive(Default)]
struct MyGame;

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My First Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
    }
}</code></pre></pre>
<h2 id="adding-a-camera"><a class="header" href="#adding-a-camera">Adding a Camera</a></h2>
<p>The camera determines what the player sees:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(
        world,
        Vec3::new(0.0, 5.0, 10.0),
        "Main Camera".to_string(),
    );
    world.resources.active_camera = Some(camera);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-lighting"><a class="header" href="#adding-lighting">Adding Lighting</a></h2>
<p>Without lights, everything is dark. Add a directional light (sun):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_sun(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="enabling-the-grid"><a class="header" href="#enabling-the-grid">Enabling the Grid</a></h2>
<p>For development, a ground grid is helpful:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.show_grid = true;
    world.resources.graphics.atmosphere = Atmosphere::Sky;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-geometry"><a class="header" href="#adding-geometry">Adding Geometry</a></h2>
<p>Spawn a cube using the built-in primitive (available from the prelude):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_cube_at(world, Vec3::new(0.0, 1.0, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-controls"><a class="header" href="#camera-controls">Camera Controls</a></h2>
<p>Add a fly camera system so you can navigate the scene:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    fly_camera_system(world);
    escape_key_exit_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(MyGame::default())
}

#[derive(Default)]
struct MyGame;

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My First Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.graphics.show_grid = true;
        world.resources.graphics.atmosphere = Atmosphere::Sky;

        let camera = spawn_camera(
            world,
            Vec3::new(0.0, 5.0, 10.0),
            "Main Camera".to_string(),
        );
        world.resources.active_camera = Some(camera);

        spawn_sun(world);

        spawn_cube_at(world, Vec3::new(0.0, 1.0, 0.0));
        spawn_cube_at(world, Vec3::new(3.0, 0.5, 0.0));
        spawn_cube_at(world, Vec3::new(-2.0, 1.5, 2.0));
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        fly_camera_system(world);
        escape_key_exit_system(world);
    }
}</code></pre></pre>
<h2 id="controls-1"><a class="header" href="#controls-1">Controls</a></h2>
<p>With the fly camera system enabled:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Action</th></tr></thead><tbody>
<tr><td>W/A/S/D</td><td>Move forward/left/back/right</td></tr>
<tr><td>Space</td><td>Move up</td></tr>
<tr><td>Shift</td><td>Move down</td></tr>
<tr><td>Mouse</td><td>Look around</td></tr>
<tr><td>Escape</td><td>Exit</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have a basic scene, explore:</p>
<ul>
<li><a href="meshes-models.html">Meshes &amp; Models</a> - Load 3D models</li>
<li><a href="materials.html">Materials</a> - Customize appearance</li>
<li><a href="physics-overview.html">Physics</a> - Add physics simulation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<h2 id="recommended-layout"><a class="header" href="#recommended-layout">Recommended Layout</a></h2>
<p>A typical Nightshade project follows this structure:</p>
<pre><code>my_game/
├── Cargo.toml
├── src/
│   ├── main.rs           # Entry point
│   ├── game.rs           # Game state
│   └── systems/          # Game systems
│       ├── player.rs
│       ├── camera.rs
│       └── ...
├── assets/
│   ├── models/           # glTF/GLB files
│   ├── textures/         # PNG, JPG, HDR
│   └── sounds/           # Audio files
└── README.md
</code></pre>
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "my_game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade.git", features = ["engine", "wgpu"] }
</code></pre>
<h2 id="entry-point-mainrs"><a class="header" href="#entry-point-mainrs">Entry Point (main.rs)</a></h2>
<p>Keep <code>main.rs</code> minimal:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod game;

use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(game::MyGame::default())
}</code></pre></pre>
<h2 id="game-state-gamers"><a class="header" href="#game-state-gamers">Game State (game.rs)</a></h2>
<p>Implement your game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

#[derive(Default)]
pub struct MyGame {
    player: Option&lt;Entity&gt;,
    score: u32,
}

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Setup code
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        // Per-frame logic
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="embedding-assets"><a class="header" href="#embedding-assets">Embedding Assets</a></h2>
<p>For distribution, embed assets directly in the binary:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MODEL_BYTES: &amp;[u8] = include_bytes!("../assets/models/character.glb");
const SKY_HDR: &amp;[u8] = include_bytes!("../assets/textures/sky.hdr");
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-ecs"><a class="header" href="#custom-ecs">Custom ECS</a></h2>
<p>For complex games, create a separate game ECS alongside the engine's World:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use freecs::ecs;

ecs! {
    GameWorld {
        components {
            player_state: PlayerState,
            inventory: Inventory,
            health: Health,
        },
        resources {
            game_time: GameTime,
            score: u32,
        }
    }
}

pub struct MyGame {
    game: GameWorld,
}
<span class="boring">}</span></code></pre></pre>
<p>This keeps game-specific data separate from engine data while allowing both to coexist.</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module Organization</a></h2>
<p>For larger projects, organize systems into modules:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/systems/mod.rs
pub mod camera;
pub mod player;
pub mod enemies;
pub mod ui;

// src/game.rs
mod systems;

impl State for MyGame {
    fn run_systems(&amp;mut self, world: &amp;mut World) {
        systems::player::update(&amp;mut self.game, world);
        systems::camera::follow(&amp;self.game, world);
        systems::enemies::ai(&amp;mut self.game, world);
        systems::ui::update(&amp;self.game, world);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h1>
<p>Nightshade is organized as a layered dependency graph (DAG). Each layer builds on the one below it, and no layer references anything above it. This chapter shows how the pieces fit together.</p>
<pre><code>Feature Layer:     Terrain, Particles, NavMesh, Grass, SDF, Lattice, Scripting
                            |
Application Layer: State Trait, Main Loop, Event Bus
                            |
Rendering Layer:   Render Graph -&gt; Passes -&gt; Materials -&gt; Textures -&gt; Shaders
                            |
Simulation Layer:  Physics (Rapier), Animation, Audio (Kira)
                            |
Core Layer:        World, Transform Hierarchy, Input, Time, Windowing
                            |
Foundation Layer:  ECS (freecs), Math (nalgebra_glm), GPU (wgpu)
</code></pre>
<h2 id="foundation-layer"><a class="header" href="#foundation-layer">Foundation Layer</a></h2>
<p>The lowest layer contains three independent systems that everything else depends on.</p>
<p><strong>ECS (freecs)</strong> provides compile-time code-generated entity storage with struct-of-arrays layout. The <code>ecs!</code> macro generates the <code>World</code> struct, component accessors, query methods, and entity management. Zero <code>unsafe</code> code, all statically dispatched.</p>
<p><strong>Math (nalgebra_glm)</strong> provides vectors (<code>Vec2</code>, <code>Vec3</code>, <code>Vec4</code>), matrices (<code>Mat4</code>), quaternions (<code>Quat</code>), and all standard linear algebra operations. Nightshade uses nalgebra_glm exclusively for all math.</p>
<p><strong>GPU (wgpu)</strong> provides cross-platform GPU access. wgpu targets Vulkan, Metal, DirectX 12, and WebGPU from a single API surface.</p>
<h2 id="core-layer"><a class="header" href="#core-layer">Core Layer</a></h2>
<p>Built on the foundation, the core layer manages per-frame state and the entity hierarchy.</p>
<p><strong>World</strong> is the central data container generated by the <code>freecs::ecs!</code> macro. It holds all entity storage and a <code>Resources</code> struct containing global singletons (timing, input, graphics settings, caches, physics world, audio engine, etc.).</p>
<p><strong>Transform Hierarchy</strong> propagates <code>LocalTransform</code> through parent-child relationships to compute <code>GlobalTransform</code> matrices each frame. Dirty-flag tracking ensures only modified subtrees are recomputed.</p>
<p><strong>Input</strong> aggregates keyboard, mouse, and gamepad state each frame into <code>world.resources.input</code>. Provides both polling (<code>is_key_pressed</code>) and event-driven (<code>on_keyboard_input</code>) access patterns.</p>
<p><strong>Time</strong> is accessed through <code>world.resources.window.timing</code> and provides <code>delta_time</code>, <code>frames_per_second</code>, <code>uptime_milliseconds</code>, <code>frame_counter</code>, and raw/speed-adjusted variants.</p>
<p><strong>Windowing</strong> wraps winit for window creation, event handling, and surface management. On native platforms, secondary windows are supported via <code>SecondaryWindows</code>.</p>
<h2 id="simulation-layer"><a class="header" href="#simulation-layer">Simulation Layer</a></h2>
<p>Systems that update world state each frame, independent of rendering.</p>
<p><strong>Physics (Rapier3D)</strong> runs at a fixed 60Hz timestep with interpolation for smooth rendering. Provides rigid bodies, colliders, character controllers, joints, and raycasting. Gated behind the <code>physics</code> feature flag.</p>
<p><strong>Animation</strong> plays back skeletal animations loaded from glTF files. Supports blending, crossfading, speed control, and looping. Bone transforms are written directly into the ECS each frame.</p>
<p><strong>Audio (Kira)</strong> handles sound playback with spatial positioning, distance attenuation, and FFT analysis. Gated behind the <code>audio</code> feature flag.</p>
<h2 id="rendering-layer"><a class="header" href="#rendering-layer">Rendering Layer</a></h2>
<p>Transforms ECS data into pixels on screen.</p>
<p><strong>Render Graph</strong> is a dependency-driven frame graph built on petgraph. Passes declare which resources they read and write via named slots. The graph automatically builds dependency edges, topologically sorts passes, computes resource lifetimes, aliases transient GPU memory, and determines optimal load/store operations.</p>
<p><strong>Passes</strong> implement the <code>PassNode</code> trait. Each pass owns its GPU pipelines and bind group layouts. Built-in passes cover shadow mapping, PBR mesh rendering, skeletal animation, water, grass, particles, text, UI, and post-processing (SSAO, SSGI, SSR, bloom, depth of field, tonemapping, effects).</p>
<p><strong>Materials</strong> use a PBR metallic-roughness workflow stored in a <code>MaterialRegistry</code>. Materials reference textures by name and are assigned to entities via <code>MaterialRef</code>.</p>
<p><strong>Textures</strong> are managed by a <code>TextureCache</code> that handles GPU upload, format conversion, and atlas packing (for sprites). Textures are loaded via <code>WorldCommand::LoadTexture</code>.</p>
<p><strong>Shaders</strong> are written in WGSL and embedded at compile time via <code>include_str!</code>.</p>
<h2 id="application-layer"><a class="header" href="#application-layer">Application Layer</a></h2>
<p>The interface between engine and game code.</p>
<p><strong>State Trait</strong> is implemented by your game struct. Its methods (<code>initialize</code>, <code>run_systems</code>, <code>ui</code>, <code>configure_render_graph</code>, etc.) are called by the engine at specific points in the frame lifecycle.</p>
<p><strong>Main Loop</strong> drives the frame lifecycle: process events, update input, call <code>run_systems</code>, dispatch events, animate, propagate transforms, step physics, render, present.</p>
<p><strong>Event Bus</strong> provides decoupled communication via <code>world.resources.event_bus</code>. Supports typed app events and input messages.</p>
<h2 id="feature-layer"><a class="header" href="#feature-layer">Feature Layer</a></h2>
<p>High-level gameplay systems built on everything below.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Dependencies</th></tr></thead><tbody>
<tr><td>Terrain</td><td>Rendering (mesh generation, tessellation), Physics (heightfield collider)</td></tr>
<tr><td>Particles</td><td>Rendering (GPU billboard pass), ECS (emitter component)</td></tr>
<tr><td>NavMesh</td><td>Physics (geometry), ECS (agent component), Core (transforms)</td></tr>
<tr><td>Grass</td><td>Rendering (instanced GPU pass), ECS (region component)</td></tr>
<tr><td>SDF Sculpting</td><td>Rendering (compute + raymarching), ECS (SDF world resource)</td></tr>
<tr><td>Lattice Deformation</td><td>Core (transforms), ECS (control points)</td></tr>
<tr><td>Scripting</td><td>WASM plugin runtime, ECS (component access API)</td></tr>
</tbody></table>
</div>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<p>A typical frame flows data through the layers like this:</p>
<pre><code>Input Events (winit)
    |
    v
Input State (world.resources.input)
    |
    v
Game Logic (State::run_systems)
    |
    v
ECS Mutations (spawn, despawn, set components)
    |
    v
Animation (bone transforms written to ECS)
    |
    v
Transform Propagation (LocalTransform -&gt; GlobalTransform)
    |
    v
Physics Step (Rapier simulation, sync back to ECS)
    |
    v
Render Graph Execution
    |-- Shadow Depth Pass (reads GlobalTransform, Light)
    |-- Geometry Passes (reads GlobalTransform, RenderMesh, MaterialRef)
    |-- Post-Processing (reads scene_color, depth, normals)
    |-- UI Pass (reads egui/immediate UI state)
    |-- Blit Pass (writes to swapchain)
    |
    v
Present (wgpu surface present)
</code></pre>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<p>Most subsystems are opt-in via Cargo feature flags:</p>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>What it enables</th></tr></thead><tbody>
<tr><td><code>engine</code></td><td>Core rendering, ECS, transforms, input</td></tr>
<tr><td><code>physics</code></td><td>Rapier3D physics simulation</td></tr>
<tr><td><code>audio</code></td><td>Kira audio playback</td></tr>
<tr><td><code>egui</code></td><td>egui immediate-mode UI</td></tr>
<tr><td><code>gamepad</code></td><td>Gamepad input via gilrs</td></tr>
<tr><td><code>assets</code></td><td>Image/HDR loading via the image crate</td></tr>
<tr><td><code>openxr</code></td><td>OpenXR VR support</td></tr>
<tr><td><code>steam</code></td><td>Steamworks integration</td></tr>
<tr><td><code>scripting</code></td><td>WASM plugin system</td></tr>
<tr><td><code>sdf_sculpt</code></td><td>SDF sculpting tools</td></tr>
<tr><td><code>scene_graph</code></td><td>Scene serialization</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system"><a class="header" href="#entity-component-system">Entity Component System</a></h1>
<p>Nightshade uses <strong>freecs</strong>, a compile-time code-generated ECS with struct-of-arrays (SoA) storage. freecs generates all entity management, component storage, and query methods at compile time via the <code>ecs!</code> macro, with zero <code>unsafe</code> code.</p>
<h2 id="what-is-an-ecs"><a class="header" href="#what-is-an-ecs">What is an ECS?</a></h2>
<p>An Entity Component System separates data from behavior:</p>
<ul>
<li><strong>Entities</strong> are unique identifiers (IDs). They have no data of their own.</li>
<li><strong>Components</strong> are plain data structs attached to entities. Each component type is stored in its own contiguous array.</li>
<li><strong>Systems</strong> are functions that query entities by their component masks and process matching entities.</li>
</ul>
<p>This is fundamentally different from object-oriented game architectures where a <code>GameObject</code> class owns its data and behavior through inheritance. The OOP approach leads to deep inheritance hierarchies (the "diamond problem"), poor cache locality (objects scattered across the heap), and rigid coupling between data and logic. ECS inverts this: data is organized by type, not by object, and logic operates on slices of data rather than individual objects.</p>
<h2 id="how-archetype-storage-works"><a class="header" href="#how-archetype-storage-works">How Archetype Storage Works</a></h2>
<p>freecs uses <strong>archetype-based SoA (struct-of-arrays) storage</strong>. To understand why this matters, consider how data layouts affect performance.</p>
<h3 id="array-of-structs-vs-struct-of-arrays"><a class="header" href="#array-of-structs-vs-struct-of-arrays">Array of Structs vs Struct of Arrays</a></h3>
<p>In a traditional OOP game, entities are stored as an <strong>array of structs (AoS)</strong>:</p>
<pre><code>Memory: [Entity0{pos,vel,hp,mesh}] [Entity1{pos,vel,hp,mesh}] [Entity2{pos,vel,hp,mesh}]
</code></pre>
<p>When a system iterates over all positions, it loads entire entity structs into cache lines even though it only needs the <code>pos</code> field. The rest is wasted bandwidth.</p>
<p>In <strong>SoA storage</strong>, each component type gets its own contiguous array:</p>
<pre><code>Positions:  [pos0] [pos1] [pos2] [pos3] ...
Velocities: [vel0] [vel1] [vel2] [vel3] ...
Health:     [hp0]  [hp1]  [hp2]  [hp3]  ...
</code></pre>
<p>Now a system iterating over positions reads a dense, contiguous block of memory. Every byte loaded into a cache line is useful. This can be 5-10x faster for large entity counts due to CPU cache prefetching.</p>
<h3 id="archetype-tables"><a class="header" href="#archetype-tables">Archetype Tables</a></h3>
<p>Not every entity has the same components. An entity with <code>Position | Velocity</code> is different from one with <code>Position | Velocity | Health</code>. freecs groups entities by their <strong>component mask</strong> (the exact set of components they have) into <strong>archetype tables</strong>.</p>
<p>Each table stores only entities with identical component masks. Within a table, components are stored in SoA layout:</p>
<pre><code>Table A (mask: Position | Velocity):
  positions:  [p0, p1, p2]
  velocities: [v0, v1, v2]

Table B (mask: Position | Velocity | Health):
  positions:  [p3, p4]
  velocities: [v3, v4]
  healths:    [h3, h4]
</code></pre>
<p>When querying for <code>Position | Velocity</code>, the ECS checks each table's mask with a single bitwise AND. Table A matches, Table B also matches (it has a superset of the requested components). Tables whose masks don't include all requested components are skipped entirely without examining any entities.</p>
<h3 id="component-masks-as-bitflags"><a class="header" href="#component-masks-as-bitflags">Component Masks as Bitflags</a></h3>
<p>Each component is assigned a bit position at compile time. An entity's component mask is a single integer where bit N is set if the entity has component N:</p>
<pre><code>LOCAL_TRANSFORM    = 0b0001
GLOBAL_TRANSFORM   = 0b0010
RENDER_MESH        = 0b0100
MATERIAL_REF       = 0b1000
</code></pre>
<p>Querying <code>query_entities(RENDER_MESH | LOCAL_TRANSFORM)</code> becomes <code>table_mask &amp; query_mask == query_mask</code>, which is two CPU instructions (AND + CMP). This is why ECS queries scale to millions of entities.</p>
<h2 id="why-freecs"><a class="header" href="#why-freecs">Why freecs?</a></h2>
<p>freecs generates all ECS infrastructure at compile time from a single macro invocation. This means:</p>
<ul>
<li><strong>No runtime overhead</strong> for component lookups - everything is statically dispatched, no vtables, no hash lookups</li>
<li><strong>SoA storage</strong> - components of the same type are stored in contiguous arrays, optimal for CPU cache utilization</li>
<li><strong>Archetype tables</strong> - entities with the same component mask share a table, so queries skip irrelevant entities entirely</li>
<li><strong>Zero <code>unsafe</code></strong> - the generated code uses only safe Rust</li>
<li><strong>Bitflag queries</strong> - component presence is checked with bitmask operations, which is a single CPU instruction</li>
<li><strong>Compile-time monomorphization</strong> - accessor methods like <code>get_local_transform()</code> compile down to a direct array index with no indirection</li>
</ul>
<h2 id="quick-overview"><a class="header" href="#quick-overview">Quick Overview</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

// Spawn an entity with transform and mesh components
let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF,
    1,
)[0];

// Set component values
world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 5.0, 0.0),
    rotation: Quat::identity(),
    scale: Vec3::new(1.0, 1.0, 1.0),
});
world.set_render_mesh(entity, RenderMesh {
    name: "cube".to_string(),
    id: None,
});
world.set_material_ref(entity, MaterialRef::new("Default"));

// Query all entities with a specific set of components
for entity in world.query_entities(RENDER_MESH | LOCAL_TRANSFORM) {
    let transform = world.get_local_transform(entity).unwrap();
    let mesh = world.get_render_mesh(entity).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="component-flags"><a class="header" href="#component-flags">Component Flags</a></h2>
<p>Each component has a corresponding bitflag constant. Combine flags with <code>|</code> to describe which components an entity has:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RENDERABLE: ComponentFlags =
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF;

let entity = world.spawn_entities(RENDERABLE, 1)[0];
<span class="boring">}</span></code></pre></pre>
<p>The full list of built-in component flags is in the <a href="components.html">Components</a> chapter.</p>
<h2 id="custom-game-ecs"><a class="header" href="#custom-game-ecs">Custom Game ECS</a></h2>
<p>For complex games, define a separate ECS for game-specific data:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use freecs::ecs;

ecs! {
    GameWorld {
        player_state: PlayerState =&gt; PLAYER_STATE,
        inventory: Inventory =&gt; INVENTORY,
        health: Health =&gt; HEALTH,
        enemy_ai: EnemyAI =&gt; ENEMY_AI,
    }
    Resources {
        game_time: GameTime,
        score: u32,
        level: u32,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Then use both worlds together in your State:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGame {
    game: GameWorld,
}

impl State for MyGame {
    fn run_systems(&amp;mut self, world: &amp;mut World) {
        update_player(&amp;mut self.game);
        sync_positions(&amp;self.game, world);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter-guide"><a class="header" href="#chapter-guide">Chapter Guide</a></h2>
<ul>
<li><a href="ecs-macro.html">The freecs Macro</a> - Full macro syntax and what gets generated</li>
<li><a href="entities.html">Entities</a> - Spawning, despawning, and entity IDs</li>
<li><a href="components.html">Components</a> - All 48 built-in components</li>
<li><a href="queries.html">Queries &amp; Iteration</a> - Querying and iterating over entities</li>
<li><a href="ecs-resources.html">Resources</a> - Global singleton data</li>
<li><a href="tags-events-commands.html">Tags, Events &amp; Commands</a> - Events, command buffers, and deferred operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-freecs-macro"><a class="header" href="#the-freecs-macro">The freecs Macro</a></h1>
<p>The <code>freecs::ecs!</code> macro generates the entire World struct, component storage, accessors, query methods, and entity management from a declarative definition.</p>
<h2 id="macro-syntax"><a class="header" href="#macro-syntax">Macro Syntax</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>freecs::ecs! {
    World {
        // Components: field_name: Type =&gt; FLAG_NAME,
        local_transform: LocalTransform =&gt; LOCAL_TRANSFORM,
        global_transform: GlobalTransform =&gt; GLOBAL_TRANSFORM,
        render_mesh: RenderMesh =&gt; RENDER_MESH,
        material_ref: MaterialRef =&gt; MATERIAL_REF,
        camera: Camera =&gt; CAMERA,
        light: Light =&gt; LIGHT,
        // ... more components
    }
    Resources {
        // Global singletons: field_name: Type,
        window: Window,
        input: Input,
        graphics: Graphics,
        active_camera: Option&lt;Entity&gt;,
        // ... more resources
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Each line in the component block declares:</p>
<ol>
<li>A <strong>field name</strong> (snake_case) - used to generate accessor methods</li>
<li>A <strong>type</strong> - the Rust struct stored for this component</li>
<li>A <strong>flag constant</strong> (UPPER_SNAKE_CASE) - the bitflag for queries</li>
</ol>
<h2 id="what-gets-generated"><a class="header" href="#what-gets-generated">What Gets Generated</a></h2>
<p>From the macro invocation, freecs generates:</p>
<h3 id="the-world-struct"><a class="header" href="#the-world-struct">The World Struct</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct World {
    // Internal entity storage (archetype tables, free lists, etc.)
    entities: EntityStorage,
    // All global resources
    pub resources: Resources,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="per-component-accessors"><a class="header" href="#per-component-accessors">Per-Component Accessors</a></h3>
<p>For each component <code>foo: Foo =&gt; FOO</code>, the macro generates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Immutable access
world.get_foo(entity) -&gt; Option&lt;&amp;Foo&gt;

// Mutable access
world.get_foo_mut(entity) -&gt; Option&lt;&amp;mut Foo&gt;

// Set value
world.set_foo(entity, value: Foo)
<span class="boring">}</span></code></pre></pre>
<h3 id="entity-management"><a class="header" href="#entity-management">Entity Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn entities with a component mask
world.spawn_entities(flags: ComponentFlags, count: usize) -&gt; Vec&lt;Entity&gt;

// Despawn entities
world.despawn_entities(entities: &amp;[Entity])

// Check if entity has components
world.entity_has_components(entity: Entity, flags: ComponentFlags) -&gt; bool
<span class="boring">}</span></code></pre></pre>
<h3 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query entities matching a component mask
world.query_entities(flags: ComponentFlags) -&gt; impl Iterator&lt;Item = Entity&gt;

// Query and return first match
world.query_first_entity(flags: ComponentFlags) -&gt; Option&lt;Entity&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="component-flag-constants"><a class="header" href="#component-flag-constants">Component Flag Constants</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const LOCAL_TRANSFORM: ComponentFlags = 1 &lt;&lt; 0;
pub const GLOBAL_TRANSFORM: ComponentFlags = 1 &lt;&lt; 1;
pub const RENDER_MESH: ComponentFlags = 1 &lt;&lt; 2;
// ... one per component, powers of 2
<span class="boring">}</span></code></pre></pre>
<h3 id="the-resources-struct"><a class="header" href="#the-resources-struct">The Resources Struct</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Resources {
    pub window: Window,
    pub input: Input,
    pub graphics: Graphics,
    pub active_camera: Option&lt;Entity&gt;,
    // ... all declared resources with Default initialization
}
<span class="boring">}</span></code></pre></pre>
<h2 id="nightshades-world-definition"><a class="header" href="#nightshades-world-definition">Nightshade's World Definition</a></h2>
<p>Nightshade declares 48 components and 30+ resources. Here is the complete declaration (simplified paths for readability):</p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Field</th><th>Type</th><th>Category</th></tr></thead><tbody>
<tr><td><code>ANIMATION_PLAYER</code></td><td><code>animation_player</code></td><td><code>AnimationPlayer</code></td><td>Animation</td></tr>
<tr><td><code>NAME</code></td><td><code>name</code></td><td><code>Name</code></td><td>Identity</td></tr>
<tr><td><code>LOCAL_TRANSFORM</code></td><td><code>local_transform</code></td><td><code>LocalTransform</code></td><td>Transform</td></tr>
<tr><td><code>GLOBAL_TRANSFORM</code></td><td><code>global_transform</code></td><td><code>GlobalTransform</code></td><td>Transform</td></tr>
<tr><td><code>LOCAL_TRANSFORM_DIRTY</code></td><td><code>local_transform_dirty</code></td><td><code>LocalTransformDirty</code></td><td>Transform</td></tr>
<tr><td><code>PARENT</code></td><td><code>parent</code></td><td><code>Parent</code></td><td>Transform</td></tr>
<tr><td><code>IGNORE_PARENT_SCALE</code></td><td><code>ignore_parent_scale</code></td><td><code>IgnoreParentScale</code></td><td>Transform</td></tr>
<tr><td><code>AUDIO_SOURCE</code></td><td><code>audio_source</code></td><td><code>AudioSource</code></td><td>Audio</td></tr>
<tr><td><code>AUDIO_LISTENER</code></td><td><code>audio_listener</code></td><td><code>AudioListener</code></td><td>Audio</td></tr>
<tr><td><code>CAMERA</code></td><td><code>camera</code></td><td><code>Camera</code></td><td>Camera</td></tr>
<tr><td><code>PAN_ORBIT_CAMERA</code></td><td><code>pan_orbit_camera</code></td><td><code>PanOrbitCamera</code></td><td>Camera</td></tr>
<tr><td><code>LIGHT</code></td><td><code>light</code></td><td><code>Light</code></td><td>Lighting</td></tr>
<tr><td><code>LINES</code></td><td><code>lines</code></td><td><code>Lines</code></td><td>Debug</td></tr>
<tr><td><code>VISIBILITY</code></td><td><code>visibility</code></td><td><code>Visibility</code></td><td>Rendering</td></tr>
<tr><td><code>DECAL</code></td><td><code>decal</code></td><td><code>Decal</code></td><td>Rendering</td></tr>
<tr><td><code>RENDER_MESH</code></td><td><code>render_mesh</code></td><td><code>RenderMesh</code></td><td>Rendering</td></tr>
<tr><td><code>MATERIAL_REF</code></td><td><code>material_ref</code></td><td><code>MaterialRef</code></td><td>Rendering</td></tr>
<tr><td><code>RENDER_LAYER</code></td><td><code>render_layer</code></td><td><code>RenderLayer</code></td><td>Rendering</td></tr>
<tr><td><code>SPRITE</code></td><td><code>sprite</code></td><td><code>Sprite</code></td><td>2D</td></tr>
<tr><td><code>SPRITE_ANIMATOR</code></td><td><code>sprite_animator</code></td><td><code>SpriteAnimator</code></td><td>2D</td></tr>
<tr><td><code>TEXT</code></td><td><code>text</code></td><td><code>Text</code></td><td>Text</td></tr>
<tr><td><code>HUD_TEXT</code></td><td><code>hud_text</code></td><td><code>HudText</code></td><td>Text</td></tr>
<tr><td><code>TEXT_CHARACTER_COLORS</code></td><td><code>text_character_colors</code></td><td><code>TextCharacterColors</code></td><td>Text</td></tr>
<tr><td><code>TEXT_CHARACTER_BACKGROUND_COLORS</code></td><td><code>text_character_background_colors</code></td><td><code>TextCharacterBackgroundColors</code></td><td>Text</td></tr>
<tr><td><code>BOUNDING_VOLUME</code></td><td><code>bounding_volume</code></td><td><code>BoundingVolume</code></td><td>Spatial</td></tr>
<tr><td><code>HOVERED</code></td><td><code>hovered</code></td><td><code>Hovered</code></td><td>Input</td></tr>
<tr><td><code>ROTATION</code></td><td><code>rotation</code></td><td><code>Rotation</code></td><td>Transform</td></tr>
<tr><td><code>CASTS_SHADOW</code></td><td><code>casts_shadow</code></td><td><code>CastsShadow</code></td><td>Rendering</td></tr>
<tr><td><code>RIGID_BODY</code></td><td><code>rigid_body</code></td><td><code>RigidBodyComponent</code></td><td>Physics</td></tr>
<tr><td><code>COLLIDER</code></td><td><code>collider</code></td><td><code>ColliderComponent</code></td><td>Physics</td></tr>
<tr><td><code>PHYSICS_MATERIAL</code></td><td><code>physics_material</code></td><td><code>PhysicsMaterialComponent</code></td><td>Physics</td></tr>
<tr><td><code>CHARACTER_CONTROLLER</code></td><td><code>character_controller</code></td><td><code>CharacterControllerComponent</code></td><td>Physics</td></tr>
<tr><td><code>PHYSICS_INTERPOLATION</code></td><td><code>physics_interpolation</code></td><td><code>PhysicsInterpolation</code></td><td>Physics</td></tr>
<tr><td><code>INSTANCED_MESH</code></td><td><code>instanced_mesh</code></td><td><code>InstancedMesh</code></td><td>Rendering</td></tr>
<tr><td><code>PARTICLE_EMITTER</code></td><td><code>particle_emitter</code></td><td><code>ParticleEmitter</code></td><td>Particles</td></tr>
<tr><td><code>PREFAB_SOURCE</code></td><td><code>prefab_source</code></td><td><code>PrefabSource</code></td><td>Prefabs</td></tr>
<tr><td><code>PREFAB_INSTANCE</code></td><td><code>prefab_instance</code></td><td><code>PrefabInstance</code></td><td>Prefabs</td></tr>
<tr><td><code>SCRIPT</code></td><td><code>script</code></td><td><code>Script</code></td><td>Scripting</td></tr>
<tr><td><code>SKIN</code></td><td><code>skin</code></td><td><code>Skin</code></td><td>Animation</td></tr>
<tr><td><code>JOINT</code></td><td><code>joint</code></td><td><code>Joint</code></td><td>Animation</td></tr>
<tr><td><code>MORPH_WEIGHTS</code></td><td><code>morph_weights</code></td><td><code>MorphWeights</code></td><td>Animation</td></tr>
<tr><td><code>NAVMESH_AGENT</code></td><td><code>navmesh_agent</code></td><td><code>NavMeshAgent</code></td><td>Navigation</td></tr>
<tr><td><code>LATTICE</code></td><td><code>lattice</code></td><td><code>Lattice</code></td><td>Deformation</td></tr>
<tr><td><code>LATTICE_INFLUENCED</code></td><td><code>lattice_influenced</code></td><td><code>LatticeInfluenced</code></td><td>Deformation</td></tr>
<tr><td><code>WATER</code></td><td><code>water</code></td><td><code>Water</code></td><td>Rendering</td></tr>
<tr><td><code>GRASS_REGION</code></td><td><code>grass_region</code></td><td><code>GrassRegion</code></td><td>Rendering</td></tr>
<tr><td><code>GRASS_INTERACTOR</code></td><td><code>grass_interactor</code></td><td><code>GrassInteractor</code></td><td>Rendering</td></tr>
</tbody></table>
</div>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<p>The <code>Resources</code> block includes:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Feature Gate</th></tr></thead><tbody>
<tr><td><code>window</code></td><td><code>Window</code></td><td>always</td></tr>
<tr><td><code>secondary_windows</code></td><td><code>SecondaryWindows</code></td><td>always</td></tr>
<tr><td><code>user_interface</code></td><td><code>UserInterface</code></td><td>always</td></tr>
<tr><td><code>immediate_ui</code></td><td><code>ImmediateUi</code></td><td>always</td></tr>
<tr><td><code>graphics</code></td><td><code>Graphics</code></td><td>always</td></tr>
<tr><td><code>input</code></td><td><code>Input</code></td><td>always</td></tr>
<tr><td><code>audio</code></td><td><code>AudioEngine</code></td><td><code>audio</code></td></tr>
<tr><td><code>physics</code></td><td><code>PhysicsWorld</code></td><td><code>physics</code></td></tr>
<tr><td><code>navmesh</code></td><td><code>NavMeshWorld</code></td><td>always</td></tr>
<tr><td><code>text_cache</code></td><td><code>TextCache</code></td><td>always</td></tr>
<tr><td><code>mesh_cache</code></td><td><code>MeshCache</code></td><td>always</td></tr>
<tr><td><code>animation_cache</code></td><td><code>AnimationCache</code></td><td>always</td></tr>
<tr><td><code>prefab_cache</code></td><td><code>PrefabCache</code></td><td>always</td></tr>
<tr><td><code>material_registry</code></td><td><code>MaterialRegistry</code></td><td>always</td></tr>
<tr><td><code>texture_cache</code></td><td><code>TextureCache</code></td><td>always</td></tr>
<tr><td><code>active_camera</code></td><td><code>Option&lt;Entity&gt;</code></td><td>always</td></tr>
<tr><td><code>event_bus</code></td><td><code>EventBus</code></td><td>always</td></tr>
<tr><td><code>command_queue</code></td><td><code>Vec&lt;WorldCommand&gt;</code></td><td>always</td></tr>
<tr><td><code>entity_names</code></td><td><code>HashMap&lt;String, Entity&gt;</code></td><td>always</td></tr>
</tbody></table>
</div>
<p>Conditional resources are included only when their feature flag is enabled, using <code>#[cfg(feature = "...")]</code> attributes in the macro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>Entities are unique identifiers that group components together. An entity is just an ID - it has no data of its own.</p>
<h2 id="entity-type"><a class="header" href="#entity-type">Entity Type</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use freecs::Entity;
<span class="boring">}</span></code></pre></pre>
<p><code>Entity</code> is a lightweight handle containing a generation and an index. Generations prevent dangling references - if an entity is despawned and its slot reused, the old <code>Entity</code> handle will no longer match.</p>
<h2 id="spawning-entities"><a class="header" href="#spawning-entities">Spawning Entities</a></h2>
<h3 id="basic-spawning"><a class="header" href="#basic-spawning">Basic Spawning</a></h3>
<p>Spawn entities with <code>spawn_entities</code>, specifying component flags and count:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF,
    1,
)[0];
<span class="boring">}</span></code></pre></pre>
<p>Then set component values:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),
    rotation: Quat::identity(),
    scale: Vec3::new(1.0, 1.0, 1.0),
});

world.set_render_mesh(entity, RenderMesh {
    name: "cube".to_string(),
    id: None,
});

world.set_material_ref(entity, MaterialRef::new("Default"));
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-spawning"><a class="header" href="#batch-spawning">Batch Spawning</a></h3>
<p>Spawn multiple entities at once:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entities = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 100);

for (index, entity) in entities.iter().enumerate() {
    world.set_local_transform(*entity, LocalTransform {
        translation: Vec3::new(index as f32 * 2.0, 0.0, 0.0),
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h3>
<p>Nightshade provides convenience functions for common entities:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Primitives
spawn_cube_at(world, Vec3::new(0.0, 1.0, 0.0));
spawn_sphere_at(world, Vec3::new(2.0, 1.0, 0.0));
spawn_plane_at(world, Vec3::zeros());
spawn_cylinder_at(world, Vec3::new(4.0, 1.0, 0.0));
spawn_cone_at(world, Vec3::new(6.0, 1.0, 0.0));
spawn_torus_at(world, Vec3::new(8.0, 1.0, 0.0));

// Camera
let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Main Camera".to_string());
world.resources.active_camera = Some(camera);

// Sun light
let sun = spawn_sun(world);

// First-person player with character controller
let (player_entity, camera_entity) = spawn_first_person_player(world, Vec3::new(0.0, 2.0, 0.0));
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-models"><a class="header" href="#loading-models">Loading Models</a></h3>
<p>Load glTF/GLB models:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

let model_bytes = include_bytes!("../assets/character.glb");
let result = import_gltf_from_bytes(model_bytes)?;

for (name, (rgba_data, width, height)) in result.textures {
    world.queue_command(WorldCommand::LoadTexture {
        name,
        rgba_data,
        width,
        height,
    });
}

for (name, mesh) in result.meshes {
    mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
}

for prefab in result.prefabs {
    spawn_prefab_with_animations(
        world,
        &amp;prefab,
        &amp;result.animations,
        Vec3::new(0.0, 0.0, 0.0),
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="despawning-entities"><a class="header" href="#despawning-entities">Despawning Entities</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Despawn specific entities
world.despawn_entities(&amp;[entity]);

// Despawn entity and all children recursively
despawn_recursive_immediate(world, entity);

// Deferred despawn via command queue
world.queue_command(WorldCommand::DespawnRecursive { entity });
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-components"><a class="header" href="#checking-components">Checking Components</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.entity_has_components(entity, RENDER_MESH) {
    // Entity has a mesh
}

if world.entity_has_components(entity, ANIMATION_PLAYER | SKIN) {
    // Entity is an animated skinned model
}
<span class="boring">}</span></code></pre></pre>
<h2 id="parent-child-relationships"><a class="header" href="#parent-child-relationships">Parent-Child Relationships</a></h2>
<p>Spawn an entity as a child of another:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parent = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];
let child = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM | PARENT, 1)[0];

world.set_parent(child, Parent(Some(parent)));
world.set_local_transform(child, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<p>See <a href="scene-hierarchy.html">Transform Hierarchy</a> for details on parent-child transforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Nightshade provides 44 built-in components across several categories.</p>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>LocalTransform</code></td><td>Position, rotation, scale relative to parent</td></tr>
<tr><td><code>GlobalTransform</code></td><td>Computed world-space transformation matrix</td></tr>
<tr><td><code>LocalTransformDirty</code></td><td>Marker for transforms needing propagation</td></tr>
<tr><td><code>Parent</code></td><td>Parent entity reference for hierarchy</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalTransform {
    pub translation: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}

pub struct GlobalTransform(pub Mat4);

pub struct Parent(pub Option&lt;Entity&gt;);
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-components"><a class="header" href="#rendering-components">Rendering Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RenderMesh</code></td><td>References mesh by name</td></tr>
<tr><td><code>MaterialRef</code></td><td>References material by name</td></tr>
<tr><td><code>Sprite</code></td><td>2D billboard rendering</td></tr>
<tr><td><code>RenderLayer</code></td><td>Depth/layer for ordering</td></tr>
<tr><td><code>CastsShadow</code></td><td>Marks mesh for shadow maps</td></tr>
<tr><td><code>Visibility</code></td><td>Visibility toggle</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderMesh {
    pub name: String,
    pub id: Option&lt;MeshId&gt;,
}

pub struct MaterialRef {
    pub name: String,
    pub id: Option&lt;MaterialId&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>MaterialRef::new(name)</code> takes <code>impl Into&lt;String&gt;</code>, so you can pass <code>&amp;str</code> directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MaterialRef::new("Default")
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-components"><a class="header" href="#camera-components">Camera Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Camera</code></td><td>Projection mode and smoothing</td></tr>
<tr><td><code>PanOrbitCamera</code></td><td>Orbiting camera controller</td></tr>
</tbody></table>
</div>
<p>There is a single <code>CAMERA</code> component flag. The projection type is determined by the <code>Projection</code> enum inside the <code>Camera</code> struct:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Camera {
    pub projection: Projection,
    pub smoothing: Option&lt;Smoothing&gt;,
}

pub enum Projection {
    Perspective(PerspectiveCamera),
    Orthographic(OrthographicCamera),
}

pub struct PerspectiveCamera {
    pub aspect_ratio: Option&lt;f32&gt;,
    pub y_fov_rad: f32,
    pub z_far: Option&lt;f32&gt;,
    pub z_near: f32,
}

pub struct OrthographicCamera {
    pub x_mag: f32,
    pub y_mag: f32,
    pub z_far: f32,
    pub z_near: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lighting"><a class="header" href="#lighting">Lighting</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Light</code></td><td>Directional, Point, or Spot light</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Light {
    pub light_type: LightType,
    pub color: Vec3,
    pub intensity: f32,
    pub range: f32,
    pub cast_shadows: bool,
    pub shadow_bias: f32,
    pub inner_cone_angle: f32,
    pub outer_cone_angle: f32,
}

pub enum LightType {
    Directional,
    Point,
    Spot,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-components"><a class="header" href="#physics-components">Physics Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RigidBodyComponent</code></td><td>Dynamic/Fixed/Kinematic body</td></tr>
<tr><td><code>ColliderComponent</code></td><td>Collision shape</td></tr>
<tr><td><code>CharacterControllerComponent</code></td><td>Kinematic player controller</td></tr>
<tr><td><code>PhysicsInterpolation</code></td><td>Smooth physics rendering</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RigidBodyComponent {
    pub handle: Option&lt;RigidBodyHandle&gt;,
    pub body_type: RigidBodyType,
    pub translation: [f32; 3],
    pub rotation: [f32; 4],
    pub linvel: [f32; 3],
    pub angvel: [f32; 3],
    pub mass: f32,
    pub locked_axes: u8,
}

pub enum RigidBodyType {
    Dynamic,
    Fixed,
    KinematicPositionBased,
    KinematicVelocityBased,
}
<span class="boring">}</span></code></pre></pre>
<p>Constructor methods:</p>
<ul>
<li><code>RigidBodyComponent::new_dynamic()</code></li>
<li><code>RigidBodyComponent::new_static()</code> (creates a <code>Fixed</code> body type)</li>
<li><code>RigidBodyComponent::new_kinematic_position_based()</code></li>
<li><code>RigidBodyComponent::new_kinematic_velocity_based()</code></li>
</ul>
<p>The component flag for rigid bodies is <code>RIGID_BODY</code> (not <code>RIGID_BODY_COMPONENT</code>).</p>
<h2 id="animation-components"><a class="header" href="#animation-components">Animation Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AnimationPlayer</code></td><td>Animation playback control</td></tr>
<tr><td><code>Skin</code></td><td>Skeleton definition</td></tr>
<tr><td><code>Joint</code></td><td>Bone in skeleton</td></tr>
<tr><td><code>MorphWeights</code></td><td>Blend shape weights</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationPlayer {
    pub clips: Vec&lt;AnimationClip&gt;,
    pub current_clip: Option&lt;usize&gt;,
    pub blend_from_clip: Option&lt;usize&gt;,
    pub blend_factor: f32,
    pub playing: bool,
    pub speed: f32,
    pub time: f32,
    pub looping: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-components"><a class="header" href="#audio-components">Audio Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AudioSource</code></td><td>Sound playback</td></tr>
<tr><td><code>AudioListener</code></td><td>3D audio receiver</td></tr>
</tbody></table>
</div>
<h2 id="geometry-components"><a class="header" href="#geometry-components">Geometry Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Text</code></td><td>3D world text</td></tr>
<tr><td><code>HudText</code></td><td>Screen-space HUD text</td></tr>
<tr><td><code>Lines</code></td><td>Debug line rendering</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lines {
    pub lines: Vec&lt;Line&gt;,
}

pub struct Line {
    pub start: Vec3,
    pub end: Vec3,
    pub color: Vec4,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-components"><a class="header" href="#advanced-components">Advanced Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ParticleEmitter</code></td><td>GPU particle system</td></tr>
<tr><td><code>GrassRegion</code></td><td>Procedural grass field</td></tr>
<tr><td><code>GrassInteractor</code></td><td>Grass bending interaction</td></tr>
<tr><td><code>NavMeshAgent</code></td><td>AI pathfinding agent</td></tr>
<tr><td><code>Water</code></td><td>Water surface/volume</td></tr>
<tr><td><code>Decal</code></td><td>Projected texture</td></tr>
<tr><td><code>Name</code></td><td>String identifier</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="queries--iteration"><a class="header" href="#queries--iteration">Queries &amp; Iteration</a></h1>
<p>Queries find entities by their component masks. Since component presence is tracked as bitflags, queries are extremely fast - a single bitmask comparison per archetype table.</p>
<h2 id="basic-queries"><a class="header" href="#basic-queries">Basic Queries</a></h2>
<p>Query entities with specific components using component flags:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM) {
    if let Some(transform) = world.get_local_transform(entity) {
        let position = transform.translation;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The query returns all entities that have <strong>at least</strong> the specified components. An entity with <code>LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH</code> will match a query for <code>LOCAL_TRANSFORM | GLOBAL_TRANSFORM</code>.</p>
<h2 id="common-query-patterns"><a class="header" href="#common-query-patterns">Common Query Patterns</a></h2>
<h3 id="renderable-entities"><a class="header" href="#renderable-entities">Renderable Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RENDERABLE: ComponentFlags =
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF;

for entity in world.query_entities(RENDERABLE) {
    let transform = world.get_global_transform(entity).unwrap();
    let mesh = world.get_render_mesh(entity).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-entities"><a class="header" href="#physics-entities">Physics Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query_entities(RIGID_BODY | LOCAL_TRANSFORM) {
    if let Some(rb) = world.get_rigid_body(entity) {
        if rb.body_type == RigidBodyType::Dynamic {
            // Process dynamic bodies
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="animated-entities"><a class="header" href="#animated-entities">Animated Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query_entities(ANIMATION_PLAYER) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.speed = 1.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="first-match"><a class="header" href="#first-match">First Match</a></h2>
<p>For singleton-like entities, use iterator methods:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let player = world.query_entities(CHARACTER_CONTROLLER).next();

if let Some(player_entity) = player {
    let controller = world.get_character_controller(player_entity);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>Combine queries with additional runtime checks:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query_entities(LIGHT) {
    let light = world.get_light(entity).unwrap();
    if light.light_type == LightType::Point {
        // Process point lights only
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="entity-count"><a class="header" href="#entity-count">Entity Count</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let renderable_count = world.query_entities(RENDER_MESH).count();
let light_count = world.query_entities(LIGHT).count();
<span class="boring">}</span></code></pre></pre>
<h2 id="named-entity-lookup"><a class="header" href="#named-entity-lookup">Named Entity Lookup</a></h2>
<p>If entities have the <code>Name</code> component:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_by_name(world: &amp;World, name: &amp;str) -&gt; Option&lt;Entity&gt; {
    for entity in world.query_entities(NAME) {
        if let Some(entity_name) = world.get_name(entity) {
            if entity_name.0 == name {
                return Some(entity);
            }
        }
    }
    None
}

let player = find_by_name(world, "Player");
<span class="boring">}</span></code></pre></pre>
<p>The engine also maintains <code>world.resources.entity_names</code> as a <code>HashMap&lt;String, Entity&gt;</code> for fast name-based lookups.</p>
<h2 id="children-queries"><a class="header" href="#children-queries">Children Queries</a></h2>
<p>Query children of a specific parent:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(children) = world.resources.children_cache.get(&amp;parent_entity) {
    for child in children {
        if let Some(transform) = world.get_local_transform(*child) {
            // Process child
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="collecting-results"><a class="header" href="#collecting-results">Collecting Results</a></h2>
<p>Collect query results for later processing (useful when you need to mutate during iteration):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let enemies: Vec&lt;Entity&gt; = world.query_entities(ENEMY_TAG | HEALTH).collect();

for enemy in &amp;enemies {
    apply_damage(world, *enemy, 10.0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iteration-with-index"><a class="header" href="#iteration-with-index">Iteration with Index</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (index, entity) in world.query_entities(RENDER_MESH).enumerate() {
    // index is the iteration position, not the entity ID
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-1"><a class="header" href="#resources-1">Resources</a></h1>
<p>Resources are global singletons stored in <code>world.resources</code>. Unlike components (which are per-entity), each resource type exists exactly once in the world.</p>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>All resources are accessed through <code>world.resources</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;

    if world.resources.input.keyboard.is_key_pressed(KeyCode::Space) {
        self.jump();
    }

    world.resources.graphics.bloom_enabled = true;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-catalog"><a class="header" href="#resource-catalog">Resource Catalog</a></h2>
<h3 id="time--window"><a class="header" href="#time--window">Time &amp; Window</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>window</code></td><td><code>Window</code></td><td>Window handle, timing, and display info</td></tr>
<tr><td><code>secondary_windows</code></td><td><code>SecondaryWindows</code></td><td>Multi-window state</td></tr>
<tr><td><code>window.timing</code></td><td><code>WindowTiming</code></td><td>Frame timing: <code>delta_time</code>, <code>frames_per_second</code>, <code>uptime_milliseconds</code></td></tr>
</tbody></table>
</div>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>input</code></td><td><code>Input</code></td><td>Keyboard, mouse, and gamepad state</td></tr>
<tr><td><code>input.keyboard</code></td><td><code>Keyboard</code></td><td>Key states, <code>is_key_pressed()</code>, <code>is_key_just_pressed()</code></td></tr>
<tr><td><code>input.mouse</code></td><td><code>Mouse</code></td><td>Position, delta, button state, scroll</td></tr>
</tbody></table>
</div>
<h3 id="graphics"><a class="header" href="#graphics">Graphics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>graphics</code></td><td><code>Graphics</code></td><td>All rendering settings</td></tr>
<tr><td><code>graphics.atmosphere</code></td><td><code>Atmosphere</code></td><td>Sky type (None, Color, Sky)</td></tr>
<tr><td><code>graphics.bloom_enabled</code></td><td><code>bool</code></td><td>Bloom toggle</td></tr>
<tr><td><code>graphics.ssao_enabled</code></td><td><code>bool</code></td><td>SSAO toggle</td></tr>
<tr><td><code>graphics.color_grading</code></td><td><code>ColorGrading</code></td><td>Tonemapping, exposure, contrast</td></tr>
</tbody></table>
</div>
<h3 id="caches"><a class="header" href="#caches">Caches</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mesh_cache</code></td><td><code>MeshCache</code></td><td>Loaded mesh data by name</td></tr>
<tr><td><code>material_registry</code></td><td><code>MaterialRegistry</code></td><td>Registered materials</td></tr>
<tr><td><code>texture_cache</code></td><td><code>TextureCache</code></td><td>GPU textures</td></tr>
<tr><td><code>animation_cache</code></td><td><code>AnimationCache</code></td><td>Animation clip data</td></tr>
<tr><td><code>prefab_cache</code></td><td><code>PrefabCache</code></td><td>Loaded prefab templates</td></tr>
<tr><td><code>text_cache</code></td><td><code>TextCache</code></td><td>Font atlas and glyph data</td></tr>
</tbody></table>
</div>
<h3 id="scene"><a class="header" href="#scene">Scene</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>active_camera</code></td><td><code>Option&lt;Entity&gt;</code></td><td>Currently rendering camera</td></tr>
<tr><td><code>children_cache</code></td><td><code>HashMap&lt;Entity, Vec&lt;Entity&gt;&gt;</code></td><td>Parent-to-children mapping</td></tr>
<tr><td><code>entity_names</code></td><td><code>HashMap&lt;String, Entity&gt;</code></td><td>Name-to-entity lookup</td></tr>
<tr><td><code>transform_dirty_entities</code></td><td><code>Vec&lt;Entity&gt;</code></td><td>Entities needing transform propagation</td></tr>
</tbody></table>
</div>
<h3 id="simulation"><a class="header" href="#simulation">Simulation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Feature</th></tr></thead><tbody>
<tr><td><code>physics</code></td><td><code>PhysicsWorld</code></td><td><code>physics</code></td></tr>
<tr><td><code>audio</code></td><td><code>AudioEngine</code></td><td><code>audio</code></td></tr>
<tr><td><code>navmesh</code></td><td><code>NavMeshWorld</code></td><td>always</td></tr>
</tbody></table>
</div>
<h3 id="communication"><a class="header" href="#communication">Communication</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>event_bus</code></td><td><code>EventBus</code></td><td>Message passing between systems</td></tr>
<tr><td><code>command_queue</code></td><td><code>Vec&lt;WorldCommand&gt;</code></td><td>Deferred GPU/scene operations</td></tr>
</tbody></table>
</div>
<h3 id="platform-1"><a class="header" href="#platform-1">Platform</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Type</th><th>Feature</th></tr></thead><tbody>
<tr><td><code>xr</code></td><td><code>XrResources</code></td><td><code>openxr</code></td></tr>
<tr><td><code>steam</code></td><td><code>SteamResources</code></td><td><code>steam</code></td></tr>
<tr><td><code>script_runtime</code></td><td><code>ScriptRuntime</code></td><td><code>scripting</code></td></tr>
<tr><td><code>sdf_world</code></td><td><code>SdfWorld</code></td><td><code>sdf_sculpt</code></td></tr>
</tbody></table>
</div>
<h2 id="conditional-resources"><a class="header" href="#conditional-resources">Conditional Resources</a></h2>
<p>Some resources are only available when their feature flag is enabled:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "physics")]
{
    world.resources.physics.gravity = Vec3::new(0.0, -9.81, 0.0);
}

#[cfg(feature = "audio")]
{
    world.resources.audio.master_volume = 0.8;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="world-commands"><a class="header" href="#world-commands">World Commands</a></h2>
<p>Operations that require GPU access or must be deferred are queued as commands:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::LoadTexture {
    name: "my_texture".to_string(),
    rgba_data: texture_bytes,
    width: 256,
    height: 256,
});

world.queue_command(WorldCommand::DespawnRecursive { entity });
world.queue_command(WorldCommand::LoadHdrSkybox { hdr_data });
world.queue_command(WorldCommand::CaptureScreenshot { path: None });
<span class="boring">}</span></code></pre></pre>
<p>Commands are processed during the render phase when GPU access is available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tags-events--commands"><a class="header" href="#tags-events--commands">Tags, Events &amp; Commands</a></h1>
<p>This chapter covers the communication and deferred-operation patterns in Nightshade's ECS.</p>
<h2 id="event-bus"><a class="header" href="#event-bus">Event Bus</a></h2>
<p>The event bus provides decoupled communication between systems via <code>world.resources.event_bus</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EventBus {
    pub messages: VecDeque&lt;Message&gt;,
}

pub enum Message {
    Input { event: InputEvent },
    App {
        type_name: &amp;'static str,
        payload: Box&lt;dyn Any + Send + Sync&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="publishing-events"><a class="header" href="#publishing-events">Publishing Events</a></h3>
<p>Define event structs and publish them:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EnemyDied {
    pub entity: Entity,
    pub position: Vec3,
}

pub struct ItemPickedUp {
    pub item_type: ItemType,
    pub quantity: u32,
}

fn combat_system(world: &amp;mut World) {
    for enemy in world.query_entities(ENEMY | HEALTH) {
        let health = world.get_health(enemy).unwrap();
        if health.current &lt;= 0.0 {
            let position = world.get_global_transform(enemy)
                .map(|t| t.0.column(3).xyz())
                .unwrap_or(Vec3::zeros());

            publish_app_event(world, EnemyDied {
                entity: enemy,
                position,
            });

            world.despawn_entities(&amp;[enemy]);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="consuming-events"><a class="header" href="#consuming-events">Consuming Events</a></h3>
<p>Process events in your game loop:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    while let Some(msg) = world.resources.event_bus.messages.pop_front() {
        match msg {
            Message::App { payload, .. } =&gt; {
                if let Some(died) = payload.downcast_ref::&lt;EnemyDied&gt;() {
                    self.handle_enemy_death(world, died);
                }
                if let Some(pickup) = payload.downcast_ref::&lt;ItemPickedUp&gt;() {
                    self.update_inventory(pickup);
                }
            }
            Message::Input { event } =&gt; {
                self.handle_input_event(event);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-patterns"><a class="header" href="#event-patterns">Event Patterns</a></h3>
<p>Events enable one-to-many communication without coupling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// One system publishes
publish_app_event(world, DoorOpened { door_id: 42 });

// Multiple handlers respond independently
if let Some(door) = payload.downcast_ref::&lt;DoorOpened&gt;() {
    trigger_cutscene(world, door.door_id);
}

if let Some(door) = payload.downcast_ref::&lt;DoorOpened&gt;() {
    play_door_sound(world, door.door_id);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="world-commands-1"><a class="header" href="#world-commands-1">World Commands</a></h2>
<p>Commands are deferred operations that require GPU access or must happen at a specific point in the frame. They are queued during <code>run_systems</code> and processed later during the render phase.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::LoadTexture {
    name: "brick".to_string(),
    rgba_data: texture_bytes,
    width: 512,
    height: 512,
});

world.queue_command(WorldCommand::DespawnRecursive { entity });
world.queue_command(WorldCommand::LoadHdrSkybox { hdr_data });
world.queue_command(WorldCommand::CaptureScreenshot { path: None });
<span class="boring">}</span></code></pre></pre>
<h3 id="available-commands"><a class="header" href="#available-commands">Available Commands</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>LoadTexture</code></td><td>Upload RGBA texture data to the GPU</td></tr>
<tr><td><code>DespawnRecursive</code></td><td>Remove entity and all children</td></tr>
<tr><td><code>LoadHdrSkybox</code></td><td>Load an HDR environment map</td></tr>
<tr><td><code>CaptureScreenshot</code></td><td>Save the next frame to a PNG</td></tr>
</tbody></table>
</div>
<h3 id="immediate-vs-deferred"><a class="header" href="#immediate-vs-deferred">Immediate vs Deferred</a></h3>
<p>For operations that don't need GPU access, use immediate functions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Immediate - happens right now
world.despawn_entities(&amp;[entity]);
despawn_recursive_immediate(world, entity);

// Deferred - happens during render phase
world.queue_command(WorldCommand::DespawnRecursive { entity });
<span class="boring">}</span></code></pre></pre>
<h2 id="state-trait-event-handling"><a class="header" href="#state-trait-event-handling">State Trait Event Handling</a></h2>
<p>The <code>State</code> trait provides a dedicated <code>handle_event</code> method for processing event bus messages:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_event(&amp;mut self, world: &amp;mut World, message: &amp;Message) {
    match message {
        Message::App { payload, .. } =&gt; {
            if let Some(event) = payload.downcast_ref::&lt;MyEvent&gt;() {
                self.process_event(world, event);
            }
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is called by the engine after <code>run_systems</code> during the event dispatch phase of the frame lifecycle.</p>
<h2 id="input-events"><a class="header" href="#input-events">Input Events</a></h2>
<p>The event bus also carries input events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum InputEvent {
    KeyboardInput { key_code: u32, state: KeyState },
    GamepadConnected { gamepad_id: usize },
    GamepadDisconnected { gamepad_id: usize },
}

pub enum KeyState {
    Pressed,
    Released,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>Keep events small - only include necessary data</li>
<li>Process events each frame - don't let the queue grow unbounded</li>
<li>Avoid circular events - A handling B which triggers A causes infinite loops</li>
<li>Use commands for GPU operations, immediate functions for pure ECS operations</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math--coordinates"><a class="header" href="#math--coordinates">Math &amp; Coordinates</a></h1>
<p>Nightshade uses <strong>nalgebra_glm</strong> exclusively for all linear algebra. This chapter covers the types, conventions, and common operations you'll use throughout the engine.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>Vec2</code></td><td>2D vector</td><td>Screen positions, UV coordinates</td></tr>
<tr><td><code>Vec3</code></td><td>3D vector</td><td>Positions, directions, colors</td></tr>
<tr><td><code>Vec4</code></td><td>4D vector</td><td>Homogeneous coordinates, RGBA colors</td></tr>
<tr><td><code>Mat4</code></td><td>4x4 matrix</td><td>Transform matrices</td></tr>
<tr><td><code>Quat</code></td><td>Quaternion</td><td>Rotations</td></tr>
</tbody></table>
</div>
<p>All types are re-exported through the prelude:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

let position = Vec3::new(1.0, 2.0, 3.0);
let direction = Vec3::y();
let identity = Mat4::identity();
let rotation = Quat::identity();
<span class="boring">}</span></code></pre></pre>
<h2 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h2>
<p>Nightshade uses a <strong>right-handed Y-up</strong> coordinate system:</p>
<pre><code>    +Y (up)
     |
     |
     +--- +X (right)
    /
   /
  +Z (forward, toward camera)
</code></pre>
<ul>
<li><strong>+X</strong> points right</li>
<li><strong>+Y</strong> points up</li>
<li><strong>+Z</strong> points toward the camera (out of the screen)</li>
<li><strong>-Z</strong> points into the screen (forward into the scene)</li>
</ul>
<p>This matches the glTF convention and nalgebra_glm's default handedness.</p>
<h2 id="vector-operations"><a class="header" href="#vector-operations">Vector Operations</a></h2>
<h3 id="construction"><a class="header" href="#construction">Construction</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Vec3::new(1.0, 2.0, 3.0);
let zero = Vec3::zeros();
let one = Vec3::new(1.0, 1.0, 1.0);
let up = Vec3::y();
let right = Vec3::x();
let forward = -Vec3::z();
<span class="boring">}</span></code></pre></pre>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = a + b;
let difference = a - b;
let scaled = a * 2.0;

// Element-wise multiplication requires component_mul
let element_wise = a.component_mul(&amp;b);
<span class="boring">}</span></code></pre></pre>
<p>The <code>*</code> operator on <code>Vec2</code>/<code>Vec3</code> performs scalar multiplication, not element-wise. Use <code>component_mul()</code> when you need per-component multiplication.</p>
<h3 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let length = nalgebra_glm::length(&amp;v);
let normalized = nalgebra_glm::normalize(&amp;v);
let dot = nalgebra_glm::dot(&amp;a, &amp;b);
let cross = nalgebra_glm::cross(&amp;a, &amp;b);
let distance = nalgebra_glm::distance(&amp;a, &amp;b);
let lerped = nalgebra_glm::lerp(&amp;a, &amp;b, 0.5);
<span class="boring">}</span></code></pre></pre>
<h2 id="quaternion-rotations"><a class="header" href="#quaternion-rotations">Quaternion Rotations</a></h2>
<p>Nightshade uses quaternions for all rotations. They avoid gimbal lock and interpolate smoothly.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rotation around an axis
let rotation = nalgebra_glm::quat_angle_axis(
    std::f32::consts::FRAC_PI_4,  // 45 degrees
    &amp;Vec3::y(),                     // around Y axis
);

// Look-at rotation
let forward = nalgebra_glm::normalize(&amp;(target - position));
let rotation = nalgebra_glm::quat_look_at(&amp;forward, &amp;Vec3::y());

// Interpolation
let blended = rotation_a.slerp(&amp;rotation_b, 0.5);

// Apply rotation to a vector
let rotated = nalgebra_glm::quat_rotate_vec3(&amp;rotation, &amp;direction);
<span class="boring">}</span></code></pre></pre>
<h2 id="transform-matrices"><a class="header" href="#transform-matrices">Transform Matrices</a></h2>
<p><code>GlobalTransform</code> stores a 4x4 matrix. <code>LocalTransform</code> stores decomposed translation/rotation/scale:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalTransform {
    pub translation: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}

pub struct GlobalTransform(pub Mat4);
<span class="boring">}</span></code></pre></pre>
<h3 id="building-matrices"><a class="header" href="#building-matrices">Building Matrices</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let translation = nalgebra_glm::translation(&amp;Vec3::new(1.0, 2.0, 3.0));
let rotation = nalgebra_glm::quat_to_mat4(&amp;some_quat);
let scale = nalgebra_glm::scaling(&amp;Vec3::new(2.0, 2.0, 2.0));
let combined = translation * rotation * scale;
<span class="boring">}</span></code></pre></pre>
<h3 id="extracting-from-matrices"><a class="header" href="#extracting-from-matrices">Extracting from Matrices</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let global = world.get_global_transform(entity).unwrap();
let position = global.0.column(3).xyz();
<span class="boring">}</span></code></pre></pre>
<h2 id="angles"><a class="header" href="#angles">Angles</a></h2>
<p>nalgebra_glm works in <strong>radians</strong>. Convert from degrees when needed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let radians = nalgebra_glm::radians(&amp;nalgebra_glm::vec1(45.0)).x;
let degrees = nalgebra_glm::degrees(&amp;nalgebra_glm::vec1(std::f32::consts::FRAC_PI_4)).x;
<span class="boring">}</span></code></pre></pre>
<h2 id="depth-range-and-reversed-z"><a class="header" href="#depth-range-and-reversed-z">Depth Range and Reversed-Z</a></h2>
<p>wgpu uses a <strong>[0, 1]</strong> depth range (not [-1, 1] like OpenGL).</p>
<p>Nightshade uses <strong>reversed-Z</strong> depth, where <code>0.0</code> is the far plane and <code>1.0</code> is the near plane. This is the opposite of the traditional convention where 0 is near and 1 is far.</p>
<h3 id="why-reversed-z"><a class="header" href="#why-reversed-z">Why Reversed-Z?</a></h3>
<p>Floating-point numbers have more precision near zero and less precision near one (because of how the exponent and mantissa are distributed). In a standard depth buffer, the near plane maps to 0 and the far plane maps to 1. But perspective projection is highly nonlinear: most of the [0, 1] range is consumed by geometry close to the near plane, leaving very little precision for distant objects. This causes z-fighting (flickering surfaces) at medium to far distances.</p>
<p>Reversed-Z exploits the floating-point distribution by mapping the far plane to 0 (where float precision is highest) and the near plane to 1. The perspective nonlinearity and the floating-point precision curve partially cancel each other out, resulting in nearly uniform depth precision across the entire view range. This is especially important for large outdoor scenes.</p>
<p>Practically, this means:</p>
<ul>
<li>Depth clear value is <code>0.0</code> (far plane)</li>
<li>Depth comparison function is <code>Greater</code> or <code>GreaterEqual</code> (closer objects have larger depth values)</li>
<li>Projection matrices are constructed with <code>reversed_infinite_perspective_rh_zo</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">Time</a></h1>
<p>All timing information lives in <code>world.resources.window.timing</code>. There is no separate <code>Time</code> resource.</p>
<h2 id="windowtiming"><a class="header" href="#windowtiming">WindowTiming</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowTiming {
    pub frames_per_second: f32,
    pub delta_time: f32,
    pub raw_delta_time: f32,
    pub time_speed: f32,
    pub last_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub current_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub initial_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub frame_counter: u32,
    pub uptime_milliseconds: u64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-time"><a class="header" href="#accessing-time">Accessing Time</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;
    let fps = world.resources.window.timing.frames_per_second;
    let elapsed = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;
    let frame = world.resources.window.timing.frame_counter;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="delta-time"><a class="header" href="#delta-time">Delta Time</a></h2>
<p><code>delta_time</code> is the time in seconds since the last frame, adjusted by <code>time_speed</code>. Use it for all frame-rate-independent movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_entity(world: &amp;mut World, entity: Entity, velocity: Vec3) {
    let dt = world.resources.window.timing.delta_time;
    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.translation += velocity * dt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>raw_delta_time</code> is the unscaled delta time before <code>time_speed</code> is applied. Use <code>raw_delta_time</code> for UI animations or anything that should ignore time scaling.</p>
<h2 id="time-speed"><a class="header" href="#time-speed">Time Speed</a></h2>
<p>Control the speed of time:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.window.timing.time_speed = 0.5;  // Half speed (slow motion)
world.resources.window.timing.time_speed = 2.0;  // Double speed
world.resources.window.timing.time_speed = 0.0;  // Paused
<span class="boring">}</span></code></pre></pre>
<p><code>delta_time = raw_delta_time * time_speed</code>, so setting <code>time_speed</code> to zero pauses all time-dependent movement without stopping the render loop.</p>
<h2 id="periodic-actions"><a class="header" href="#periodic-actions">Periodic Actions</a></h2>
<p>Use an accumulator for timed events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyGame {
    spawn_timer: f32,
}

fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;
    self.spawn_timer += dt;
    if self.spawn_timer &gt;= 2.0 {
        spawn_enemy(world);
        self.spawn_timer = 0.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="uptime"><a class="header" href="#uptime">Uptime</a></h2>
<p><code>uptime_milliseconds</code> counts wall-clock time since the application started. Useful for shader animations and effects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let time = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;
let wave = (time * 2.0).sin();
<span class="boring">}</span></code></pre></pre>
<h2 id="web-compatibility"><a class="header" href="#web-compatibility">Web Compatibility</a></h2>
<p>Timing uses <code>web_time::Instant</code> instead of <code>std::time::Instant</code> for cross-platform compatibility between native and WASM targets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-state-trait"><a class="header" href="#the-state-trait">The State Trait</a></h1>
<p>The <code>State</code> trait is the primary interface between your game and the Nightshade engine. Every game implements this trait to define its behavior.</p>
<h2 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait State {
    fn title(&amp;self) -&gt; &amp;str { "Nightshade" }
    fn icon_bytes(&amp;self) -&gt; Option&lt;&amp;'static [u8]&gt; { /* default: built-in icon */ }
    fn initialize(&amp;mut self, _world: &amp;mut World) {}
    fn next_state(&amp;mut self, _world: &amp;mut World) -&gt; Option&lt;Box&lt;dyn State&gt;&gt; { None }
    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) { /* default: bloom + post-processing + swapchain blit */ }
    fn ui(&amp;mut self, _world: &amp;mut World, _ui_context: &amp;egui::Context) {}
    fn secondary_ui(&amp;mut self, _world: &amp;mut World, _window_index: usize, _ui_context: &amp;egui::Context) {}
    fn immediate_ui(&amp;mut self, _world: &amp;mut World, _ui: &amp;mut ImmediateUi) {}
    fn run_systems(&amp;mut self, _world: &amp;mut World) {}
    fn pre_render(&amp;mut self, _renderer: &amp;mut dyn Render, _world: &amp;mut World) {}
    fn update_render_graph(&amp;mut self, _graph: &amp;mut RenderGraph&lt;World&gt;, _world: &amp;World) {}
    fn handle_event(&amp;mut self, _world: &amp;mut World, _message: &amp;Message) {}
    fn on_keyboard_input(&amp;mut self, _world: &amp;mut World, _key_code: KeyCode, _key_state: ElementState) {}
    fn on_dropped_file(&amp;mut self, _world: &amp;mut World, _path: &amp;std::path::Path) {}
    fn on_dropped_file_data(&amp;mut self, _world: &amp;mut World, _name: &amp;str, _data: &amp;[u8]) {}
    fn on_hovered_file(&amp;mut self, _world: &amp;mut World, _path: &amp;std::path::Path) {}
    fn on_hovered_file_cancelled(&amp;mut self, _world: &amp;mut World) {}
    fn on_gamepad_event(&amp;mut self, _world: &amp;mut World, _event: gilrs::Event) {}
    fn on_mouse_input(&amp;mut self, _world: &amp;mut World, _state: ElementState, _button: MouseButton) {}
    fn handle_mcp_command(&amp;mut self, _world: &amp;mut World, _command: &amp;McpCommand) -&gt; Option&lt;McpResponse&gt; { None }
}
<span class="boring">}</span></code></pre></pre>
<p>All methods have default implementations, so you only need to implement the ones relevant to your game.</p>
<h2 id="commonly-used-methods"><a class="header" href="#commonly-used-methods">Commonly Used Methods</a></h2>
<h3 id="title"><a class="header" href="#title">title()</a></h3>
<p>Returns the window title. Defaults to <code>"Nightshade"</code> if not overridden:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn title(&amp;self) -&gt; &amp;str {
    "My Awesome Game"
}
<span class="boring">}</span></code></pre></pre>
<h3 id="initialize"><a class="header" href="#initialize">initialize()</a></h3>
<p>Called once when the application starts. Use this to set up your initial game state:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.atmosphere = Atmosphere::Sky;

    let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    self.player = Some(spawn_player(world));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="run_systems"><a class="header" href="#run_systems">run_systems()</a></h3>
<p>Called every frame. This is where your game logic lives:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    player_movement_system(world);
    enemy_ai_system(world);
    collision_response_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-methods"><a class="header" href="#optional-methods">Optional Methods</a></h2>
<h3 id="ui"><a class="header" href="#ui">ui()</a></h3>
<p>For egui-based user interfaces. Requires the <code>egui</code> feature. Note that <code>world</code> comes before <code>ui_context</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, world: &amp;mut World, ui_context: &amp;egui::Context) {
    egui::Window::new("Debug").show(ui_context, |ui| {
        ui.label(format!("FPS: {:.0}", world.resources.window.timing.frames_per_second));
        ui.label(format!("Entities: {}", world.query_entities(RENDER_MESH).count()));
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="immediate_ui"><a class="header" href="#immediate_ui">immediate_ui()</a></h3>
<p>For the built-in immediate mode UI (menus, HUD):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    if self.paused {
        ui.panel("Pause Menu", |ui| {
            if ui.button("Resume") {
                self.paused = false;
            }
            if ui.button("Quit") {
                std::process::exit(0);
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_keyboard_input"><a class="header" href="#on_keyboard_input">on_keyboard_input()</a></h3>
<p>Handle keyboard events directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key_code: KeyCode, key_state: ElementState) {
    if key_state == ElementState::Pressed {
        match key_code {
            KeyCode::Escape =&gt; self.paused = !self.paused,
            KeyCode::F11 =&gt; toggle_fullscreen(world),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_mouse_input"><a class="header" href="#on_mouse_input">on_mouse_input()</a></h3>
<p>Handle mouse button events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
    if state == ElementState::Pressed {
        match button {
            MouseButton::Left =&gt; self.shoot(world),
            MouseButton::Right =&gt; self.aim(world),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_gamepad_event"><a class="header" href="#on_gamepad_event">on_gamepad_event()</a></h3>
<p>Handle gamepad button presses:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {
    if let gilrs::EventType::ButtonPressed(button, _) = event.event {
        match button {
            gilrs::Button::Start =&gt; self.paused = !self.paused,
            gilrs::Button::South =&gt; self.player_jump(),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="secondary_ui"><a class="header" href="#secondary_ui">secondary_ui()</a></h3>
<p>For multi-window applications using egui. Called with a <code>window_index</code> parameter that identifies which secondary window is being drawn, allowing you to render different UI per window. Requires the <code>egui</code> feature:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn secondary_ui(&amp;mut self, world: &amp;mut World, window_index: usize, ui_context: &amp;egui::Context) {
    match window_index {
        0 =&gt; {
            egui::Window::new("Inspector").show(ui_context, |ui| {
                ui.label("Secondary window 0");
            });
        }
        1 =&gt; {
            egui::Window::new("Scene View").show(ui_context, |ui| {
                ui.label("Secondary window 1");
            });
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configure_render_graph"><a class="header" href="#configure_render_graph">configure_render_graph()</a></h3>
<p>Customize the rendering pipeline. Called once during initialization. The default implementation sets up bloom, post-processing, and swapchain blit passes. Override this to replace or extend the default pipeline:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    let bloom_pass = passes::BloomPass::new(device, 1920, 1080);
    graph.add_pass(
        Box::new(bloom_pass),
        &amp;[("input", resources.scene_color), ("output", resources.bloom)],
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="update_render_graph"><a class="header" href="#update_render_graph">update_render_graph()</a></h3>
<p>Called each frame to update render graph state dynamically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, world: &amp;World) {
    if self.bloom_changed {
        graph.set_enabled("bloom_pass", self.bloom_enabled);
        self.bloom_changed = false;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pre_render"><a class="header" href="#pre_render">pre_render()</a></h3>
<p>Called before rendering begins each frame. Useful for custom GPU uploads or renderer state changes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pre_render(&amp;mut self, renderer: &amp;mut dyn Render, world: &amp;mut World) {
    renderer.update_custom_buffer(world, &amp;self.custom_data);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="next_state"><a class="header" href="#next_state">next_state()</a></h3>
<p>Allows transitioning to a different State. Return <code>Some(new_state)</code> to switch:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn next_state(&amp;mut self, world: &amp;mut World) -&gt; Option&lt;Box&lt;dyn State&gt;&gt; {
    if self.transition_to_gameplay {
        Some(Box::new(GameplayState::new()))
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_dropped_file--on_dropped_file_data"><a class="header" href="#on_dropped_file--on_dropped_file_data">on_dropped_file() / on_dropped_file_data()</a></h3>
<p>Handle files dropped onto the window:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_dropped_file(&amp;mut self, world: &amp;mut World, path: &amp;Path) {
    if path.extension() == Some("glb".as_ref()) {
        self.load_model(world, path);
    }
}

fn on_dropped_file_data(&amp;mut self, world: &amp;mut World, name: &amp;str, data: &amp;[u8]) {
    self.process_dropped_data(world, name, data);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_hovered_file--on_hovered_file_cancelled"><a class="header" href="#on_hovered_file--on_hovered_file_cancelled">on_hovered_file() / on_hovered_file_cancelled()</a></h3>
<p>Handle file drag hover events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_hovered_file(&amp;mut self, world: &amp;mut World, path: &amp;Path) {
    self.show_drop_indicator = true;
}

fn on_hovered_file_cancelled(&amp;mut self, world: &amp;mut World) {
    self.show_drop_indicator = false;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handle_mcp_command"><a class="header" href="#handle_mcp_command">handle_mcp_command()</a></h3>
<p>Intercept MCP commands before the engine processes them. Requires the <code>mcp</code> feature. Return <code>Some(response)</code> to handle a command yourself, or <code>None</code> to let the engine handle it with default behavior:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(all(feature = "mcp", not(target_arch = "wasm32")))]
fn handle_mcp_command(
    &amp;mut self,
    world: &amp;mut World,
    command: &amp;McpCommand,
) -&gt; Option&lt;McpResponse&gt; {
    match command {
        McpCommand::SpawnEntity { name, .. } =&gt; {
            self.pending_scene_refresh = true;
            None
        }
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="ai-integration.html">AI Integration</a> for full details on the MCP system.</p>
<h3 id="handle_event"><a class="header" href="#handle_event">handle_event()</a></h3>
<p>Handle custom EventBus messages:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_event(&amp;mut self, world: &amp;mut World, message: &amp;Message) {
    match message {
        Message::Custom(data) =&gt; self.process_event(world, data),
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="launching-your-game"><a class="header" href="#launching-your-game">Launching Your Game</a></h2>
<p>Use the <code>nightshade::launch</code> function to run your game:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(MyGame::default())
}</code></pre></pre>
<p>Or with an HDR skybox:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    load_hdr_skybox(world, include_bytes!("../assets/sky.hdr").to_vec());
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-loop"><a class="header" href="#main-loop">Main Loop</a></h1>
<p>Understanding the frame lifecycle helps you structure game logic correctly and debug timing issues.</p>
<h2 id="frame-execution-order"><a class="header" href="#frame-execution-order">Frame Execution Order</a></h2>
<p>Each frame executes in this order:</p>
<pre><code>1.  Process window/input events (winit)
2.  Update input state from events
3.  Calculate delta time
4.  Begin egui frame (if enabled)
5.  Call State::run_systems() - Your game logic
6.  Dispatch EventBus messages
7.  Update animation players
8.  Apply animations to transforms
9.  Propagate transform hierarchy
10. Step physics simulation (fixed timestep)
11. Sync physics transforms to ECS
12. Update audio listener positions
13. Execute render graph passes
14. End egui frame
15. Present to swapchain
</code></pre>
<h2 id="timing"><a class="header" href="#timing">Timing</a></h2>
<p>All timing information is accessed through <code>world.resources.window.timing</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowTiming {
    pub frames_per_second: f32,
    pub delta_time: f32,
    pub raw_delta_time: f32,
    pub time_speed: f32,
    pub last_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub current_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub initial_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub frame_counter: u32,
    pub uptime_milliseconds: u64,
}

fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;
    let elapsed = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;
    let frame = world.resources.window.timing.frame_counter;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fixed-timestep-physics"><a class="header" href="#fixed-timestep-physics">Fixed Timestep Physics</a></h2>
<p>Physics runs at a fixed 60 Hz regardless of frame rate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PHYSICS_TIMESTEP: f32 = 1.0 / 60.0;

fn update_physics(world: &amp;mut World, dt: f32) {
    world.resources.physics_accumulator += dt;

    while world.resources.physics_accumulator &gt;= PHYSICS_TIMESTEP {
        store_physics_state(world);
        world.resources.physics.step(PHYSICS_TIMESTEP);
        world.resources.physics_accumulator -= PHYSICS_TIMESTEP;
    }

    let alpha = world.resources.physics_accumulator / PHYSICS_TIMESTEP;
    interpolate_physics_transforms(world, alpha);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-interpolation"><a class="header" href="#physics-interpolation">Physics Interpolation</a></h3>
<p>For smooth rendering between physics steps:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PhysicsInterpolation {
    pub previous_translation: Vec3,
    pub previous_rotation: Quat,
    pub current_translation: Vec3,
    pub current_rotation: Quat,
}

fn interpolate_physics_transforms(world: &amp;mut World, alpha: f32) {
    for entity in world.query_entities(PHYSICS_INTERPOLATION) {
        let interp = world.get_physics_interpolation(entity).unwrap();
        let translation = interp.previous_translation.lerp(&amp;interp.current_translation, alpha);
        let rotation = interp.previous_rotation.slerp(&amp;interp.current_rotation, alpha);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="system-ordering"><a class="header" href="#system-ordering">System Ordering</a></h2>
<h3 id="before-physics"><a class="header" href="#before-physics">Before Physics</a></h3>
<p>Place movement and input handling before physics:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    handle_input(world);

    player_movement_system(world);

    ai_decision_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="after-physics"><a class="header" href="#after-physics">After Physics</a></h3>
<p>Query physics results after the step:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let contacts = get_all_contacts(world);
    for contact in contacts {
        handle_collision(world, contact);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="delta-time-usage"><a class="header" href="#delta-time-usage">Delta Time Usage</a></h2>
<p>Always multiply movement by delta time for frame-rate independence:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_entity(world: &amp;mut World, entity: Entity, velocity: Vec3) {
    let dt = world.resources.window.timing.delta_time;

    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.translation += velocity * dt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="accumulating-time"><a class="header" href="#accumulating-time">Accumulating Time</a></h3>
<p>For periodic actions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyGame {
    spawn_timer: f32,
}

fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;

    self.spawn_timer += dt;
    if self.spawn_timer &gt;= 2.0 {
        spawn_enemy(world);
        self.spawn_timer = 0.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(MyGame::default())
}</code></pre></pre>
<h3 id="wasm"><a class="header" href="#wasm">WASM</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen(start)]
pub async fn start() {
    nightshade::launch(MyGame::default()).await;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="vr-openxr"><a class="header" href="#vr-openxr">VR (OpenXR)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    nightshade::launch_xr(MyGame::default());
}</code></pre></pre>
<h2 id="debugging-frame-issues"><a class="header" href="#debugging-frame-issues">Debugging Frame Issues</a></h2>
<h3 id="frame-spikes"><a class="header" href="#frame-spikes">Frame Spikes</a></h3>
<p>If you see occasional stuttering:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;
    if dt &gt; 0.1 {
        tracing::warn!("Long frame: {:.3}s", dt);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="consistent-slowdown"><a class="header" href="#consistent-slowdown">Consistent Slowdown</a></h3>
<p>Profile your systems:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let start = std::time::Instant::now();

    expensive_system(world);

    let elapsed = start.elapsed();
    if elapsed.as_millis() &gt; 5 {
        tracing::info!("expensive_system took {:?}", elapsed);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Don't block the main thread</strong>: Use async for file I/O</li>
<li><strong>Batch similar operations</strong>: Process all enemies together, not interleaved</li>
<li><strong>Use spatial partitioning</strong>: For collision checks with many entities</li>
<li><strong>Profile before optimizing</strong>: Measure, don't guess</li>
<li><strong>Consider fixed timestep for gameplay</strong>: Not just physics</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world--resources"><a class="header" href="#world--resources">World &amp; Resources</a></h1>
<p>The <code>World</code> is the central data container in Nightshade. It holds all entities, components, and global resources.</p>
<h2 id="world-structure"><a class="header" href="#world-structure">World Structure</a></h2>
<p>The World is generated by the <code>freecs::ecs!</code> macro and contains:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct World {
    pub entities: EntityStorage,
    pub resources: Resources,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<p>Resources are global singletons accessible throughout the engine:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Resources {
    pub world_id: u64,
    pub is_runtime: bool,
    pub window: Window,
    pub secondary_windows: SecondaryWindows,
    pub user_interface: UserInterface,
    pub immediate_ui: ImmediateUi,
    pub graphics: Graphics,
    pub input: Input,
    #[cfg(feature = "audio")]
    pub audio: AudioEngine,
    #[cfg(feature = "physics")]
    pub physics: PhysicsWorld,
    pub navmesh: NavMeshWorld,
    pub text_cache: TextCache,
    pub mesh_cache: MeshCache,
    pub animation_cache: AnimationCache,
    pub prefab_cache: PrefabCache,
    pub material_registry: MaterialRegistry,
    pub texture_cache: TextureCache,
    pub pending_font_loads: Vec&lt;PendingFontLoad&gt;,
    pub active_camera: Option&lt;Entity&gt;,
    pub event_bus: EventBus,
    pub command_queue: Vec&lt;WorldCommand&gt;,
    pub transform_dirty_entities: Vec&lt;Entity&gt;,
    pub children_cache: HashMap&lt;Entity, Vec&lt;Entity&gt;&gt;,
    pub children_cache_valid: bool,
    pub cleanup_frame_counter: u64,
    pub dropped_files: Vec&lt;DroppedFile&gt;,
    pub skinning_offsets: HashMap&lt;Entity, usize&gt;,
    pub total_skinning_joints: u32,
    #[cfg(feature = "scripting")]
    pub script_runtime: ScriptRuntime,
    #[cfg(feature = "openxr")]
    pub xr: XrResources,
    #[cfg(all(feature = "steam", not(target_arch = "wasm32")))]
    pub steam: SteamResources,
    #[cfg(feature = "physics")]
    pub picking_world: PickingWorld,
    pub gpu_picking: GpuPicking,
    #[cfg(feature = "sdf_sculpt")]
    pub sdf_world: SdfWorld,
    #[cfg(feature = "sdf_sculpt")]
    pub sdf_materials: SdfMaterialRegistry,
    pub mesh_render_state: MeshRenderState,
    #[cfg(feature = "scene_graph")]
    pub asset_registry: AssetRegistry,
    pub entity_names: HashMap&lt;String, Entity&gt;,
    pub pending_particle_textures: Vec&lt;ParticleTextureUpload&gt;,
    pub ibl_views: IblViews,
}
<span class="boring">}</span></code></pre></pre>
<p>There is no separate <code>Time</code> resource. Timing information is accessed through <code>world.resources.window.timing</code>.</p>
<h2 id="accessing-resources-1"><a class="header" href="#accessing-resources-1">Accessing Resources</a></h2>
<p>Resources are accessed through <code>world.resources</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let dt = world.resources.window.timing.delta_time;

    if world.resources.input.keyboard.is_key_pressed(KeyCode::Space) {
        self.jump();
    }

    world.resources.graphics.bloom_enabled = true;
    world.resources.graphics.bloom_intensity = 0.5;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-resources"><a class="header" href="#common-resources">Common Resources</a></h2>
<h3 id="time--timing"><a class="header" href="#time--timing">Time &amp; Timing</a></h3>
<p>Timing is accessed through <code>world.resources.window.timing</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dt = world.resources.window.timing.delta_time;
let fps = world.resources.window.timing.frames_per_second;
let elapsed = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;
<span class="boring">}</span></code></pre></pre>
<p>The <code>WindowTiming</code> struct contains:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindowTiming {
    pub frames_per_second: f32,
    pub delta_time: f32,
    pub raw_delta_time: f32,
    pub time_speed: f32,
    pub last_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub current_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub initial_frame_start_instant: Option&lt;web_time::Instant&gt;,
    pub frame_counter: u32,
    pub uptime_milliseconds: u64,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="input-2"><a class="header" href="#input-2">Input</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.resources.input.keyboard.is_key_pressed(KeyCode::KeyW) {
    move_forward();
}

let mouse_pos = world.resources.input.mouse.position;

if world.resources.input.mouse.state.contains(MouseState::LEFT_JUST_PRESSED) {
    shoot();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="graphics-settings"><a class="header" href="#graphics-settings">Graphics Settings</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_grid = true;
world.resources.graphics.atmosphere = Atmosphere::Sky;
world.resources.graphics.bloom_enabled = true;
world.resources.graphics.ssao_enabled = true;

world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
<span class="boring">}</span></code></pre></pre>
<h3 id="active-camera"><a class="header" href="#active-camera">Active Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.active_camera = Some(camera_entity);

if let Some(camera) = world.resources.active_camera {
    let transform = world.get_global_transform(camera);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="world-commands-2"><a class="header" href="#world-commands-2">World Commands</a></h2>
<p>Operations that require GPU access or must be deferred are queued as <code>WorldCommand</code> values and processed during the render phase:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::LoadTexture {
    name: "my_texture".to_string(),
    rgba_data: texture_bytes,
    width: 256,
    height: 256,
});

world.queue_command(WorldCommand::DespawnRecursive { entity });
world.queue_command(WorldCommand::LoadHdrSkybox { hdr_data });
world.queue_command(WorldCommand::CaptureScreenshot { path: None });
<span class="boring">}</span></code></pre></pre>
<p>For immediate recursive despawning without deferral:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>despawn_recursive_immediate(world, entity);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-hierarchy"><a class="header" href="#scene-hierarchy">Scene Hierarchy</a></h1>
<p>Nightshade supports parent-child relationships between entities, enabling hierarchical transforms where child entities move relative to their parents.</p>
<h2 id="parent-child-relationships-1"><a class="header" href="#parent-child-relationships-1">Parent-Child Relationships</a></h2>
<h3 id="setting-a-parent"><a class="header" href="#setting-a-parent">Setting a Parent</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(child_entity, Parent(Some(parent_entity)));
world.set_local_transform_dirty(child_entity, LocalTransformDirty);
<span class="boring">}</span></code></pre></pre>
<p>When you set a parent, the child's <code>LocalTransform</code> becomes relative to the parent's position, rotation, and scale.</p>
<h3 id="getting-children"><a class="header" href="#getting-children">Getting Children</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(children) = world.resources.children_cache.get(&amp;parent_entity) {
    for child in children {
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-a-parent"><a class="header" href="#removing-a-parent">Removing a Parent</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(child_entity, Parent(None));
<span class="boring">}</span></code></pre></pre>
<h2 id="transform-propagation"><a class="header" href="#transform-propagation">Transform Propagation</a></h2>
<p>Each frame, transforms propagate through the hierarchy:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>propagate_transforms(world);
<span class="boring">}</span></code></pre></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li>Find all entities marked with <code>LocalTransformDirty</code></li>
<li>Mark all their descendants as dirty</li>
<li>Sort entities by depth (parents before children)</li>
<li>For each entity:
<ul>
<li>If has parent: <code>GlobalTransform = parent.GlobalTransform * LocalTransform</code></li>
<li>If no parent: <code>GlobalTransform = LocalTransform.to_matrix()</code></li>
</ul>
</li>
<li>Remove the <code>LocalTransformDirty</code> marker</li>
</ol>
<h3 id="local-vs-global-transform"><a class="header" href="#local-vs-global-transform">Local vs Global Transform</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalTransform {
    pub translation: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}

pub struct GlobalTransform(pub Mat4);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>LocalTransform</strong>: Position, rotation, scale relative to parent (or world if no parent)</li>
<li><strong>GlobalTransform</strong>: Final world-space transformation matrix used for rendering</li>
</ul>
<h2 id="scene-serialization"><a class="header" href="#scene-serialization">Scene Serialization</a></h2>
<p>Scenes can be saved and loaded for level editing and persistence.</p>
<h3 id="scene-structure"><a class="header" href="#scene-structure">Scene Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Scene {
    pub name: String,
    pub entities: Vec&lt;SerializedEntity&gt;,
    pub hierarchy: Vec&lt;HierarchyNode&gt;,
    pub assets: SceneAssets,
}

pub struct SerializedEntity {
    pub id: u64,
    pub name: Option&lt;String&gt;,
    pub components: SerializedComponents,
}

pub struct SceneAssets {
    pub textures: Vec&lt;TextureReference&gt;,
    pub materials: Vec&lt;MaterialReference&gt;,
    pub meshes: Vec&lt;MeshReference&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="saving-a-scene"><a class="header" href="#saving-a-scene">Saving a Scene</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scene = world_to_scene(world);
save_scene(&amp;scene, "level1.scene")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-a-scene"><a class="header" href="#loading-a-scene">Loading a Scene</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scene = load_scene("level1.scene")?;
spawn_scene(world, &amp;scene);
<span class="boring">}</span></code></pre></pre>
<h3 id="binary-serialization"><a class="header" href="#binary-serialization">Binary Serialization</a></h3>
<p>For faster loading and smaller file sizes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = serialize_scene_binary(&amp;scene)?;
let scene = deserialize_scene_binary(&amp;bytes)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="recursive-operations"><a class="header" href="#recursive-operations">Recursive Operations</a></h2>
<h3 id="despawning-with-children"><a class="header" href="#despawning-with-children">Despawning with Children</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>despawn_recursive_immediate(world, parent_entity);
<span class="boring">}</span></code></pre></pre>
<p>This removes the entity and all its descendants from the world.</p>
<h3 id="cloning-hierarchy"><a class="header" href="#cloning-hierarchy">Cloning Hierarchy</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clone = clone_entity_recursive(world, original_entity);
<span class="boring">}</span></code></pre></pre>
<p>Creates a deep copy of an entity and all its children.</p>
<h2 id="example-building-a-robot-arm"><a class="header" href="#example-building-a-robot-arm">Example: Building a Robot Arm</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_robot_arm(world: &amp;mut World) -&gt; Entity {
    let base = spawn_cube_at(world, Vec3::zeros());
    world.set_name(base, Name("Base".to_string()));

    let lower_arm = spawn_cube_at(world, Vec3::new(0.0, 1.5, 0.0));
    world.set_name(lower_arm, Name("Lower Arm".to_string()));
    world.set_parent(lower_arm, Parent(Some(base)));

    let upper_arm = spawn_cube_at(world, Vec3::new(0.0, 2.0, 0.0));
    world.set_name(upper_arm, Name("Upper Arm".to_string()));
    world.set_parent(upper_arm, Parent(Some(lower_arm)));

    let hand = spawn_cube_at(world, Vec3::new(0.0, 1.5, 0.0));
    world.set_name(hand, Name("Hand".to_string()));
    world.set_parent(hand, Parent(Some(upper_arm)));

    base
}

fn rotate_arm(world: &amp;mut World, lower_arm: Entity, angle: f32) {
    if let Some(transform) = world.get_local_transform_mut(lower_arm) {
        transform.rotation = nalgebra_glm::quat_angle_axis(
            angle,
            &amp;Vec3::z(),
        );
    }
    world.set_local_transform_dirty(lower_arm, LocalTransformDirty);
}
<span class="boring">}</span></code></pre></pre>
<p>Rotating the lower arm automatically rotates the upper arm and hand with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-system"><a class="header" href="#input-system">Input System</a></h1>
<p>Input state is aggregated each frame into <code>world.resources.input</code>. Nightshade supports keyboard, mouse, and gamepad input through both polling and event-driven patterns.</p>
<h2 id="polling-input"><a class="header" href="#polling-input">Polling Input</a></h2>
<p>Check input state at any point during <code>run_systems</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // Keyboard
    if world.resources.input.keyboard.is_key_pressed(KeyCode::KeyW) {
        move_forward(world);
    }

    // Mouse position
    let mouse_pos = world.resources.input.mouse.position;

    // Mouse buttons
    if world.resources.input.mouse.state.contains(MouseState::LEFT_JUST_PRESSED) {
        shoot(world);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-driven-input"><a class="header" href="#event-driven-input">Event-Driven Input</a></h2>
<p>Handle input events through the <code>State</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key_code: KeyCode, key_state: ElementState) {
    if key_state == ElementState::Pressed {
        match key_code {
            KeyCode::Escape =&gt; self.paused = !self.paused,
            KeyCode::F11 =&gt; toggle_fullscreen(world),
            _ =&gt; {}
        }
    }
}

fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
    if state == ElementState::Pressed &amp;&amp; button == MouseButton::Left {
        self.shoot(world);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-systems"><a class="header" href="#built-in-systems">Built-in Systems</a></h2>
<p>Nightshade provides ready-to-use input systems:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // WASD + mouse fly camera
    fly_camera_system(world);

    // Escape key exits the application
    escape_key_exit_system(world);

    // Pan-orbit camera (middle mouse drag to orbit, scroll to zoom)
    pan_orbit_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapters"><a class="header" href="#chapters">Chapters</a></h2>
<ul>
<li><a href="keyboard-mouse.html">Keyboard &amp; Mouse</a> - Key detection, mouse tracking, cursor control</li>
<li><a href="gamepad.html">Gamepad Support</a> - Controller input, analog sticks, rumble</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard--mouse"><a class="header" href="#keyboard--mouse">Keyboard &amp; Mouse</a></h1>
<p>Handle keyboard and mouse input through the input resources.</p>
<h2 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h2>
<h3 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let keyboard = &amp;world.resources.input.keyboard;

    // Key currently held down
    if keyboard.is_key_pressed(KeyCode::KeyW) {
        move_forward();
    }

    if keyboard.is_key_pressed(KeyCode::Space) {
        jump();
    }

    if keyboard.is_key_pressed(KeyCode::ShiftLeft) {
        sprint();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-key-codes"><a class="header" href="#common-key-codes">Common Key Codes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody>
<tr><td>Letters</td><td><code>KeyCode::KeyA</code> through <code>KeyCode::KeyZ</code></td></tr>
<tr><td>Numbers</td><td><code>KeyCode::Digit0</code> through <code>KeyCode::Digit9</code></td></tr>
<tr><td>Arrow keys</td><td><code>KeyCode::ArrowUp</code>, <code>ArrowDown</code>, <code>ArrowLeft</code>, <code>ArrowRight</code></td></tr>
<tr><td>Space</td><td><code>KeyCode::Space</code></td></tr>
<tr><td>Shift</td><td><code>KeyCode::ShiftLeft</code>, <code>KeyCode::ShiftRight</code></td></tr>
<tr><td>Control</td><td><code>KeyCode::ControlLeft</code>, <code>KeyCode::ControlRight</code></td></tr>
<tr><td>Alt</td><td><code>KeyCode::AltLeft</code>, <code>KeyCode::AltRight</code></td></tr>
<tr><td>Escape</td><td><code>KeyCode::Escape</code></td></tr>
<tr><td>Enter</td><td><code>KeyCode::Enter</code></td></tr>
<tr><td>Tab</td><td><code>KeyCode::Tab</code></td></tr>
<tr><td>F keys</td><td><code>KeyCode::F1</code> through <code>KeyCode::F12</code></td></tr>
</tbody></table>
</div>
<h3 id="direct-event-handling"><a class="header" href="#direct-event-handling">Direct Event Handling</a></h3>
<p>Handle key events in the State trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: ElementState) {
    if state == ElementState::Pressed {
        match key {
            KeyCode::Escape =&gt; self.paused = !self.paused,
            KeyCode::F11 =&gt; toggle_fullscreen(world),
            KeyCode::Digit1 =&gt; self.select_weapon(0),
            KeyCode::Digit2 =&gt; self.select_weapon(1),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mouse-input"><a class="header" href="#mouse-input">Mouse Input</a></h2>
<h3 id="mouse-position"><a class="header" href="#mouse-position">Mouse Position</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mouse = &amp;world.resources.input.mouse;
let position = mouse.position;  // Screen coordinates (x, y)
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-movement-delta"><a class="header" href="#mouse-movement-delta">Mouse Movement (Delta)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let delta = world.resources.input.mouse.position_delta;
camera_yaw += delta.x * sensitivity;
camera_pitch += delta.y * sensitivity;
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mouse = &amp;world.resources.input.mouse;

// Button held
if mouse.state.contains(MouseState::LEFT_CLICKED) {
    fire_weapon();
}

// Button just pressed
if mouse.state.contains(MouseState::LEFT_JUST_PRESSED) {
    start_drag();
}

// Button just released
if mouse.state.contains(MouseState::LEFT_JUST_RELEASED) {
    end_drag();
}

// Right mouse button
if mouse.state.contains(MouseState::RIGHT_CLICKED) {
    aim_down_sights();
}

// Middle mouse button
if mouse.state.contains(MouseState::MIDDLE_CLICKED) {
    pan_camera();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-scroll"><a class="header" href="#mouse-scroll">Mouse Scroll</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scroll = world.resources.input.mouse.wheel_delta;
if scroll.y != 0.0 {
    zoom_camera(scroll.y);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-event-handling-1"><a class="header" href="#direct-event-handling-1">Direct Event Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
    match (button, state) {
        (MouseButton::Left, ElementState::Pressed) =&gt; self.shoot(),
        (MouseButton::Right, ElementState::Pressed) =&gt; self.aim(),
        (MouseButton::Right, ElementState::Released) =&gt; self.stop_aim(),
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="movement-input-pattern"><a class="header" href="#movement-input-pattern">Movement Input Pattern</a></h2>
<p>Common WASD movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_movement_input(world: &amp;World) -&gt; Vec3 {
    let keyboard = &amp;world.resources.input.keyboard;
    let mut direction = Vec3::zeros();

    if keyboard.is_key_pressed(KeyCode::KeyW) {
        direction.z -= 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyS) {
        direction.z += 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyA) {
        direction.x -= 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyD) {
        direction.x += 1.0;
    }

    if direction.magnitude() &gt; 0.0 {
        direction.normalize_mut();
    }

    direction
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mouse-look-pattern"><a class="header" href="#mouse-look-pattern">Mouse Look Pattern</a></h2>
<p>First-person camera control:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mouse_look_system(world: &amp;mut World, sensitivity: f32) {
    let delta = world.resources.input.mouse.position_delta;

    if let Some(camera) = world.resources.active_camera {
        if let Some(transform) = world.get_local_transform_mut(camera) {
            // Horizontal rotation (yaw)
            let yaw = nalgebra_glm::quat_angle_axis(
                -delta.x * sensitivity,
                &amp;Vec3::y(),
            );

            // Vertical rotation (pitch) - clamped
            let pitch = nalgebra_glm::quat_angle_axis(
                -delta.y * sensitivity,
                &amp;Vec3::x(),
            );

            transform.rotation = yaw * transform.rotation * pitch;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cursor-visibility"><a class="header" href="#cursor-visibility">Cursor Visibility</a></h2>
<p>For first-person games:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.show_cursor = false;
}

fn toggle_cursor(world: &amp;mut World) {
    world.resources.graphics.show_cursor = !world.resources.graphics.show_cursor;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-bindings"><a class="header" href="#key-bindings">Key Bindings</a></h2>
<p>Create rebindable controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyBindings {
    move_forward: KeyCode,
    move_back: KeyCode,
    move_left: KeyCode,
    move_right: KeyCode,
    jump: KeyCode,
    sprint: KeyCode,
}

impl Default for KeyBindings {
    fn default() -&gt; Self {
        Self {
            move_forward: KeyCode::KeyW,
            move_back: KeyCode::KeyS,
            move_left: KeyCode::KeyA,
            move_right: KeyCode::KeyD,
            jump: KeyCode::Space,
            sprint: KeyCode::ShiftLeft,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-buffer"><a class="header" href="#input-buffer">Input Buffer</a></h2>
<p>Buffer inputs for responsive controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InputBuffer {
    jump_buffer: f32,
}

fn update_input_buffer(buffer: &amp;mut InputBuffer, world: &amp;World, dt: f32) {
    buffer.jump_buffer = (buffer.jump_buffer - dt).max(0.0);

    if world.resources.input.keyboard.is_key_pressed(KeyCode::Space) {
        buffer.jump_buffer = 0.15;
    }
}

fn try_jump(buffer: &amp;mut InputBuffer, grounded: bool) -&gt; bool {
    if grounded &amp;&amp; buffer.jump_buffer &gt; 0.0 {
        buffer.jump_buffer = 0.0;
        return true;
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gamepad-support"><a class="header" href="#gamepad-support">Gamepad Support</a></h1>
<p>Nightshade provides cross-platform gamepad support.</p>
<h2 id="enabling-gamepad"><a class="header" href="#enabling-gamepad">Enabling Gamepad</a></h2>
<p>Gamepad requires the <code>gamepad</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "gamepad"] }
</code></pre>
<h2 id="checking-for-gamepad"><a class="header" href="#checking-for-gamepad">Checking for Gamepad</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(gamepad) = &amp;world.resources.input.gamepad {
        handle_gamepad_input(gamepad);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="button-input"><a class="header" href="#button-input">Button Input</a></h2>
<h3 id="button-states"><a class="header" href="#button-states">Button States</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_gamepad_input(gamepad: &amp;Gamepad) {
    if gamepad.pressed(GamepadButton::South) {
        jump();
    }

    if gamepad.pressed(GamepadButton::West) {
        attack();
    }

    if gamepad.just_pressed(GamepadButton::North) {
        interact();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="button-mapping"><a class="header" href="#button-mapping">Button Mapping</a></h3>
<div class="table-wrapper"><table><thead><tr><th>GamepadButton</th><th>Xbox</th><th>PlayStation</th><th>Nintendo</th></tr></thead><tbody>
<tr><td><code>South</code></td><td>A</td><td>Cross</td><td>B</td></tr>
<tr><td><code>East</code></td><td>B</td><td>Circle</td><td>A</td></tr>
<tr><td><code>West</code></td><td>X</td><td>Square</td><td>Y</td></tr>
<tr><td><code>North</code></td><td>Y</td><td>Triangle</td><td>X</td></tr>
<tr><td><code>LeftBumper</code></td><td>LB</td><td>L1</td><td>L</td></tr>
<tr><td><code>RightBumper</code></td><td>RB</td><td>R1</td><td>R</td></tr>
<tr><td><code>Select</code></td><td>View</td><td>Share</td><td>-</td></tr>
<tr><td><code>Start</code></td><td>Menu</td><td>Options</td><td>+</td></tr>
<tr><td><code>DPadUp/Down/Left/Right</code></td><td>D-Pad</td><td>D-Pad</td><td>D-Pad</td></tr>
</tbody></table>
</div>
<h2 id="analog-sticks"><a class="header" href="#analog-sticks">Analog Sticks</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_analog_input(gamepad: &amp;Gamepad) {
    let movement = gamepad.left_stick;
    let look = gamepad.right_stick;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="triggers"><a class="header" href="#triggers">Triggers</a></h2>
<p>Triggers return values from 0.0 (not pressed) to 1.0 (fully pressed):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_triggers(gamepad: &amp;Gamepad) {
    let left = gamepad.left_trigger;
    let right = gamepad.right_trigger;

    let acceleration = right * max_acceleration;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-based-input"><a class="header" href="#event-based-input">Event-Based Input</a></h2>
<p>Handle button events in the State trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(gamepad) = &amp;world.resources.input.gamepad {
        if gamepad.just_pressed(GamepadButton::Start) {
            self.paused = !self.paused;
        }
        if gamepad.just_pressed(GamepadButton::Select) {
            toggle_camera_mode(&amp;mut self.game);
        }
        if gamepad.just_pressed(GamepadButton::South) {
            if self.phase == GamePhase::MainMenu {
                self.phase = GamePhase::Playing;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="vibrationrumble"><a class="header" href="#vibrationrumble">Vibration/Rumble</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trigger_rumble(world: &amp;mut World, strength: f32, duration_ms: u32) {
    if let Some(gamepad) = world.resources.input.gamepad.as_mut() {
        gamepad.set_rumble(strength, strength, duration_ms);
    }
}

fn hit_feedback(world: &amp;mut World) {
    trigger_rumble(world, 0.5, 100);
}

fn explosion_feedback(world: &amp;mut World) {
    trigger_rumble(world, 1.0, 300);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-keyboard-and-gamepad"><a class="header" href="#combining-keyboard-and-gamepad">Combining Keyboard and Gamepad</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PlayerInput {
    movement: Vec2,
    look: Vec2,
    jump: bool,
    attack: bool,
}

fn gather_input(world: &amp;World) -&gt; PlayerInput {
    let mut input = PlayerInput::default();

    let keyboard = &amp;world.resources.input.keyboard;
    if keyboard.is_key_pressed(KeyCode::KeyW) { input.movement.y -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { input.movement.y += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { input.movement.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { input.movement.x += 1.0; }
    input.jump |= keyboard.is_key_pressed(KeyCode::Space);

    if let Some(gamepad) = &amp;world.resources.input.gamepad {
        let stick = gamepad.left_stick;

        if stick.magnitude() &gt; 0.0 {
            input.movement = stick;
        }

        input.jump |= gamepad.pressed(GamepadButton::South);
        input.attack |= gamepad.pressed(GamepadButton::West);
    }

    input
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-system"><a class="header" href="#event-system">Event System</a></h1>
<p>Nightshade provides an event bus for decoupled communication between systems. Events are published to a queue and consumed by interested systems.</p>
<h2 id="eventbus"><a class="header" href="#eventbus">EventBus</a></h2>
<p>The event bus is accessible through <code>world.resources.event_bus</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EventBus {
    pub messages: VecDeque&lt;Message&gt;,
}

pub enum Message {
    Input(InputMessage),
    App(Box&lt;dyn Any + Send + Sync&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="defining-custom-events"><a class="header" href="#defining-custom-events">Defining Custom Events</a></h2>
<p>Create a struct for your event:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EnemyDied {
    pub entity: Entity,
    pub position: Vec3,
    pub killer: Option&lt;Entity&gt;,
}

pub struct PlayerLeveledUp {
    pub new_level: u32,
    pub skills_unlocked: Vec&lt;String&gt;,
}

pub struct ItemPickedUp {
    pub item_type: ItemType,
    pub quantity: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="publishing-events-1"><a class="header" href="#publishing-events-1">Publishing Events</a></h2>
<p>Use <code>publish_app_event</code> to send events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn combat_system(world: &amp;mut World, game: &amp;mut GameState) {
    for enemy in world.query_entities(ENEMY | HEALTH) {
        let health = world.get_health(enemy).unwrap();
        if health.current &lt;= 0 {
            let position = world.get_global_transform(enemy)
                .map(|t| t.matrix.column(3).xyz())
                .unwrap_or(Vec3::zeros());

            publish_app_event(world, EnemyDied {
                entity: enemy,
                position,
                killer: game.last_attacker,
            });

            world.despawn_entities(&amp;[enemy]);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="consuming-events-1"><a class="header" href="#consuming-events-1">Consuming Events</a></h2>
<p>Process events in your game loop:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    while let Some(msg) = world.resources.event_bus.messages.pop_front() {
        match msg {
            Message::App(event) =&gt; {
                if let Some(died) = event.downcast_ref::&lt;EnemyDied&gt;() {
                    self.handle_enemy_death(world, died);
                }
                if let Some(levelup) = event.downcast_ref::&lt;PlayerLeveledUp&gt;() {
                    self.show_levelup_ui(levelup);
                }
                if let Some(pickup) = event.downcast_ref::&lt;ItemPickedUp&gt;() {
                    self.update_inventory(pickup);
                }
            }
            Message::Input(input_msg) =&gt; {
                self.handle_input_message(input_msg);
            }
        }
    }
}

fn handle_enemy_death(&amp;mut self, world: &amp;mut World, event: &amp;EnemyDied) {
    spawn_explosion_effect(world, event.position);
    play_sound(world, "enemy_death", PlaybackSettings::default());
    self.score += 100;
    self.enemies_killed += 1;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-patterns-1"><a class="header" href="#event-patterns-1">Event Patterns</a></h2>
<h3 id="one-to-many-communication"><a class="header" href="#one-to-many-communication">One-to-Many Communication</a></h3>
<p>Events allow one system to notify multiple listeners without direct coupling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>publish_app_event(world, DoorOpened { door_id: 42 });
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(door) = event.downcast_ref::&lt;DoorOpened&gt;() {
    trigger_cutscene(world, door.door_id);
}

if let Some(door) = event.downcast_ref::&lt;DoorOpened&gt;() {
    play_door_sound(world, door.door_id);
}

if let Some(door) = event.downcast_ref::&lt;DoorOpened&gt;() {
    update_minimap(world, door.door_id);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="deferred-actions"><a class="header" href="#deferred-actions">Deferred Actions</a></h3>
<p>Events let you schedule actions without immediate execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpawnEnemy {
    pub enemy_type: EnemyType,
    pub position: Vec3,
    pub delay_frames: u32,
}

fn wave_spawner_system(world: &amp;mut World, pending: &amp;mut Vec&lt;SpawnEnemy&gt;) {
    pending.retain_mut(|spawn| {
        if spawn.delay_frames == 0 {
            spawn_enemy(world, spawn.enemy_type, spawn.position);
            false
        } else {
            spawn.delay_frames -= 1;
            true
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="request-response-pattern"><a class="header" href="#request-response-pattern">Request-Response Pattern</a></h3>
<p>For queries that need responses, use a shared resource:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DamageRequest {
    pub target: Entity,
    pub amount: f32,
    pub damage_type: DamageType,
}

pub struct DamageResult {
    pub target: Entity,
    pub actual_damage: f32,
    pub killed: bool,
}

fn damage_system(world: &amp;mut World, requests: &amp;[DamageRequest]) -&gt; Vec&lt;DamageResult&gt; {
    requests.iter().map(|req| {
        let actual = apply_damage(world, req.target, req.amount, req.damage_type);
        let killed = is_dead(world, req.target);
        DamageResult {
            target: req.target,
            actual_damage: actual,
            killed,
        }
    }).collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-messages"><a class="header" href="#input-messages">Input Messages</a></h2>
<p>The event bus also handles input-related messages:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum InputMessage {
    KeyPressed(KeyCode),
    KeyReleased(KeyCode),
    MouseMoved { x: f32, y: f32 },
    MouseButton { button: MouseButton, pressed: bool },
    GamepadButton { button: GamepadButton, pressed: bool },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Keep events small</strong>: Only include necessary data</li>
<li><strong>Use descriptive names</strong>: <code>PlayerDied</code> not <code>Event1</code></li>
<li><strong>Process events each frame</strong>: Don't let the queue grow unbounded</li>
<li><strong>Consider event ordering</strong>: Events are processed in FIFO order</li>
<li><strong>Avoid circular events</strong>: A handling B which triggers A can cause infinite loops</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-architecture"><a class="header" href="#rendering-architecture">Rendering Architecture</a></h1>
<p>This chapter explains how ECS data flows to pixels on screen. Nightshade's renderer is built on wgpu and uses a dependency-driven render graph to orchestrate all GPU work.</p>
<h2 id="high-level-flow"><a class="header" href="#high-level-flow">High-Level Flow</a></h2>
<pre><code>ECS World State
    |
    v
Renderer (WgpuRenderer)
    |-- Sync data: upload transforms, materials, lights to GPU buffers
    |-- Prepare passes: each pass updates its bind groups and uniforms
    |-- Execute render graph: run passes in dependency order
    |-- Submit command buffers to GPU queue
    |-- Present swapchain surface
    |
    v
Pixels on Screen
</code></pre>
<h2 id="the-render-trait"><a class="header" href="#the-render-trait">The Render Trait</a></h2>
<p>All rendering goes through the <code>Render</code> trait, which abstracts the GPU backend:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Render {
    fn render_frame(&amp;mut self, world: &amp;mut World, state: &amp;mut dyn State);
    fn resize(&amp;mut self, width: u32, height: u32, world: &amp;mut World);
    // ... additional methods for texture upload, screenshot, etc.
}
<span class="boring">}</span></code></pre></pre>
<p><code>WgpuRenderer</code> is the concrete implementation that owns the wgpu device, queue, surface, and render graph.</p>
<h2 id="wgpurenderer"><a class="header" href="#wgpurenderer">WgpuRenderer</a></h2>
<p>The renderer holds all GPU state:</p>
<ul>
<li><strong>Instance, Adapter, Device, Queue</strong> - wgpu initialization chain</li>
<li><strong>Surface</strong> - the window's swapchain</li>
<li><strong>RenderGraph</strong> - the dependency-driven frame graph with all passes</li>
<li><strong>Resource IDs</strong> - handles to all transient and external textures</li>
<li><strong>Texture Cache</strong> - uploaded GPU textures</li>
<li><strong>Font Atlas</strong> - glyph texture for text rendering</li>
<li><strong>Camera Viewports</strong> - render-to-texture for editor viewports</li>
</ul>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>When the application starts:</p>
<ol>
<li><strong>Instance creation</strong> - wgpu creates a <code>wgpu::Instance</code>, which selects the GPU backend (Vulkan on Linux/Windows, Metal on macOS, DX12 on Windows, WebGPU on WASM). The instance is the entry point to the GPU API.</li>
<li><strong>Adapter request</strong> - The instance queries available GPUs and selects one. The adapter describes the GPU's capabilities (supported texture formats, limits, features).</li>
<li><strong>Device and queue</strong> - The adapter opens a logical device (the interface for creating GPU resources) and a command queue (where command buffers are submitted for execution). All GPU work goes through the queue.</li>
<li><strong>Surface configuration</strong> - The window surface is configured with the GPU's preferred format (typically Bgra8UnormSrgb) and the presentation mode (Fifo for vsync, Mailbox for low-latency).</li>
<li><strong>Pass creation</strong> - All built-in passes are created. Each pass constructs its shader modules, pipeline layouts, render pipelines, bind group layouts, and any persistent GPU buffers during initialization.</li>
<li><strong>Render graph construction</strong> - A <code>RenderGraph&lt;World&gt;</code> is constructed with all transient textures and passes registered.</li>
<li><strong>User configuration</strong> - <code>State::configure_render_graph()</code> is called, allowing the game to add custom passes, textures, or modify the pipeline.</li>
<li><strong>Graph compilation</strong> - The graph builds dependency edges, topologically sorts passes, computes resource lifetimes, determines aliasing, and calculates load/store operations.</li>
</ol>
<h2 id="transient-textures"><a class="header" href="#transient-textures">Transient Textures</a></h2>
<p>The renderer declares all intermediate textures at initialization:</p>
<div class="table-wrapper"><table><thead><tr><th>Texture</th><th>Format</th><th>Description</th></tr></thead><tbody>
<tr><td><code>depth</code></td><td>Depth32Float</td><td>Main depth buffer (reversed-Z, 0.0 = far)</td></tr>
<tr><td><code>scene_color</code></td><td>Rgba16Float</td><td>HDR color accumulation buffer</td></tr>
<tr><td><code>compute_output</code></td><td>Surface format</td><td>Post-processed output before swapchain blit</td></tr>
<tr><td><code>shadow_depth</code></td><td>Depth32Float</td><td>Cascaded shadow map (8192x8192 native, 4096 WASM)</td></tr>
<tr><td><code>spotlight_shadow_atlas</code></td><td>Depth32Float</td><td>Spotlight shadow atlas (4096 native, 1024 WASM)</td></tr>
<tr><td><code>entity_id</code></td><td>R32Float</td><td>Entity ID buffer for GPU picking</td></tr>
<tr><td><code>view_normals</code></td><td>Rgba16Float</td><td>View-space normals for SSAO/SSGI</td></tr>
<tr><td><code>selection_mask</code></td><td>R8Unorm</td><td>Selection mask for editor outlines</td></tr>
<tr><td><code>ssao_raw</code></td><td>R8Unorm</td><td>Raw SSAO before blur</td></tr>
<tr><td><code>ssao</code></td><td>R8Unorm</td><td>Blurred SSAO</td></tr>
<tr><td><code>ssgi_raw</code></td><td>Rgba16Float</td><td>Raw SSGI (half resolution)</td></tr>
<tr><td><code>ssgi</code></td><td>Rgba16Float</td><td>Blurred SSGI (half resolution)</td></tr>
<tr><td><code>ssr_raw</code></td><td>Rgba16Float</td><td>Raw screen-space reflections</td></tr>
<tr><td><code>ssr</code></td><td>Rgba16Float</td><td>Blurred SSR</td></tr>
<tr><td><code>ui_depth</code></td><td>Depth32Float</td><td>Separate depth for UI rendering</td></tr>
</tbody></table>
</div>
<p>External textures (provided each frame):</p>
<ul>
<li><code>swapchain</code> - the window surface texture</li>
<li><code>viewport_output</code> - editor viewport render target</li>
</ul>
<h2 id="per-frame-rendering"><a class="header" href="#per-frame-rendering">Per-Frame Rendering</a></h2>
<p>Each frame, <code>render_frame()</code> executes:</p>
<ol>
<li><strong>Sync data</strong> - Upload transform matrices, material uniforms, light data, and animation bone matrices to GPU buffers</li>
<li><strong>Process commands</strong> - Handle queued <code>WorldCommand</code> values (texture loads, screenshots, etc.)</li>
<li><strong>Set swapchain texture</strong> - Acquire the next swapchain image and bind it as the external <code>swapchain</code> resource</li>
<li><strong>Call <code>State::update_render_graph()</code></strong> - Allow per-frame graph modifications</li>
<li><strong>Execute render graph</strong> - Run all enabled, non-culled passes in topological order, collecting command buffers</li>
<li><strong>Submit</strong> - Send command buffers to the GPU queue</li>
<li><strong>Present</strong> - Display the frame</li>
</ol>
<h2 id="resize-handling"><a class="header" href="#resize-handling">Resize Handling</a></h2>
<p>When the window resizes:</p>
<ol>
<li>The surface is reconfigured with new dimensions</li>
<li>All transient textures are resized to match</li>
<li>The render graph recomputes resource aliasing</li>
<li>Passes that cache bind groups invalidate them</li>
</ol>
<p>SSGI textures resize to half the new dimensions.</p>
<h2 id="custom-rendering"><a class="header" href="#custom-rendering">Custom Rendering</a></h2>
<p>Games customize rendering through two <code>State</code> methods:</p>
<ul>
<li><strong><code>configure_render_graph()</code></strong> - Called once at startup. Add custom passes, textures, and change the pipeline structure.</li>
<li><strong><code>update_render_graph()</code></strong> - Called each frame. Enable/disable passes, update pass parameters.</li>
</ul>
<p>See <a href="render-graph.html">The Render Graph</a> for details on how the graph system works, and <a href="render-graph-custom.html">Custom Passes</a> for implementation examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-render-graph"><a class="header" href="#the-render-graph">The Render Graph</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/custom_pass">Custom Pass</a> | <a href="https://matthewberger.dev/nightshade/custom_multipass">Custom Multipass</a> | <a href="https://matthewberger.dev/nightshade/render_layers">Render Layers</a></p>
</blockquote>
<p>The render graph is a dependency-driven frame graph that automatically schedules GPU work. Instead of manually ordering render passes, you declare what each pass reads and writes, and the graph figures out the rest.</p>
<h2 id="the-problem-manual-pass-ordering"><a class="header" href="#the-problem-manual-pass-ordering">The Problem: Manual Pass Ordering</a></h2>
<p>A modern renderer has dozens of passes: shadow maps, geometry, SSAO, SSR, bloom, tonemapping, UI. Each reads from and writes to intermediate textures. Without automation, you must:</p>
<ol>
<li><strong>Manually order passes</strong> - Shadow maps before geometry, geometry before SSAO, SSAO before compositing. Add one pass and you must figure out where it fits in the chain. Reorder one pass and you break three others.</li>
<li><strong>Manually manage textures</strong> - Allocate intermediate textures, track which ones are alive when, decide when to clear vs load, when to store vs discard. Get it wrong and you see black screens or stale data from previous frames.</li>
<li><strong>Manually optimize memory</strong> - SSAO's intermediate texture and SSR's intermediate texture might never be alive at the same time. Without aliasing, you waste VRAM on textures that could share the same memory.</li>
<li><strong>Manually handle dynamic passes</strong> - Disabling bloom shouldn't require rewriting the compositing pass's inputs. But with hardcoded ordering, every conditional pass is an <code>if</code> statement that must be threaded through the entire pipeline.</li>
</ol>
<p>A render graph (also called a frame graph, as described in the Frostbite GDC 2017 talk "FrameGraph: Extensible Rendering Architecture in Frostbite") solves all of this. You describe what each pass needs, and the graph handles ordering, memory, and lifecycle.</p>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<p>The render graph models the frame as a <strong>directed acyclic graph (DAG)</strong> where:</p>
<ul>
<li><strong>Nodes</strong> are render passes</li>
<li><strong>Edges</strong> are resource dependencies (an edge from A to B means "A produces data that B consumes")</li>
</ul>
<p>This is the same abstraction as a build system (Make, Bazel) or a task scheduler. Given the dependency edges, a topological sort produces a valid execution order. The graph can then analyze resource lifetimes across that order to alias memory, compute load/store operations, and cull unused passes.</p>
<p>The key insight is that passes declare their dependencies <strong>declaratively</strong> through named slots, not <strong>imperatively</strong> through explicit ordering. This makes the system composable: adding a new pass means declaring what it reads and writes, not editing every other pass that touches the same resources.</p>
<h2 id="why-a-render-graph"><a class="header" href="#why-a-render-graph">Why a Render Graph?</a></h2>
<ul>
<li><strong>Automatic ordering</strong> - Passes are topologically sorted based on read/write dependencies</li>
<li><strong>Automatic memory management</strong> - Transient textures with non-overlapping lifetimes share GPU memory</li>
<li><strong>Automatic load/store ops</strong> - The graph determines whether to Clear, Load, Store, or Discard each attachment</li>
<li><strong>Dead pass culling</strong> - Passes that don't contribute to any external output are automatically skipped</li>
<li><strong>Runtime toggling</strong> - Passes can be enabled/disabled at runtime without recompiling the graph</li>
</ul>
<h2 id="the-rendergraph-struct"><a class="header" href="#the-rendergraph-struct">The RenderGraph Struct</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderGraph&lt;C = ()&gt; {
    graph: DiGraph&lt;GraphNode&lt;C&gt;, ResourceId&gt;,  // petgraph directed graph
    pass_nodes: HashMap&lt;String, NodeIndex&gt;,     // pass name -&gt; graph node
    resources: RenderGraphResources,            // texture/buffer descriptors and handles
    execution_order: Vec&lt;NodeIndex&gt;,            // topologically sorted pass order
    store_ops: HashMap&lt;ResourceId, StoreOp&gt;,    // per-resource store operations
    clear_ops: HashSet&lt;(NodeIndex, ResourceId)&gt;,// which passes clear which resources
    aliasing_info: Option&lt;ResourceAliasingInfo&gt;,// memory sharing between transients
    culled_passes: HashSet&lt;NodeIndex&gt;,          // passes removed by dead-pass culling
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The generic parameter <code>C</code> is the "configs" type passed to passes during execution. Nightshade uses <code>RenderGraph&lt;World&gt;</code> so passes can read ECS state.</p>
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<h3 id="1-setup-phase-once-at-startup"><a class="header" href="#1-setup-phase-once-at-startup">1. Setup Phase (once at startup)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut graph = RenderGraph::new();

// Declare textures
let depth = graph.add_depth_texture("depth")
    .size(1920, 1080)
    .clear_depth(0.0)
    .transient();

let scene_color = graph.add_color_texture("scene_color")
    .format(wgpu::TextureFormat::Rgba16Float)
    .size(1920, 1080)
    .clear_color(wgpu::Color::BLACK)
    .transient();

let swapchain = graph.add_color_texture("swapchain")
    .format(surface_format)
    .external();

// Add passes with slot bindings
graph.add_pass(
    Box::new(clear_pass),
    &amp;[("color", scene_color), ("depth", depth)],
)?;

graph.add_pass(
    Box::new(mesh_pass),
    &amp;[("color", scene_color), ("depth", depth)],
)?;

graph.add_pass(
    Box::new(blit_pass),
    &amp;[("input", scene_color), ("output", swapchain)],
)?;

// Compile: build edges, sort, compute aliasing
graph.compile()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-per-frame-execution"><a class="header" href="#2-per-frame-execution">2. Per-Frame Execution</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Provide the swapchain texture for this frame
graph.set_external_texture(swapchain_id, swapchain_view, width, height);

// Execute all passes, get command buffers
let command_buffers = graph.execute(&amp;device, &amp;queue, &amp;world)?;

// Submit to GPU
queue.submit(command_buffers);
<span class="boring">}</span></code></pre></pre>
<h2 id="key-methods"><a class="header" href="#key-methods">Key Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>Create an empty graph</td></tr>
<tr><td><code>add_color_texture()</code></td><td>Declare a color render target (returns builder)</td></tr>
<tr><td><code>add_depth_texture()</code></td><td>Declare a depth buffer (returns builder)</td></tr>
<tr><td><code>add_buffer()</code></td><td>Declare a GPU buffer (returns builder)</td></tr>
<tr><td><code>add_pass()</code></td><td>Add a pass with slot-to-resource bindings</td></tr>
<tr><td><code>pass()</code></td><td>Fluent pass builder (alternative to <code>add_pass</code>)</td></tr>
<tr><td><code>compile()</code></td><td>Build dependency graph, topological sort, compute aliasing</td></tr>
<tr><td><code>execute()</code></td><td>Prepare and run all passes, return command buffers</td></tr>
<tr><td><code>set_external_texture()</code></td><td>Provide an external texture (e.g. swapchain) each frame</td></tr>
<tr><td><code>set_pass_enabled()</code></td><td>Enable/disable a pass at runtime</td></tr>
<tr><td><code>get_pass_mut()</code></td><td>Access a pass for runtime configuration</td></tr>
<tr><td><code>resize_transient_resource()</code></td><td>Change dimensions of a transient texture</td></tr>
</tbody></table>
</div>
<h2 id="compilation-steps"><a class="header" href="#compilation-steps">Compilation Steps</a></h2>
<p>When <code>compile()</code> is called:</p>
<ol>
<li><strong>Build dependency edges</strong> - For each resource, the graph creates an edge from writer to reader</li>
<li><strong>Topological sort</strong> - Passes are sorted so every pass executes after its dependencies</li>
<li><strong>Compute store ops</strong> - Determine Store vs Discard for each resource write</li>
<li><strong>Compute clear ops</strong> - Determine which pass performs the initial Clear for each resource</li>
<li><strong>Compute resource lifetimes</strong> - Track first_use and last_use for each transient resource</li>
<li><strong>Compute resource aliasing</strong> - Transient resources with non-overlapping lifetimes share GPU memory</li>
<li><strong>Dead pass culling</strong> - Passes that don't contribute to external outputs are marked for skipping</li>
</ol>
<h2 id="sub-chapters"><a class="header" href="#sub-chapters">Sub-Chapters</a></h2>
<ul>
<li><a href="render-graph-resources.html">Resources &amp; Textures</a> - Resource types, builders, external vs transient</li>
<li><a href="render-graph-passes.html">Passes &amp; the PassNode Trait</a> - Implementing custom passes</li>
<li><a href="render-graph-scheduling.html">Dependency Resolution &amp; Scheduling</a> - How passes are ordered</li>
<li><a href="render-graph-aliasing.html">Resource Aliasing &amp; Memory</a> - GPU memory sharing</li>
<li><a href="render-graph-custom.html">Custom Passes</a> - Full examples of custom rendering</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources--textures"><a class="header" href="#resources--textures">Resources &amp; Textures</a></h1>
<p>Render graph resources are GPU textures and buffers that passes read from and write to. Each resource has a <code>ResourceId</code> handle used for all graph operations.</p>
<h2 id="resourceid"><a class="header" href="#resourceid">ResourceId</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ResourceId(pub u32);
<span class="boring">}</span></code></pre></pre>
<p><code>ResourceId</code> is an opaque handle returned when you declare a resource. Pass it to <code>add_pass()</code> slot bindings to connect passes to resources.</p>
<h2 id="resource-types"><a class="header" href="#resource-types">Resource Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ExternalColor</code></td><td>Color texture provided externally each frame (e.g. swapchain)</td></tr>
<tr><td><code>TransientColor</code></td><td>Color texture managed by the graph (allocated, aliased, freed automatically)</td></tr>
<tr><td><code>ExternalDepth</code></td><td>Depth texture provided externally</td></tr>
<tr><td><code>TransientDepth</code></td><td>Depth texture managed by the graph</td></tr>
<tr><td><code>ExternalBuffer</code></td><td>GPU buffer provided externally</td></tr>
<tr><td><code>TransientBuffer</code></td><td>GPU buffer managed by the graph</td></tr>
</tbody></table>
</div>
<h2 id="external-vs-transient"><a class="header" href="#external-vs-transient">External vs Transient</a></h2>
<p><strong>External</strong> resources are owned by you. You provide them each frame via <code>set_external_texture()</code>. The graph never creates or destroys them. The swapchain texture is the most common external resource.</p>
<p><strong>Transient</strong> resources are owned by the graph. The graph creates GPU textures/buffers as needed, tracks their lifetimes, and can alias them (share memory between resources with non-overlapping lifetimes) to minimize VRAM usage.</p>
<h2 id="creating-color-textures"><a class="header" href="#creating-color-textures">Creating Color Textures</a></h2>
<p>Use the fluent builder:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Transient - graph manages lifetime and may alias memory
let hdr = graph.add_color_texture("scene_color")
    .format(wgpu::TextureFormat::Rgba16Float)
    .size(1920, 1080)
    .clear_color(wgpu::Color::BLACK)
    .transient();

// External - you provide the texture each frame
let swapchain = graph.add_color_texture("swapchain")
    .format(wgpu::TextureFormat::Bgra8UnormSrgb)
    .external();
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>format(TextureFormat)</code></td><td>Pixel format (default: Rgba8UnormSrgb)</td></tr>
<tr><td><code>size(width, height)</code></td><td>Texture dimensions</td></tr>
<tr><td><code>usage(TextureUsages)</code></td><td>GPU usage flags</td></tr>
<tr><td><code>sample_count(u32)</code></td><td>MSAA sample count</td></tr>
<tr><td><code>mip_levels(u32)</code></td><td>Mipmap level count</td></tr>
<tr><td><code>clear_color(Color)</code></td><td>Clear color (only for the first pass that writes)</td></tr>
<tr><td><code>no_store()</code></td><td>Don't force store after last write</td></tr>
<tr><td><code>transient()</code></td><td>Finalize as transient (returns ResourceId)</td></tr>
<tr><td><code>external()</code></td><td>Finalize as external (returns ResourceId)</td></tr>
</tbody></table>
</div>
<h2 id="creating-depth-textures"><a class="header" href="#creating-depth-textures">Creating Depth Textures</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let depth = graph.add_depth_texture("depth")
    .size(1920, 1080)
    .format(wgpu::TextureFormat::Depth32Float)
    .clear_depth(0.0)
    .transient();
<span class="boring">}</span></code></pre></pre>
<h3 id="depth-builder-methods"><a class="header" href="#depth-builder-methods">Depth Builder Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>format(TextureFormat)</code></td><td>Depth format (default: Depth32Float)</td></tr>
<tr><td><code>size(width, height)</code></td><td>Texture dimensions</td></tr>
<tr><td><code>usage(TextureUsages)</code></td><td>GPU usage flags</td></tr>
<tr><td><code>array_layers(u32)</code></td><td>For texture arrays (e.g. shadow cascades)</td></tr>
<tr><td><code>clear_depth(f32)</code></td><td>Clear depth value</td></tr>
<tr><td><code>no_store()</code></td><td>Don't force store</td></tr>
<tr><td><code>transient()</code> / <code>external()</code></td><td>Finalize</td></tr>
</tbody></table>
</div>
<h2 id="creating-buffers"><a class="header" href="#creating-buffers">Creating Buffers</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_buffer = graph.add_buffer("compute_data")
    .size(1024 * 1024)
    .usage(wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST)
    .transient();
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-templates"><a class="header" href="#resource-templates">Resource Templates</a></h2>
<p>For creating multiple similar resources, use templates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let template = ResourceTemplate::new(
    wgpu::TextureFormat::Rgba16Float,
    1920,
    1080,
).usage(wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING);

let texture_a = graph.transient_color_from_template("blur_a", &amp;template);
let texture_b = graph.transient_color_from_template("blur_b", &amp;template);
<span class="boring">}</span></code></pre></pre>
<h3 id="template-methods"><a class="header" href="#template-methods">Template Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new(format, width, height)</code></td><td>Create a template</td></tr>
<tr><td><code>usage(TextureUsages)</code></td><td>Set usage flags</td></tr>
<tr><td><code>sample_count(u32)</code></td><td>MSAA samples</td></tr>
<tr><td><code>mip_levels(u32)</code></td><td>Mipmap levels</td></tr>
<tr><td><code>array_layers(u32)</code></td><td>Texture array layers</td></tr>
<tr><td><code>cube_map()</code></td><td>Configure as cube map (6 layers)</td></tr>
<tr><td><code>dimension_3d(depth)</code></td><td>3D texture</td></tr>
</tbody></table>
</div>
<h2 id="resource-pools"><a class="header" href="#resource-pools">Resource Pools</a></h2>
<p>For batch allocation from a template:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pool = graph.resource_pool(&amp;template);
let [blur_a, blur_b, blur_c] = [
    pool.transient("blur_a"),
    pool.transient("blur_b"),
    pool.transient("blur_c"),
];
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-external-textures-per-frame"><a class="header" href="#setting-external-textures-per-frame">Setting External Textures Per-Frame</a></h2>
<p>External textures must be provided each frame before <code>execute()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each frame, provide the swapchain texture
let surface_texture = surface.get_current_texture()?;
let view = surface_texture.texture.create_view(&amp;Default::default());
graph.set_external_texture(swapchain_id, view, width, height);
<span class="boring">}</span></code></pre></pre>
<h2 id="resizing-transient-textures"><a class="header" href="#resizing-transient-textures">Resizing Transient Textures</a></h2>
<p>When the window resizes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.resize_transient_resource(&amp;device, depth_id, new_width, new_height)?;
graph.resize_transient_resource(&amp;device, scene_color_id, new_width, new_height)?;
<span class="boring">}</span></code></pre></pre>
<p>This invalidates the aliasing info and triggers reallocation on the next execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passes--the-passnode-trait"><a class="header" href="#passes--the-passnode-trait">Passes &amp; the PassNode Trait</a></h1>
<p>Every render pass implements the <code>PassNode</code> trait to declare its resource dependencies and execute GPU commands.</p>
<h2 id="the-passnode-trait"><a class="header" href="#the-passnode-trait">The PassNode Trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PassNode&lt;C = ()&gt;: Send + Sync + Any {
    fn name(&amp;self) -&gt; &amp;str;
    fn reads(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    fn writes(&amp;self) -&gt; Vec&lt;&amp;str&gt;;
    fn reads_writes(&amp;self) -&gt; Vec&lt;&amp;str&gt; { Vec::new() }
    fn optional_reads(&amp;self) -&gt; Vec&lt;&amp;str&gt; { Vec::new() }
    fn prepare(&amp;mut self, _device: &amp;Device, _queue: &amp;wgpu::Queue, _configs: &amp;C) {}
    fn invalidate_bind_groups(&amp;mut self) {}
    fn execute&lt;'r, 'e&gt;(
        &amp;mut self,
        context: PassExecutionContext&lt;'r, 'e, C&gt;,
    ) -&gt; Result&lt;Vec&lt;SubGraphRunCommand&lt;'r&gt;&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>On WASM, the <code>Send + Sync</code> bounds are removed.</p>
<h2 id="slot-based-resource-binding"><a class="header" href="#slot-based-resource-binding">Slot-Based Resource Binding</a></h2>
<p>Passes declare named <strong>slots</strong> that map to graph resources. The slot names are strings that match the keys in the <code>add_pass()</code> bindings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PassNode&lt;World&gt; for MyPass {
    fn name(&amp;self) -&gt; &amp;str { "my_pass" }

    // Slots this pass reads from (input textures)
    fn reads(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec!["input"] }

    // Slots this pass writes to (output attachments)
    fn writes(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec!["output"] }

    // Slots that are both read and written (read-modify-write)
    fn reads_writes(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec![] }

    // Slots that are read if available, but don't create dependencies if absent
    fn optional_reads(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec![] }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>When adding the pass to the graph, you bind slot names to resource IDs:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.add_pass(
    Box::new(my_pass),
    &amp;[("input", scene_color_id), ("output", swapchain_id)],
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="passexecutioncontext"><a class="header" href="#passexecutioncontext">PassExecutionContext</a></h2>
<p>The context provides access to resources during execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PassExecutionContext&lt;'r, 'e, C = ()&gt; {
    pub encoder: &amp;'e mut CommandEncoder,
    pub resources: &amp;'r RenderGraphResources,
    pub device: &amp;'r Device,
    pub queue: &amp;'r wgpu::Queue,
    pub configs: &amp;'r C,  // For Nightshade, this is &amp;World
    // ... internal fields
}
<span class="boring">}</span></code></pre></pre>
<h3 id="context-methods"><a class="header" href="#context-methods">Context Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get_texture_view(slot)</code></td><td><code>&amp;TextureView</code></td><td>Get a texture view for sampling</td></tr>
<tr><td><code>get_color_attachment(slot)</code></td><td><code>(view, LoadOp, StoreOp)</code></td><td>Get color attachment with automatic load/store ops</td></tr>
<tr><td><code>get_depth_attachment(slot)</code></td><td><code>(view, LoadOp, StoreOp)</code></td><td>Get depth attachment with automatic load/store ops</td></tr>
<tr><td><code>get_buffer(slot)</code></td><td><code>&amp;Buffer</code></td><td>Get a GPU buffer</td></tr>
<tr><td><code>get_texture_size(slot)</code></td><td><code>(u32, u32)</code></td><td>Get texture dimensions</td></tr>
<tr><td><code>is_pass_enabled()</code></td><td><code>bool</code></td><td>Check if this pass is currently enabled</td></tr>
<tr><td><code>run_sub_graph(name, inputs)</code></td><td>-</td><td>Execute a sub-graph</td></tr>
</tbody></table>
</div>
<h3 id="automatic-loadstore-operations"><a class="header" href="#automatic-loadstore-operations">Automatic Load/Store Operations</a></h3>
<p>The graph automatically determines the correct load and store operations:</p>
<ul>
<li><strong>LoadOp::Clear</strong> - Used when this pass is the first writer and the resource has a clear value</li>
<li><strong>LoadOp::Load</strong> - Used when a previous pass already wrote to this resource</li>
<li><strong>StoreOp::Store</strong> - Used when another pass will read this resource later</li>
<li><strong>StoreOp::Discard</strong> - Used when no subsequent pass reads this resource</li>
</ul>
<p>You don't choose these yourself - the <code>get_color_attachment()</code> and <code>get_depth_attachment()</code> methods return the correct ops.</p>
<h2 id="prepare-phase"><a class="header" href="#prepare-phase">Prepare Phase</a></h2>
<p><code>prepare()</code> is called before execution for each non-culled pass. Use it to upload uniforms:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;mut self, device: &amp;Device, queue: &amp;wgpu::Queue, configs: &amp;World) {
    let camera_data = extract_camera_uniforms(configs);
    queue.write_buffer(&amp;self.uniform_buffer, 0, bytemuck::bytes_of(&amp;camera_data));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bind-group-invalidation"><a class="header" href="#bind-group-invalidation">Bind Group Invalidation</a></h2>
<p>When the graph reallocates resources (e.g. after resize), <code>invalidate_bind_groups()</code> is called on affected passes. Clear any cached bind groups:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn invalidate_bind_groups(&amp;mut self) {
    self.bind_group = None;
}
<span class="boring">}</span></code></pre></pre>
<p>The graph tracks resource versions and only invalidates passes that reference changed resources.</p>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlurPass {
    pipeline: wgpu::RenderPipeline,
    bind_group_layout: wgpu::BindGroupLayout,
    bind_group: Option&lt;wgpu::BindGroup&gt;,
    sampler: wgpu::Sampler,
}

impl PassNode&lt;World&gt; for BlurPass {
    fn name(&amp;self) -&gt; &amp;str { "blur_pass" }
    fn reads(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec!["input"] }
    fn writes(&amp;self) -&gt; Vec&lt;&amp;str&gt; { vec!["output"] }

    fn invalidate_bind_groups(&amp;mut self) {
        self.bind_group = None;
    }

    fn execute&lt;'r, 'e&gt;(
        &amp;mut self,
        ctx: PassExecutionContext&lt;'r, 'e, World&gt;,
    ) -&gt; Result&lt;Vec&lt;SubGraphRunCommand&lt;'r&gt;&gt;&gt; {
        if !ctx.is_pass_enabled() {
            return Ok(vec![]);
        }

        let input_view = ctx.get_texture_view("input")?;
        let (output_view, load_op, store_op) = ctx.get_color_attachment("output")?;

        if self.bind_group.is_none() {
            self.bind_group = Some(ctx.device.create_bind_group(&amp;wgpu::BindGroupDescriptor {
                layout: &amp;self.bind_group_layout,
                entries: &amp;[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(input_view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&amp;self.sampler),
                    },
                ],
                label: Some("blur_bind_group"),
            }));
        }

        let mut pass = ctx.encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor {
            label: Some("blur_pass"),
            color_attachments: &amp;[Some(wgpu::RenderPassColorAttachment {
                view: output_view,
                resolve_target: None,
                ops: wgpu::Operations { load: load_op, store: store_op },
            })],
            depth_stencil_attachment: None,
            ..Default::default()
        });

        pass.set_pipeline(&amp;self.pipeline);
        pass.set_bind_group(0, self.bind_group.as_ref().unwrap(), &amp;[]);
        pass.draw(0..3, 0..1);  // Fullscreen triangle

        Ok(vec![])
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sub-graph-execution"><a class="header" href="#sub-graph-execution">Sub-Graph Execution</a></h2>
<p>Passes can trigger sub-graph execution for multi-pass effects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn execute&lt;'r, 'e&gt;(
    &amp;mut self,
    mut ctx: PassExecutionContext&lt;'r, 'e, World&gt;,
) -&gt; Result&lt;Vec&lt;SubGraphRunCommand&lt;'r&gt;&gt;&gt; {
    ctx.run_sub_graph("bloom_mip_chain".to_string(), vec![
        SlotValue::TextureView {
            view: ctx.get_texture_view("hdr")?,
            width: self.width,
            height: self.height,
        },
    ]);

    Ok(ctx.into_sub_graph_commands())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-resolution--scheduling"><a class="header" href="#dependency-resolution--scheduling">Dependency Resolution &amp; Scheduling</a></h1>
<p>The render graph automatically orders passes based on their resource dependencies. This chapter explains how that works.</p>
<h2 id="dependency-edge-construction"><a class="header" href="#dependency-edge-construction">Dependency Edge Construction</a></h2>
<p>When <code>compile()</code> is called, the graph builds edges between passes:</p>
<ol>
<li>Iterate through all passes</li>
<li>For each resource a pass reads, find the pass that last wrote to it</li>
<li>Create a directed edge from the writer to the reader</li>
</ol>
<pre><code>Pass A writes texture T
Pass B reads texture T
  =&gt; Edge: A -&gt; B (B depends on A)
</code></pre>
<p>For <code>reads_writes</code> resources, the pass is treated as both a reader and a writer. Optional reads create edges only if a writer exists.</p>
<h2 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h2>
<p>After building edges, the graph performs a topological sort using petgraph. A topological sort of a DAG produces a linear ordering where for every edge A -&gt; B, A appears before B. This guarantees every pass runs after all the passes that produce its inputs.</p>
<p>For a graph with V passes and E dependency edges, topological sorting runs in O(V + E) time using Kahn's algorithm (iteratively remove nodes with no incoming edges) or depth-first search. petgraph implements this efficiently.</p>
<p>If the graph contains cycles (A depends on B, B depends on A), no valid topological ordering exists and compilation fails with <code>RenderGraphError::CyclicDependency</code>. Cycles in a render graph indicate a logical error: two passes cannot each depend on the other's output.</p>
<h2 id="dead-pass-culling"><a class="header" href="#dead-pass-culling">Dead Pass Culling</a></h2>
<p>Not all passes may contribute to the final output. The graph uses backward reachability from external resources to determine which passes are needed:</p>
<ol>
<li>Start with all external resources as "required"</li>
<li>Walk backward through the execution order</li>
<li>A pass is required if it writes to a required resource (or has no writes/reads_writes, indicating side effects)</li>
<li>If a pass is required, all resources it reads become required too</li>
<li>Passes not marked as required are culled</li>
</ol>
<pre><code>Pass A writes T1
Pass B reads T1, writes T2     &lt;- T2 is not read by anyone
Pass C reads T1, writes output  &lt;- output is external

Result: A and C execute, B is culled
</code></pre>
<h2 id="runtime-pass-toggling"><a class="header" href="#runtime-pass-toggling">Runtime Pass Toggling</a></h2>
<p>Passes can be enabled or disabled at runtime without recompiling the graph:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.set_pass_enabled("bloom_pass", false)?;
<span class="boring">}</span></code></pre></pre>
<p>When a pass is disabled, its <code>execute()</code> method receives <code>is_pass_enabled() == false</code>. The pass can check this and skip all GPU work:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn execute&lt;'r, 'e&gt;(
    &amp;mut self,
    ctx: PassExecutionContext&lt;'r, 'e, World&gt;,
) -&gt; Result&lt;Vec&lt;SubGraphRunCommand&lt;'r&gt;&gt;&gt; {
    if !ctx.is_pass_enabled() {
        return Ok(vec![]);
    }
    // ... normal execution
}
<span class="boring">}</span></code></pre></pre>
<h2 id="recompilation"><a class="header" href="#recompilation">Recompilation</a></h2>
<p>The graph tracks a <code>needs_recompile</code> flag. Adding or removing passes sets this flag. On the next <code>execute()</code>, the graph:</p>
<ol>
<li>Removes all existing edges</li>
<li>Rebuilds dependency edges</li>
<li>Re-sorts topologically</li>
<li>Recomputes store ops, clear ops, lifetimes, and aliasing</li>
</ol>
<p>This happens automatically - you don't need to call <code>compile()</code> again manually.</p>
<h2 id="store-and-clear-operations"><a class="header" href="#store-and-clear-operations">Store and Clear Operations</a></h2>
<h3 id="store-operations"><a class="header" href="#store-operations">Store Operations</a></h3>
<p>On tile-based GPU architectures (mobile GPUs, Apple Silicon), render pass attachments are stored in fast on-chip tile memory during rendering. At the end of the render pass, the driver must decide whether to write that tile memory back to main VRAM. This write-back is called a "store" operation and it has significant bandwidth cost.</p>
<p>For each resource write, the graph determines whether to store the result:</p>
<ul>
<li><strong>Store</strong> - If any later pass reads this resource, or if it's an external resource with <code>force_store</code>. The data must survive to be read later.</li>
<li><strong>Discard</strong> - If no later pass reads this resource. The GPU can skip the write-back entirely, saving memory bandwidth. This is a significant optimization on tile-based architectures.</li>
</ul>
<h3 id="clear-operations"><a class="header" href="#clear-operations">Clear Operations</a></h3>
<p>Similarly, at the start of a render pass, the GPU must decide what to do with the existing attachment contents:</p>
<ul>
<li><strong>Clear</strong> - Write a known value (black, zero depth) into the attachment. This is cheap because the GPU can initialize tile memory without reading from VRAM.</li>
<li><strong>Load</strong> - Read the existing contents from VRAM into tile memory. This is necessary when a previous pass has already written data that this pass needs to preserve.</li>
</ul>
<p>The first pass that writes to a resource with a clear value (clear_color or clear_depth) gets a <code>LoadOp::Clear</code>. All subsequent writers get <code>LoadOp::Load</code>.</p>
<p>These are computed during compilation and used automatically by <code>get_color_attachment()</code> and <code>get_depth_attachment()</code>. Getting these wrong is a common source of rendering bugs: using Clear when you should Load erases previous passes' work; using Load when you should Clear wastes bandwidth loading garbage data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-aliasing--memory"><a class="header" href="#resource-aliasing--memory">Resource Aliasing &amp; Memory</a></h1>
<p>Transient resources with non-overlapping lifetimes can share the same GPU memory. The render graph computes this automatically to minimize VRAM usage.</p>
<h2 id="why-aliasing-matters"><a class="header" href="#why-aliasing-matters">Why Aliasing Matters</a></h2>
<p>A modern rendering pipeline might use 15+ intermediate textures: shadow maps, SSAO buffers, bloom mip chains, SSR buffers, selection masks, and more. At 1080p, a single Rgba16Float texture is about 16 MB. At 4K, it's 64 MB. Without aliasing, all these textures exist simultaneously in VRAM even if they're never alive at the same time.</p>
<p>Resource aliasing is the GPU equivalent of stack allocation: the same memory region is reused by different variables (textures) whose lifetimes don't overlap. The render graph's execution order gives a total ordering of pass execution, which makes it possible to compute exact lifetimes and find aliasing opportunities.</p>
<p>This technique is inspired by the Frostbite engine's frame graph (GDC 2017) and is standard practice in modern engines. The savings can be 30-50% of transient VRAM depending on the pipeline.</p>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<p>After topological sorting, the graph knows the execution order. For each transient resource, it computes:</p>
<ul>
<li><strong>first_use</strong> - The pass index where the resource is first written</li>
<li><strong>last_use</strong> - The pass index where the resource is last read</li>
</ul>
<p>If resource A's lifetime ends before resource B's lifetime begins, and they have compatible formats, they can share the same GPU texture:</p>
<pre><code>Pass 0: writes A
Pass 1: reads A, writes B
Pass 2: reads B, writes C    &lt;- A's memory can be reused for C
Pass 3: reads C, writes output
</code></pre>
<p>Here, A's lifetime is [0, 1] and C's lifetime is [2, 3]. Since they don't overlap and have compatible descriptors, the graph assigns them to the same pool slot.</p>
<h2 id="compatibility-requirements"><a class="header" href="#compatibility-requirements">Compatibility Requirements</a></h2>
<p>Two textures can alias if they have identical:</p>
<ul>
<li>Format</li>
<li>Width and height</li>
<li>Sample count</li>
<li>Mip level count</li>
<li>The reuser's usage flags are a subset of the pool's usage flags</li>
</ul>
<p>Two buffers can alias if the pool's size is at least as large as the reuser's, and usage flags match exactly.</p>
<p>If a reuser needs additional usage flags, the pool texture is recreated with the combined flags.</p>
<h2 id="pool-based-allocation"><a class="header" href="#pool-based-allocation">Pool-Based Allocation</a></h2>
<p>The aliasing system uses a pool with a <code>BinaryHeap</code> for efficient slot reuse:</p>
<ol>
<li>Sort transient resources by first_use</li>
<li>For each resource:
<ul>
<li>Check if any pool slot has a <code>lifetime_end</code> before this resource's <code>first_use</code></li>
<li>If a compatible slot is found, reuse it</li>
<li>Otherwise, allocate a new pool slot</li>
</ul>
</li>
<li>Each pool slot holds at most one GPU texture/buffer at a time</li>
</ol>
<p>The heap is ordered by <code>lifetime_end</code> (min-heap), so the earliest-expiring slots are checked first.</p>
<h2 id="bind-group-invalidation-1"><a class="header" href="#bind-group-invalidation-1">Bind Group Invalidation</a></h2>
<p>When a transient resource gets a new GPU texture (because the pool slot was reallocated), any passes that reference that resource need to recreate their bind groups.</p>
<p>The graph tracks a <strong>version number</strong> per resource. When a resource's version changes between frames:</p>
<ol>
<li>Find all passes that read, write, or reads_write that resource</li>
<li>Call <code>invalidate_bind_groups()</code> on those passes</li>
<li>Update the stored version</li>
</ol>
<p>This ensures passes always reference the correct GPU texture, even after aliasing changes or window resizes.</p>
<h2 id="memory-savings"><a class="header" href="#memory-savings">Memory Savings</a></h2>
<p>For a typical scene with 15+ transient textures, aliasing can reduce VRAM usage significantly. For example:</p>
<ul>
<li><code>ssao_raw</code> and <code>ssgi_raw</code> may never be alive at the same time</li>
<li>Shadow depth maps are only needed during shadow passes, then their memory can be reused</li>
<li>Intermediate blur textures from bloom can share memory with SSR blur textures</li>
</ul>
<p>The exact savings depend on pass ordering and resource sizes.</p>
<h2 id="external-resources"><a class="header" href="#external-resources">External Resources</a></h2>
<p>External resources (swapchain, viewport outputs) are never aliased. They are always owned externally and provided fresh each frame.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-passes"><a class="header" href="#custom-passes">Custom Passes</a></h1>
<p>Customize the rendering pipeline by adding your own passes to the render graph.</p>
<h2 id="configure_render_graph-1"><a class="header" href="#configure_render_graph-1">configure_render_graph()</a></h2>
<p>Override this <code>State</code> method to add custom passes at startup:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    // Add custom textures
    let my_texture = graph.add_color_texture("my_effect")
        .format(wgpu::TextureFormat::Rgba16Float)
        .size(1920, 1080)
        .clear_color(wgpu::Color::BLACK)
        .transient();

    // Add custom passes
    let my_pass = MyCustomPass::new(device);
    graph.add_pass(
        Box::new(my_pass),
        &amp;[("input", resources.scene_color), ("output", my_texture)],
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="renderresources"><a class="header" href="#renderresources">RenderResources</a></h2>
<p>The <code>RenderResources</code> struct provides resource IDs for all built-in textures:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>scene_color</code></td><td>HDR color buffer (Rgba16Float)</td></tr>
<tr><td><code>depth</code></td><td>Main depth buffer (Depth32Float)</td></tr>
<tr><td><code>compute_output</code></td><td>Post-processed output before swapchain blit</td></tr>
<tr><td><code>swapchain</code></td><td>Final swapchain output</td></tr>
<tr><td><code>view_normals</code></td><td>View-space normals</td></tr>
<tr><td><code>ssao_raw</code> / <code>ssao</code></td><td>Raw and blurred SSAO</td></tr>
<tr><td><code>ssgi_raw</code> / <code>ssgi</code></td><td>Raw and blurred SSGI</td></tr>
<tr><td><code>ssr_raw</code> / <code>ssr</code></td><td>Raw and blurred SSR</td></tr>
<tr><td><code>surface_width</code> / <code>surface_height</code></td><td>Current window dimensions in pixels</td></tr>
</tbody></table>
</div>
<h2 id="update_render_graph-1"><a class="header" href="#update_render_graph-1">update_render_graph()</a></h2>
<p>For per-frame changes, use <code>update_render_graph()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, world: &amp;World) {
    if self.bloom_changed {
        let _ = graph.set_pass_enabled("bloom_pass", self.bloom_enabled);
        self.bloom_changed = false;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-built-in-passes"><a class="header" href="#adding-built-in-passes">Adding Built-in Passes</a></h2>
<p>Use the built-in pass types in your custom graph:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::passes;

fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    let bloom_texture = graph.add_color_texture("bloom")
        .format(wgpu::TextureFormat::Rgba16Float)
        .size(960, 540)
        .clear_color(wgpu::Color::BLACK)
        .transient();

    // Bloom
    let bloom_pass = passes::BloomPass::new(device, 1920, 1080);
    graph.add_pass(
        Box::new(bloom_pass),
        &amp;[("hdr", resources.scene_color), ("bloom", bloom_texture)],
    );

    // SSAO
    let ssao_pass = passes::SsaoPass::new(device, 1920, 1080);
    graph.add_pass(
        Box::new(ssao_pass),
        &amp;[
            ("depth", resources.depth),
            ("normals", resources.view_normals),
            ("ssao_raw", resources.ssao_raw),
        ],
    );

    let ssao_blur_pass = passes::SsaoBlurPass::new(device, 1920, 1080);
    graph.add_pass(
        Box::new(ssao_blur_pass),
        &amp;[("ssao_raw", resources.ssao_raw), ("ssao", resources.ssao)],
    );

    // Final compositing
    let postprocess_pass = passes::PostProcessPass::new(device, surface_format, 0.3);
    graph.add_pass(
        Box::new(postprocess_pass),
        &amp;[
            ("hdr", resources.scene_color),
            ("bloom", bloom_texture),
            ("ssao", resources.ssao),
            ("output", resources.compute_output),
        ],
    );

    // Blit to swapchain
    let blit_pass = passes::BlitPass::new(device, surface_format);
    graph.add_pass(
        Box::new(blit_pass),
        &amp;[("input", resources.compute_output), ("output", resources.swapchain)],
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="passbuilder-fluent-api"><a class="header" href="#passbuilder-fluent-api">PassBuilder Fluent API</a></h2>
<p>Instead of <code>add_pass()</code>, you can use the fluent builder:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.pass(Box::new(bloom_pass))
    .read("hdr", resources.scene_color)
    .write("bloom", bloom_texture);

graph.pass(Box::new(postprocess_pass))
    .read("hdr", resources.scene_color)
    .read("bloom", bloom_texture)
    .read("ssao", resources.ssao)
    .write("output", resources.swapchain);
<span class="boring">}</span></code></pre></pre>
<p>The <code>PassBuilder</code> automatically adds the pass to the graph when it goes out of scope (via <code>Drop</code>).</p>
<h2 id="conditional-passes"><a class="header" href="#conditional-passes">Conditional Passes</a></h2>
<p>Enable or disable passes based on settings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    if self.ssao_enabled {
        let ssao_pass = passes::SsaoPass::new(device, 1920, 1080);
        graph.add_pass(
            Box::new(ssao_pass),
            &amp;[
                ("depth", resources.depth),
                ("normals", resources.view_normals),
                ("ssao_raw", resources.ssao_raw),
            ],
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or toggle at runtime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, _world: &amp;World) {
    let _ = graph.set_pass_enabled("ssao_pass", self.ssao_enabled);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="default-pipeline"><a class="header" href="#default-pipeline">Default Pipeline</a></h2>
<p>If you don't override <code>configure_render_graph()</code>, the default implementation adds:</p>
<ol>
<li><strong>BloomPass</strong> - HDR bloom at half resolution</li>
<li><strong>PostProcessPass</strong> - Tonemapping and compositing</li>
<li><strong>BlitPass</strong> - Copy to swapchain</li>
</ol>
<p>The engine always adds the core passes (clear, sky, shadow, mesh, skinned mesh, water, grass, grid, lines, selection) regardless of your custom configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-default-pipeline"><a class="header" href="#the-default-pipeline">The Default Pipeline</a></h1>
<p>The engine constructs a default render graph with all built-in passes. This chapter shows the complete pass ordering and data flow.</p>
<h2 id="pass-execution-order"><a class="header" href="#pass-execution-order">Pass Execution Order</a></h2>
<p>The graph topologically sorts these passes based on their dependencies. The typical execution order is:</p>
<pre><code>1.  ClearPass           - Clear scene_color and depth
2.  ShadowDepthPass     - Render cascaded shadow maps + spotlight shadows
3.  SkyPass             - Render procedural atmosphere to scene_color
4.  ScenePass           - Render scene objects (simple path) to scene_color
5.  MeshPass            - Render PBR meshes with shadows and lighting
6.  SkinnedMeshPass     - Render animated skeletal meshes
7.  WaterPass           - Render water surface
8.  WaterMeshPass       - Render water mesh displacement
9.  GrassPass           - Render GPU-instanced grass
10. GridPass            - Render infinite ground grid
11. LinesPass           - Render debug lines
12. SelectionMaskPass   - Generate selection mask for editor
13. OutlinePass         - Render selection outline

    --- User passes (from configure_render_graph) ---

14. BloomPass           - HDR bloom (default)
15. PostProcessPass     - Tonemapping and compositing (default)
16. BlitPass            - Copy to swapchain (default)

    --- UI passes ---

17. EguiPass            - egui UI (if egui feature enabled)
</code></pre>
<h2 id="data-flow-diagram"><a class="header" href="#data-flow-diagram">Data Flow Diagram</a></h2>
<pre><code>                    shadow_depth
ShadowDepthPass --&gt; spotlight_shadow_atlas
                        |
                        v
SkyPass ----------&gt; scene_color &lt;-- ClearPass
                        |
MeshPass ----------&gt; scene_color, depth, entity_id, view_normals
                        |
SkinnedMeshPass --&gt; scene_color, depth
                        |
WaterPass --------&gt; scene_color, depth
GrassPass --------&gt; scene_color, depth
GridPass ---------&gt; scene_color, depth
LinesPass --------&gt; scene_color, depth
                        |
                        v
BloomPass --------&gt; bloom (half-res)
                        |
PostProcessPass --&gt; compute_output
    reads: scene_color, bloom, ssao
                        |
BlitPass ---------&gt; swapchain
</code></pre>
<h2 id="core-passes-always-present"><a class="header" href="#core-passes-always-present">Core Passes (Always Present)</a></h2>
<p>These passes are added by the engine during renderer initialization. They cannot be removed, but can be disabled at runtime.</p>
<h3 id="clearpass"><a class="header" href="#clearpass">ClearPass</a></h3>
<p>Clears <code>scene_color</code> to black and <code>depth</code> to 0.0 (reversed-Z far plane).</p>
<h3 id="skypass"><a class="header" href="#skypass">SkyPass</a></h3>
<p>Renders the procedural atmosphere or solid background color. Controlled by <code>world.resources.graphics.atmosphere</code>.</p>
<h3 id="scenepass"><a class="header" href="#scenepass">ScenePass</a></h3>
<p>A simple scene rendering pass for basic objects.</p>
<h3 id="shadowdepthpass"><a class="header" href="#shadowdepthpass">ShadowDepthPass</a></h3>
<p>Renders the shadow map. See <a href="shadows.html">Shadow Mapping</a>.</p>
<h3 id="meshpass"><a class="header" href="#meshpass">MeshPass</a></h3>
<p>The main PBR mesh rendering pass. See <a href="geometry-passes.html">Geometry Passes</a>.</p>
<h3 id="skinnedmeshpass"><a class="header" href="#skinnedmeshpass">SkinnedMeshPass</a></h3>
<p>Renders animated skeletal meshes with GPU skinning.</p>
<h3 id="selection-passes"><a class="header" href="#selection-passes">Selection Passes</a></h3>
<p><code>SelectionMaskPass</code> and <code>OutlinePass</code> generate and render editor selection outlines.</p>
<h2 id="user-configurable-passes-default"><a class="header" href="#user-configurable-passes-default">User-Configurable Passes (Default)</a></h2>
<p>These passes are added by the default <code>configure_render_graph()</code> implementation. Override this method to replace them.</p>
<h3 id="bloompass"><a class="header" href="#bloompass">BloomPass</a></h3>
<p>Reads <code>scene_color</code>, writes a half-resolution <code>bloom</code> texture.</p>
<h3 id="postprocesspass"><a class="header" href="#postprocesspass">PostProcessPass</a></h3>
<p>Reads <code>scene_color</code>, <code>bloom</code>, and <code>ssao</code>. Performs tonemapping and compositing. Writes to <code>compute_output</code>.</p>
<h3 id="blitpass"><a class="header" href="#blitpass">BlitPass</a></h3>
<p>Copies <code>compute_output</code> to <code>swapchain</code> for presentation.</p>
<h2 id="adding-ssaossgissr"><a class="header" href="#adding-ssaossgissr">Adding SSAO/SSGI/SSR</a></h2>
<p>The default pipeline only includes bloom and tonemapping. To enable SSAO, SSGI, or SSR, override <code>configure_render_graph()</code> and add the appropriate passes. See <a href="post-processing.html">Post-Processing</a> for the full list of available post-processing passes and <a href="render-graph-custom.html">Custom Passes</a> for examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-mapping"><a class="header" href="#shadow-mapping">Shadow Mapping</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/shadows">Shadows</a> | <a href="https://matthewberger.dev/nightshade/spotlight_shadows">Spotlight Shadows</a></p>
</blockquote>
<p>Nightshade uses cascaded shadow mapping for directional lights and a shadow atlas for spotlights.</p>
<h2 id="how-shadow-mapping-works"><a class="header" href="#how-shadow-mapping-works">How Shadow Mapping Works</a></h2>
<p>Shadow mapping is a two-pass technique. In the first pass, the scene is rendered from the light's point of view into a depth-only texture (the shadow map). In the second pass (the main geometry pass), each fragment projects itself into the light's coordinate space and compares its depth against the stored shadow map value. If the fragment is farther from the light than the shadow map records, something closer is blocking the light, and the fragment is in shadow.</p>
<p>The core idea is that the shadow map captures the "closest surface to the light" at every pixel. Any surface behind that closest surface must be occluded.</p>
<h3 id="the-resolution-problem"><a class="header" href="#the-resolution-problem">The Resolution Problem</a></h3>
<p>A single shadow map has finite resolution. A directional light (like the sun) illuminates the entire scene, but the shadow map must cover it all. Objects near the camera need high-resolution shadows (you can see the shadow edges clearly), while distant objects can tolerate lower resolution. A single shadow map wastes resolution on distant geometry while providing insufficient detail nearby.</p>
<h2 id="cascaded-shadow-maps-csm"><a class="header" href="#cascaded-shadow-maps-csm">Cascaded Shadow Maps (CSM)</a></h2>
<p>CSM solves this by splitting the camera's view frustum into multiple depth ranges (cascades), each with its own shadow map. Near cascades cover a small area at high texel density. Far cascades cover a large area at lower density.</p>
<p>The <code>ShadowDepthPass</code> renders 4 shadow cascades (<code>NUM_SHADOW_CASCADES = 4</code>) into a single large depth texture:</p>
<ul>
<li><strong>Cascade 0</strong> - Near range, highest detail (covers roughly 0-10% of the view distance)</li>
<li><strong>Cascade 1</strong> - Mid-near range (covers roughly 10-30%)</li>
<li><strong>Cascade 2</strong> - Mid-far range (covers roughly 30-60%)</li>
<li><strong>Cascade 3</strong> - Far range, lowest detail (covers roughly 60-100%)</li>
</ul>
<h3 id="shadow-map-resolution"><a class="header" href="#shadow-map-resolution">Shadow Map Resolution</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Resolution</th></tr></thead><tbody>
<tr><td>Native</td><td>8192 x 8192</td></tr>
<tr><td>WASM</td><td>4096 x 4096</td></tr>
</tbody></table>
</div>
<p>Each cascade uses a quarter of the texture (rendered into its own viewport region), giving each cascade an effective resolution of 4096x4096 on native.</p>
<h3 id="how-cascades-work"><a class="header" href="#how-cascades-work">How Cascades Work</a></h3>
<p>Each frame, the engine:</p>
<ol>
<li><strong>Frustum computation</strong> - Computes the camera's view frustum (the truncated pyramid defined by the near plane, far plane, and field of view)</li>
<li><strong>Frustum splitting</strong> - Divides the frustum into 4 depth ranges using a logarithmic-linear split scheme. Logarithmic splitting gives more resolution to nearby cascades, while linear splitting distributes more evenly. A blend between the two (typically 0.5-0.8 toward logarithmic) produces good results across most scenes.</li>
<li><strong>Tight projection fitting</strong> - For each cascade, computes the 8 corner points of that frustum slice, transforms them into light space, and builds a tight orthographic projection matrix that just encompasses those points. This minimizes wasted shadow map texels.</li>
<li><strong>Shadow rendering</strong> - Renders all shadow-casting meshes from the directional light's perspective into each cascade's viewport region of the shadow texture.</li>
</ol>
<p>During the mesh pass, each fragment determines which cascade to sample based on its distance from the camera. The shader selects the highest-resolution cascade that contains the fragment, projects it into that cascade's light-space coordinates, and performs the depth comparison.</p>
<h3 id="cascade-selection-and-blending"><a class="header" href="#cascade-selection-and-blending">Cascade Selection and Blending</a></h3>
<p>At cascade boundaries, shadows can exhibit visible seams where resolution changes abruptly. The fragment shader compares the fragment's view-space depth against cascade split distances to choose the appropriate cascade. Some implementations blend between adjacent cascades at boundaries for smooth transitions.</p>
<h2 id="spotlight-shadow-atlas"><a class="header" href="#spotlight-shadow-atlas">Spotlight Shadow Atlas</a></h2>
<p>Spotlights use a separate shadow atlas:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Atlas Size</th></tr></thead><tbody>
<tr><td>Native</td><td>4096 x 4096</td></tr>
<tr><td>WASM</td><td>1024 x 1024</td></tr>
</tbody></table>
</div>
<p>Each spotlight that has <code>cast_shadows: true</code> is assigned a slot in the atlas. The atlas is subdivided to accommodate multiple spotlights.</p>
<h2 id="enabling-shadows"><a class="header" href="#enabling-shadows">Enabling Shadows</a></h2>
<h3 id="directional-light-shadows"><a class="header" href="#directional-light-shadows">Directional Light Shadows</a></h3>
<p><code>spawn_sun()</code> creates a directional light with shadows enabled by default:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sun = spawn_sun(world);
<span class="boring">}</span></code></pre></pre>
<p>To manually configure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_light(entity, Light {
    light_type: LightType::Directional,
    cast_shadows: true,
    shadow_bias: 0.005,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="spotlight-shadows"><a class="header" href="#spotlight-shadows">Spotlight Shadows</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_light(entity, Light {
    light_type: LightType::Spot,
    cast_shadows: true,
    shadow_bias: 0.002,
    inner_cone_angle: 0.2,
    outer_cone_angle: 0.5,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="per-mesh-shadow-casting"><a class="header" href="#per-mesh-shadow-casting">Per-Mesh Shadow Casting</a></h3>
<p>Control which meshes cast shadows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_casts_shadow(entity, CastsShadow(true));
world.set_casts_shadow(entity, CastsShadow(false));
<span class="boring">}</span></code></pre></pre>
<h2 id="shadow-quality"><a class="header" href="#shadow-quality">Shadow Quality</a></h2>
<h3 id="shadow-bias"><a class="header" href="#shadow-bias">Shadow Bias</a></h3>
<p>Shadow acne occurs because the shadow map has limited resolution. A surface that should be lit samples the shadow map at a slightly different position than where it was rendered, and floating-point imprecision causes the surface to falsely report itself as in shadow. This creates a Moiré-like pattern of alternating lit and shadowed stripes on surfaces.</p>
<p>Shadow bias adds a small depth offset during the shadow comparison, pushing the comparison point slightly toward the light so surfaces don't self-shadow. The trade-off is that too much bias causes <strong>peter-panning</strong>: shadows detach from the base of objects because the bias pushes them too far away.</p>
<p><code>shadow_bias</code> controls this offset:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>light.shadow_bias = 0.005;  // Good default for directional lights
light.shadow_bias = 0.002;  // Good default for spotlights
<span class="boring">}</span></code></pre></pre>
<p>Spotlights need less bias because their shadow maps cover a smaller area with higher effective resolution.</p>
<h3 id="cascade-settings"><a class="header" href="#cascade-settings">Cascade Settings</a></h3>
<p>Shadow cascades are configured at the renderer level. The engine uses 4 cascades (<code>NUM_SHADOW_CASCADES = 4</code>) with the shadow map resolution set at initialization (8192 native, 4096 WASM). These are not runtime-configurable through <code>Graphics</code> resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-passes"><a class="header" href="#geometry-passes">Geometry Passes</a></h1>
<p>Geometry passes render scene objects into the HDR color buffer and depth buffer. Each pass handles a different type of geometry.</p>
<h2 id="clearpass-1"><a class="header" href="#clearpass-1">ClearPass</a></h2>
<p>Clears <code>scene_color</code> to black and <code>depth</code> to 0.0 (reversed-Z far plane). Always runs first.</p>
<p><strong>Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="skypass-1"><a class="header" href="#skypass-1">SkyPass</a></h2>
<p>Renders the sky/atmosphere background. Controlled by <code>world.resources.graphics.atmosphere</code>:</p>
<ul>
<li><code>Atmosphere::None</code> - Solid background color (default)</li>
<li><code>Atmosphere::Sky</code> - Procedural clear sky gradient</li>
<li><code>Atmosphere::CloudySky</code> - Procedural sky with volumetric clouds</li>
<li><code>Atmosphere::Space</code> - Procedural starfield</li>
<li><code>Atmosphere::Nebula</code> - Procedural nebula with stars</li>
<li><code>Atmosphere::Sunset</code> - Procedural sunset gradient</li>
<li><code>Atmosphere::DayNight</code> - Procedural day/night cycle driven by hour parameter</li>
<li><code>Atmosphere::Hdr</code> - HDR environment cubemap</li>
</ul>
<p><strong>Writes:</strong> <code>scene_color</code></p>
<h2 id="scenepass-1"><a class="header" href="#scenepass-1">ScenePass</a></h2>
<p>Basic scene rendering pass for simple objects.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="meshpass-1"><a class="header" href="#meshpass-1">MeshPass</a></h2>
<p>The main PBR mesh rendering pass. Renders all entities with <code>RENDER_MESH | MATERIAL_REF | GLOBAL_TRANSFORM</code>. Features:</p>
<ul>
<li><strong>PBR shading</strong> with metallic-roughness workflow</li>
<li><strong>Cascaded shadow mapping</strong> - Samples the shadow depth texture</li>
<li><strong>Spotlight shadows</strong> - Samples the spotlight shadow atlas</li>
<li><strong>Normal mapping</strong> - Per-pixel normals from normal textures</li>
<li><strong>Alpha modes</strong> - Opaque, mask (alpha cutoff), and blend</li>
<li><strong>Entity ID output</strong> - Writes entity IDs for GPU picking</li>
<li><strong>View normals output</strong> - Writes view-space normals for SSAO/SSGI</li>
</ul>
<p><strong>Reads:</strong> <code>shadow_depth</code>, <code>spotlight_shadow_atlas</code>
<strong>Writes:</strong> <code>scene_color</code>, <code>depth</code>, <code>entity_id</code>, <code>view_normals</code></p>
<h2 id="skinnedmeshpass-1"><a class="header" href="#skinnedmeshpass-1">SkinnedMeshPass</a></h2>
<p>Renders animated skeletal meshes. Reads bone matrices from the skinning buffer and transforms vertices on the GPU.</p>
<p><strong>Reads:</strong> <code>shadow_depth</code>, <code>spotlight_shadow_atlas</code>
<strong>Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="waterpass"><a class="header" href="#waterpass">WaterPass</a></h2>
<p>Renders water surfaces with procedural wave displacement, reflections, and refractions.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="watermeshpass"><a class="header" href="#watermeshpass">WaterMeshPass</a></h2>
<p>Renders water mesh geometry with tessellation and displacement.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="grasspass"><a class="header" href="#grasspass">GrassPass</a></h2>
<p>GPU-instanced grass rendering. Renders thousands of grass blades using instance data from <code>GrassRegion</code> components. Supports wind animation and interactive bending via <code>GrassInteractor</code> components.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="decalpass"><a class="header" href="#decalpass">DecalPass</a></h2>
<p>Renders projected decals onto scene geometry. Decals sample the depth buffer to project textures onto surfaces.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="particlepass"><a class="header" href="#particlepass">ParticlePass</a></h2>
<p>GPU billboard particle rendering. Reads <code>ParticleEmitter</code> component data and renders camera-facing quads.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="textpass"><a class="header" href="#textpass">TextPass</a></h2>
<p>Renders 3D world-space text using the font atlas.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="hudpass"><a class="header" href="#hudpass">HudPass</a></h2>
<p>Renders screen-space HUD text. Unlike <code>TextPass</code>, HUD text is rendered in screen coordinates with configurable anchoring.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="linespass"><a class="header" href="#linespass">LinesPass</a></h2>
<p>Renders debug lines from <code>Lines</code> components. Useful for visualization, bounding boxes, and debugging.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="gridpass"><a class="header" href="#gridpass">GridPass</a></h2>
<p>Renders an infinite ground grid. Controlled by <code>world.resources.graphics.show_grid</code>.</p>
<p><strong>Reads/Writes:</strong> <code>scene_color</code>, <code>depth</code></p>
<h2 id="uirectpass"><a class="header" href="#uirectpass">UiRectPass</a></h2>
<p>Renders UI rectangles for the immediate-mode UI system.</p>
<h2 id="selectionmaskpass"><a class="header" href="#selectionmaskpass">SelectionMaskPass</a></h2>
<p>Generates a selection mask texture for selected entities. Used by the editor for selection outlines.</p>
<p><strong>Reads:</strong> <code>depth</code>
<strong>Writes:</strong> <code>selection_mask</code></p>
<h2 id="outlinepass"><a class="header" href="#outlinepass">OutlinePass</a></h2>
<p>Reads the selection mask and renders outlines around selected entities by detecting edges in the mask.</p>
<p><strong>Reads:</strong> <code>selection_mask</code>
<strong>Writes:</strong> <code>scene_color</code></p>
<h2 id="sdf-passes-feature-sdf_sculpt"><a class="header" href="#sdf-passes-feature-sdf_sculpt">SDF Passes (feature: sdf_sculpt)</a></h2>
<h3 id="sdfcomputepass"><a class="header" href="#sdfcomputepass">SdfComputePass</a></h3>
<p>Computes SDF brick maps on the GPU.</p>
<h3 id="sdfpass"><a class="header" href="#sdfpass">SdfPass</a></h3>
<p>Raymarches signed distance fields for real-time sculpting visualization.</p>
<h2 id="interiormappingpass"><a class="header" href="#interiormappingpass">InteriorMappingPass</a></h2>
<p>Renders interior mapping (parallax cubemap) for building windows.</p>
<h2 id="projectionpass--hizpass"><a class="header" href="#projectionpass--hizpass">ProjectionPass / HiZPass</a></h2>
<p>Hierarchical-Z buffer generation for occlusion culling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="post-processing"><a class="header" href="#post-processing">Post-Processing</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/bloom">Bloom</a> | <a href="https://matthewberger.dev/nightshade/ssao">SSAO</a> | <a href="https://matthewberger.dev/nightshade/depth_of_field">Depth of Field</a></p>
</blockquote>
<p>Post-processing passes read the HDR scene color, depth, and normals to produce the final image. These passes are added in <code>configure_render_graph()</code>.</p>
<h2 id="available-passes"><a class="header" href="#available-passes">Available Passes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pass</th><th>Description</th><th>Reads</th><th>Writes</th></tr></thead><tbody>
<tr><td><code>SsaoPass</code></td><td>Screen-space ambient occlusion</td><td>depth, normals</td><td>ssao_raw</td></tr>
<tr><td><code>SsaoBlurPass</code></td><td>Bilateral blur for SSAO</td><td>ssao_raw</td><td>ssao</td></tr>
<tr><td><code>SsgiPass</code></td><td>Screen-space global illumination (half-res)</td><td>scene_color, depth, normals</td><td>ssgi_raw</td></tr>
<tr><td><code>SsgiBlurPass</code></td><td>Bilateral blur for SSGI</td><td>ssgi_raw</td><td>ssgi</td></tr>
<tr><td><code>SsrPass</code></td><td>Screen-space reflections</td><td>scene_color, depth, normals</td><td>ssr_raw</td></tr>
<tr><td><code>SsrBlurPass</code></td><td>Blur for SSR</td><td>ssr_raw</td><td>ssr</td></tr>
<tr><td><code>BloomPass</code></td><td>HDR bloom with mip chain</td><td>scene_color</td><td>bloom</td></tr>
<tr><td><code>DepthOfFieldPass</code></td><td>Bokeh depth of field</td><td>scene_color, depth</td><td>scene_color</td></tr>
<tr><td><code>PostProcessPass</code></td><td>Final tonemapping and compositing</td><td>scene_color, bloom, ssao</td><td>output</td></tr>
<tr><td><code>EffectsPass</code></td><td>Custom shader effects</td><td>scene_color</td><td>scene_color</td></tr>
<tr><td><code>OutlinePass</code></td><td>Selection outline</td><td>selection_mask</td><td>scene_color</td></tr>
<tr><td><code>BlitPass</code></td><td>Simple texture copy</td><td>input</td><td>output</td></tr>
<tr><td><code>ComputeGrayscalePass</code></td><td>Grayscale conversion</td><td>input</td><td>output</td></tr>
</tbody></table>
</div>
<h2 id="enabling-effects"><a class="header" href="#enabling-effects">Enabling Effects</a></h2>
<p>Control post-processing through <code>world.resources.graphics</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.bloom_enabled = true;
    world.resources.graphics.bloom_intensity = 0.3;

    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.ssao_radius = 0.5;
    world.resources.graphics.ssao_intensity = 1.0;

    world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ssao-screen-space-ambient-occlusion"><a class="header" href="#ssao-screen-space-ambient-occlusion">SSAO (Screen-Space Ambient Occlusion)</a></h2>
<p>In the real world, corners, crevices, and enclosed spaces receive less ambient light because surrounding geometry occludes incoming light from many directions. SSAO approximates this effect in screen space by analyzing the depth buffer.</p>
<h3 id="how-ssao-works"><a class="header" href="#how-ssao-works">How SSAO Works</a></h3>
<p>For each pixel, the shader reconstructs the 3D position from the depth buffer, then samples several random points in a hemisphere oriented along the surface normal. Each sample point is projected back into screen space to check the depth buffer: if the stored depth is closer than the sample point, that direction is occluded. The ratio of occluded samples to total samples gives the occlusion factor.</p>
<p>The key inputs are:</p>
<ul>
<li><strong>Depth buffer</strong> - Provides the 3D position of each pixel</li>
<li><strong>View-space normals</strong> - Orients the sampling hemisphere along the surface</li>
<li><strong>Random noise</strong> - Rotates the sample kernel per-pixel to avoid banding patterns</li>
</ul>
<p>The raw SSAO output is noisy because of the limited sample count (typically 16-64 samples per pixel). A bilateral blur pass smooths the result while preserving edges (it avoids blurring across depth discontinuities, which would cause halos around objects).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.ssao_enabled = true;
world.resources.graphics.ssao_radius = 0.5;
world.resources.graphics.ssao_intensity = 1.0;
world.resources.graphics.ssao_bias = 0.025;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>ssao_radius</code> - The hemisphere radius in world units. Larger values detect occlusion from farther geometry but can cause over-darkening.</li>
<li><code>ssao_bias</code> - A small depth offset to prevent self-occlusion artifacts on flat surfaces.</li>
<li><code>ssao_intensity</code> - Multiplier for the final occlusion factor.</li>
</ul>
<h2 id="ssgi-screen-space-global-illumination"><a class="header" href="#ssgi-screen-space-global-illumination">SSGI (Screen-Space Global Illumination)</a></h2>
<p>In real-world lighting, light bounces between surfaces. A red wall next to a white floor tints the floor red. Traditional rasterization only computes direct lighting (light source to surface to camera). Global illumination (GI) adds these indirect bounces.</p>
<p>SSGI approximates one bounce of indirect light using only screen-space information. For each pixel, the shader traces short rays through the depth buffer to find nearby surfaces, then samples the color at those hit points as incoming indirect light. This is conceptually similar to SSAO but samples color instead of just occlusion.</p>
<p>SSGI is computed at half resolution for performance (the indirect illumination is low-frequency and doesn't need full resolution), then bilaterally blurred and upsampled.</p>
<h2 id="ssr-screen-space-reflections"><a class="header" href="#ssr-screen-space-reflections">SSR (Screen-Space Reflections)</a></h2>
<p>SSR adds dynamic reflections by ray-marching through the depth buffer. For each reflective pixel, the shader computes the reflection vector from the camera direction and the surface normal, then steps along that vector in screen space, checking the depth buffer at each step. When the ray intersects a surface (the ray's depth exceeds the depth buffer value), the color at that screen position becomes the reflection.</p>
<p>This technique works well for reflections of on-screen geometry but has inherent limitations: off-screen objects cannot be reflected, and reflections at grazing angles stretch across large screen areas. The blur pass hides artifacts from these limitations, and a fallback to environment maps or IBL fills in where SSR has no data.</p>
<h2 id="bloom"><a class="header" href="#bloom">Bloom</a></h2>
<p>Bloom simulates the light scattering that occurs in real cameras and the human eye when bright light sources bleed into surrounding areas. In HDR rendering, pixels can have values above 1.0 (the displayable range). Bloom extracts these bright pixels and spreads their light outward.</p>
<h3 id="how-bloom-works"><a class="header" href="#how-bloom-works">How Bloom Works</a></h3>
<p>The bloom pipeline uses a progressive downsample/upsample approach (similar to the technique described in the Call of Duty: Advanced Warfare presentation):</p>
<ol>
<li><strong>Threshold</strong> - Extract pixels brighter than a threshold from the HDR scene color</li>
<li><strong>Downsample chain</strong> - Progressively halve the resolution through multiple mip levels (e.g., 1920x1080 -&gt; 960x540 -&gt; 480x270 -&gt; ...), applying a blur at each step. This is much cheaper than blurring at full resolution because each mip level has 1/4 the pixels.</li>
<li><strong>Upsample chain</strong> - Walk back up the mip chain, additively blending each level with the one above it. This produces a smooth, wide blur that spans many pixels without requiring a massive blur kernel.</li>
<li><strong>Composite</strong> - Add the bloom result to the scene color during the final post-process pass.</li>
</ol>
<p>The mip-chain approach produces natural-looking bloom because it captures both tight glow (from the high-resolution mips) and wide glow (from the low-resolution mips) simultaneously.</p>
<p>Bloom creates a glow effect around bright pixels using this mip-chain downsample/upsample approach:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.bloom_enabled = true;
world.resources.graphics.bloom_intensity = 0.5;
<span class="boring">}</span></code></pre></pre>
<p>Materials with high emissive values produce the strongest bloom:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glowing = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [2.0, 8.0, 10.0],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="depth-of-field"><a class="header" href="#depth-of-field">Depth of Field</a></h2>
<p>Depth of field simulates the optical behavior of a physical camera lens. A real lens can only focus at one distance; objects nearer or farther than the focal plane appear blurred. The amount of blur (the circle of confusion, or CoC) increases with distance from the focal plane and is controlled by the aperture size.</p>
<h3 id="how-dof-works"><a class="header" href="#how-dof-works">How DoF Works</a></h3>
<ol>
<li><strong>CoC computation</strong> - For each pixel, compute the circle of confusion from the depth buffer value, the focus distance, and the aperture. The CoC is the diameter (in pixels) of the blur disc for that pixel.</li>
<li><strong>Blur</strong> - Apply a variable-radius blur where the kernel size is proportional to the CoC. Pixels with large CoC values (far from focus) get blurred heavily; pixels near the focal plane remain sharp.</li>
<li><strong>Bokeh</strong> - Bright out-of-focus highlights form characteristic shapes (circles, hexagons) called bokeh. The shader can emphasize bright pixels during the blur to simulate this optical effect.</li>
</ol>
<p>Focus blur based on distance from a focus plane:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.depth_of_field.enabled = true;
world.resources.graphics.depth_of_field.focus_distance = 10.0;
world.resources.graphics.depth_of_field.focus_range = 5.0;
world.resources.graphics.depth_of_field.max_blur_radius = 10.0;
world.resources.graphics.depth_of_field.bokeh_threshold = 1.0;
world.resources.graphics.depth_of_field.bokeh_intensity = 1.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>HDR rendering computes lighting in a physically linear color space where values can range from 0 to thousands. But displays can only show values between 0 and 1. Tonemapping is the process of compressing the HDR range into the displayable LDR range while preserving the perception of brightness differences and color relationships.</p>
<p>Different tonemapping curves make different trade-offs:</p>
<ul>
<li><strong>Reinhard</strong> - Simple <code>color / (color + 1)</code> mapping. Preserves highlights but can look washed out.</li>
<li><strong>ACES</strong> (Academy Color Encoding System) - Film-industry standard curve with good contrast and a slight warm tint. Widely used in games.</li>
<li><strong>AgX</strong> - A more recent curve designed to handle highly saturated colors better than ACES (which can produce hue shifts in bright saturated regions).</li>
<li><strong>Neutral</strong> - Minimal color manipulation, useful when color grading is handled externally.</li>
</ul>
<p>The <code>PostProcessPass</code> performs HDR-to-LDR tonemapping:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TonemapAlgorithm {
    Reinhard,
    Aces,
    ReinhardExtended,
    Uncharted2,
    AgX,
    Neutral,
    None,
}

world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.color_grading.saturation = 1.0;
world.resources.graphics.color_grading.contrast = 1.0;
world.resources.graphics.color_grading.brightness = 0.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="effects-pass"><a class="header" href="#effects-pass">Effects Pass</a></h2>
<p>The <code>EffectsPass</code> runs custom WGSL shader effects for specialized visual treatments:</p>
<ul>
<li>Color grading presets</li>
<li>Chromatic aberration</li>
<li>Film grain</li>
<li>Custom shader effects</li>
</ul>
<p>See <a href="effects-pass.html">Effects Pass</a> for details.</p>
<h2 id="custom-post-processing"><a class="header" href="#custom-post-processing">Custom Post-Processing</a></h2>
<p>Add custom post-processing passes via the render graph. See <a href="render-graph-custom.html">Custom Passes</a> for implementation examples.</p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Effect</th><th>Cost</th><th>Notes</th></tr></thead><tbody>
<tr><td>Bloom</td><td>Medium</td><td>Multiple blur passes at half resolution</td></tr>
<tr><td>SSAO</td><td>High</td><td>Many depth samples per pixel</td></tr>
<tr><td>SSGI</td><td>High</td><td>Half resolution helps, but still expensive</td></tr>
<tr><td>SSR</td><td>High</td><td>Ray tracing through depth buffer</td></tr>
<tr><td>DoF</td><td>Medium</td><td>Gaussian blur</td></tr>
<tr><td>Tonemapping</td><td>Low</td><td>Per-pixel math</td></tr>
<tr><td>Color Grading</td><td>Low</td><td>Per-pixel math</td></tr>
</tbody></table>
</div>
<p>Disable expensive effects for better performance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_quality_low(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = false;
    world.resources.graphics.bloom_enabled = false;
}

fn set_quality_high(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.bloom_enabled = true;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cameras"><a class="header" href="#cameras">Cameras</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/skybox">Skybox</a></p>
</blockquote>
<p>Cameras define the viewpoint and projection used to render the scene. Nightshade uses reversed-Z depth buffers for both perspective and orthographic projections, and supports infinite far planes, input smoothing, and arc-ball orbit controllers.</p>
<h2 id="camera-component"><a class="header" href="#camera-component">Camera Component</a></h2>
<p>A camera entity needs a transform and the <code>CAMERA</code> component:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA,
    1
)[0];
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Camera {
    pub projection: Projection,
    pub smoothing: Option&lt;Smoothing&gt;,
}

pub enum Projection {
    Perspective(PerspectiveCamera),
    Orthographic(OrthographicCamera),
}
<span class="boring">}</span></code></pre></pre>
<p>The default <code>Camera</code> uses a perspective projection (45 degree FOV, infinite far plane, 0.01 near plane) with smoothing enabled.</p>
<h2 id="spawning-cameras"><a class="header" href="#spawning-cameras">Spawning Cameras</a></h2>
<h3 id="basic-camera"><a class="header" href="#basic-camera">Basic Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = spawn_camera(
    world,
    Vec3::new(0.0, 5.0, 10.0),
    "Main Camera".to_string(),
);
world.resources.active_camera = Some(camera);
<span class="boring">}</span></code></pre></pre>
<h3 id="pan-orbit-camera"><a class="header" href="#pan-orbit-camera">Pan-Orbit Camera</a></h3>
<p>For editor-style arc-ball controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::camera::commands::spawn_pan_orbit_camera;

let camera = spawn_pan_orbit_camera(
    world,
    Vec3::new(0.0, 2.0, 0.0),  // focus point
    10.0,                       // radius (distance)
    0.5,                        // yaw (horizontal angle)
    0.4,                        // pitch (vertical angle)
    "Orbit Camera".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="perspective-projection"><a class="header" href="#perspective-projection">Perspective Projection</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PerspectiveCamera {
    pub aspect_ratio: Option&lt;f32&gt;,
    pub y_fov_rad: f32,
    pub z_far: Option&lt;f32&gt;,
    pub z_near: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>aspect_ratio</code></td><td><code>None</code></td><td>Width/height ratio. <code>None</code> uses the viewport aspect ratio</td></tr>
<tr><td><code>y_fov_rad</code></td><td><code>0.7854</code> (45 deg)</td><td>Vertical field of view in radians</td></tr>
<tr><td><code>z_far</code></td><td><code>None</code></td><td>Far plane distance. <code>None</code> uses an infinite far plane</td></tr>
<tr><td><code>z_near</code></td><td><code>0.01</code></td><td>Near plane distance</td></tr>
</tbody></table>
</div>
<h3 id="reversed-z-projection"><a class="header" href="#reversed-z-projection">Reversed-Z Projection</a></h3>
<p>Nightshade uses reversed-Z depth buffers where the near plane maps to depth 1.0 and the far plane maps to 0.0. This distributes floating-point precision more evenly across the depth range, dramatically reducing z-fighting artifacts at large distances.</p>
<p>With an infinite far plane (<code>z_far: None</code>), the projection matrix is:</p>
<pre><code>f = 1 / tan(fov / 2)

| f/aspect  0     0      0     |
| 0         f     0      0     |
| 0         0     0      z_near|
| 0         0    -1      0     |
</code></pre>
<p>With a finite far plane, the matrix maps <code>[z_near, z_far]</code> to <code>[1.0, 0.0]</code>:</p>
<pre><code>| f/aspect  0     0                          0                           |
| 0         f     0                          0                           |
| 0         0     z_near/(z_far - z_near)    z_near*z_far/(z_far-z_near) |
| 0         0    -1                          0                           |
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_camera(camera, Camera {
    projection: Projection::Perspective(PerspectiveCamera {
        y_fov_rad: 1.0,
        aspect_ratio: None,
        z_near: 0.1,
        z_far: Some(1000.0),
    }),
    smoothing: None,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="orthographic-projection"><a class="header" href="#orthographic-projection">Orthographic Projection</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OrthographicCamera {
    pub x_mag: f32,
    pub y_mag: f32,
    pub z_far: f32,
    pub z_near: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>x_mag</code></td><td><code>10.0</code></td><td>Half-width of the view volume (horizontal extent is ±x_mag)</td></tr>
<tr><td><code>y_mag</code></td><td><code>10.0</code></td><td>Half-height of the view volume (vertical extent is ±y_mag)</td></tr>
<tr><td><code>z_far</code></td><td><code>1000.0</code></td><td>Far clipping plane distance</td></tr>
<tr><td><code>z_near</code></td><td><code>0.01</code></td><td>Near clipping plane distance</td></tr>
</tbody></table>
</div>
<p>The orthographic projection also uses reversed-Z, mapping <code>[z_near, z_far]</code> to <code>[1.0, 0.0]</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_camera(camera, Camera {
    projection: Projection::Orthographic(OrthographicCamera {
        x_mag: 10.0,
        y_mag: 10.0,
        z_near: 0.1,
        z_far: 100.0,
    }),
    smoothing: None,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-systems"><a class="header" href="#camera-systems">Camera Systems</a></h2>
<h3 id="fly-camera"><a class="header" href="#fly-camera">Fly Camera</a></h3>
<p>Free-flying FPS-style camera with WASD movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    fly_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pan-orbit-camera-1"><a class="header" href="#pan-orbit-camera-1">Pan-Orbit Camera</a></h3>
<p>Arc-ball camera that orbits around a focus point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::camera::systems::pan_orbit_camera_system;

fn run_systems(&amp;mut self, world: &amp;mut World) {
    pan_orbit_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="orthographic-camera"><a class="header" href="#orthographic-camera">Orthographic Camera</a></h3>
<p>For 2D or isometric views:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::camera::systems::ortho_camera_system;

fn run_systems(&amp;mut self, world: &amp;mut World) {
    ortho_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-smoothing"><a class="header" href="#input-smoothing">Input Smoothing</a></h2>
<p>The <code>Smoothing</code> component applies frame-rate-independent exponential smoothing to all camera input. The smoothing factor is computed as:</p>
<pre><code>smoothing_factor = 1.0 - smoothness^7 ^ delta_time
</code></pre>
<p>Where <code>smoothness</code> is the per-device smoothness parameter. A smoothness of 0 gives instant response; values approaching 1 make the input increasingly sluggish. The <code>powi(7)</code> exponent makes the smoothness parameter feel linear to adjust.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Smoothing {
    pub mouse_sensitivity: f32,
    pub mouse_smoothness: f32,
    pub mouse_dpi_scale: f32,
    pub keyboard_smoothness: f32,
    pub gamepad_sensitivity: f32,
    pub gamepad_smoothness: f32,
    pub gamepad_deadzone: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mouse_sensitivity</code></td><td><code>0.5</code></td><td>Mouse look speed multiplier</td></tr>
<tr><td><code>mouse_smoothness</code></td><td><code>0.05</code></td><td>Mouse input smoothing (0 = instant, 1 = no change)</td></tr>
<tr><td><code>mouse_dpi_scale</code></td><td><code>1.0</code></td><td>DPI scaling factor for mouse input</td></tr>
<tr><td><code>keyboard_smoothness</code></td><td><code>0.08</code></td><td>Keyboard movement smoothing</td></tr>
<tr><td><code>gamepad_sensitivity</code></td><td><code>1.5</code></td><td>Gamepad stick look speed</td></tr>
<tr><td><code>gamepad_smoothness</code></td><td><code>0.06</code></td><td>Gamepad input smoothing</td></tr>
<tr><td><code>gamepad_deadzone</code></td><td><code>0.15</code></td><td>Gamepad stick deadzone threshold</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_camera(camera, Camera {
    projection: Projection::Perspective(PerspectiveCamera::default()),
    smoothing: Some(Smoothing {
        mouse_sensitivity: 0.5,
        mouse_smoothness: 0.05,
        keyboard_smoothness: 0.08,
        ..Smoothing::default()
    }),
});
<span class="boring">}</span></code></pre></pre>
<h2 id="pan-orbit-camera-configuration"><a class="header" href="#pan-orbit-camera-configuration">Pan-Orbit Camera Configuration</a></h2>
<p>The <code>PanOrbitCamera</code> component provides a fully configurable arc-ball camera with Blender-style controls by default.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PanOrbitCamera {
    pub focus: Vec3,
    pub radius: f32,
    pub yaw: f32,
    pub pitch: f32,
    pub target_focus: Vec3,
    pub target_radius: f32,
    pub target_yaw: f32,
    pub target_pitch: f32,
    pub enabled: bool,
    // ... configuration fields
}
<span class="boring">}</span></code></pre></pre>
<h3 id="default-controls"><a class="header" href="#default-controls">Default Controls</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Mouse</th><th>Gamepad</th><th>Touch</th></tr></thead><tbody>
<tr><td>Orbit</td><td>Middle button</td><td>Right stick</td><td>Single finger drag</td></tr>
<tr><td>Pan</td><td>Shift + Middle button</td><td>Left stick</td><td>Two finger drag</td></tr>
<tr><td>Zoom (drag)</td><td>Ctrl + Middle button</td><td>Triggers</td><td>Pinch</td></tr>
<tr><td>Zoom (step)</td><td>Scroll wheel</td><td>—</td><td>—</td></tr>
</tbody></table>
</div>
<h3 id="builder-api"><a class="header" href="#builder-api">Builder API</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pan_orbit = PanOrbitCamera::new(focus, 10.0)
    .with_yaw_pitch(0.5, 0.4)
    .with_zoom_limits(1.0, Some(100.0))
    .with_pitch_limits(-1.5, 1.5)
    .with_smoothness(0.1, 0.02, 0.1)
    .with_buttons(PanOrbitButton::Middle, PanOrbitButton::Middle)
    .with_modifiers(None, Some(PanOrbitModifier::Shift))
    .with_upside_down(false);
<span class="boring">}</span></code></pre></pre>
<h3 id="sensitivity-and-smoothness"><a class="header" href="#sensitivity-and-smoothness">Sensitivity and Smoothness</a></h3>
<p>Each action has independent sensitivity and smoothness parameters:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>orbit_sensitivity</code></td><td><code>1.0</code></td><td>Mouse orbit speed</td></tr>
<tr><td><code>pan_sensitivity</code></td><td><code>1.0</code></td><td>Mouse pan speed</td></tr>
<tr><td><code>zoom_sensitivity</code></td><td><code>1.0</code></td><td>Scroll zoom speed</td></tr>
<tr><td><code>orbit_smoothness</code></td><td><code>0.1</code></td><td>Orbit interpolation smoothness</td></tr>
<tr><td><code>pan_smoothness</code></td><td><code>0.02</code></td><td>Pan interpolation smoothness</td></tr>
<tr><td><code>zoom_smoothness</code></td><td><code>0.1</code></td><td>Zoom interpolation smoothness</td></tr>
<tr><td><code>gamepad_orbit_sensitivity</code></td><td><code>2.0</code></td><td>Gamepad orbit speed</td></tr>
<tr><td><code>gamepad_pan_sensitivity</code></td><td><code>10.0</code></td><td>Gamepad pan speed</td></tr>
<tr><td><code>gamepad_zoom_sensitivity</code></td><td><code>5.0</code></td><td>Gamepad zoom speed</td></tr>
<tr><td><code>gamepad_deadzone</code></td><td><code>0.15</code></td><td>Stick deadzone</td></tr>
<tr><td><code>gamepad_smoothness</code></td><td><code>0.06</code></td><td>Gamepad smoothing</td></tr>
</tbody></table>
</div>
<p>Target values (<code>target_yaw</code>, <code>target_pitch</code>, <code>target_focus</code>, <code>target_radius</code>) are set by user input, then the current values interpolate towards them using the smoothing formula. The system snaps to the target when the difference falls below 0.001.</p>
<h3 id="zoom-and-pitch-limits"><a class="header" href="#zoom-and-pitch-limits">Zoom and Pitch Limits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(pan_orbit) = world.get_pan_orbit_camera_mut(camera) {
    pan_orbit.zoom_lower_limit = 1.0;
    pan_orbit.zoom_upper_limit = Some(50.0);
    pan_orbit.pitch_upper_limit = std::f32::consts::FRAC_PI_2 - 0.01;
    pan_orbit.pitch_lower_limit = -(std::f32::consts::FRAC_PI_2 - 0.01);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="upside-down-handling"><a class="header" href="#upside-down-handling">Upside-Down Handling</a></h3>
<p>When <code>allow_upside_down</code> is <code>true</code>, the pitch can exceed ±90 degrees. When the camera goes upside down, the yaw direction is automatically reversed for intuitive mouse control.</p>
<h3 id="runtime-control"><a class="header" href="#runtime-control">Runtime Control</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(pan_orbit) = world.get_pan_orbit_camera_mut(camera) {
    pan_orbit.target_focus = Vec3::new(0.0, 2.0, 0.0);
    pan_orbit.target_radius = 5.0;
    pan_orbit.target_yaw += 0.1;
    pan_orbit.target_pitch += 0.05;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="computing-camera-transform"><a class="header" href="#computing-camera-transform">Computing Camera Transform</a></h3>
<p>The pan-orbit camera position is computed from yaw, pitch, and radius:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (position, rotation) = pan_orbit.compute_camera_transform();
<span class="boring">}</span></code></pre></pre>
<p>The camera is placed at <code>focus + rotate(yaw, pitch) * (0, 0, radius)</code> — the rotation is composed as yaw (around Y) then pitch (around X).</p>
<h2 id="screen-to-world-conversion"><a class="header" href="#screen-to-world-conversion">Screen-to-World Conversion</a></h2>
<p>Convert screen coordinates to a world-space ray:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::picking::PickingRay;

let screen_pos = world.resources.input.mouse.position;
if let Some(ray) = PickingRay::from_screen_position(world, screen_pos) {
    let origin = ray.origin;
    let direction = ray.direction;
}
<span class="boring">}</span></code></pre></pre>
<p>For perspective cameras, the ray origin is the camera position and the direction is computed by unprojecting through the inverse view-projection matrix. For orthographic cameras, the origin is the unprojected near-plane point and the direction is the camera's forward vector.</p>
<h2 id="multiple-cameras"><a class="header" href="#multiple-cameras">Multiple Cameras</a></h2>
<p>Switch between cameras:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: ElementState) {
    if state == ElementState::Pressed &amp;&amp; key == KeyCode::Tab {
        let current = world.resources.active_camera;
        world.resources.active_camera = if current == Some(self.main_camera) {
            Some(self.debug_camera)
        } else {
            Some(self.main_camera)
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/textures">Textures</a> | <a href="https://matthewberger.dev/nightshade/alpha_blending">Alpha Blending</a></p>
</blockquote>
<p>Materials define the visual appearance of meshes using PBR (Physically Based Rendering) following the glTF 2.0 metallic-roughness workflow. Nightshade supports the full glTF PBR model plus several extensions: KHR_materials_transmission, KHR_materials_volume, KHR_materials_specular, and KHR_materials_emissive_strength.</p>
<h2 id="material-structure"><a class="header" href="#material-structure">Material Structure</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Material {
    // Core PBR
    pub base_color: [f32; 4],
    pub roughness: f32,
    pub metallic: f32,
    pub emissive_factor: [f32; 3],
    pub emissive_strength: f32,
    pub alpha_mode: AlphaMode,
    pub alpha_cutoff: f32,
    pub unlit: bool,
    pub double_sided: bool,
    pub uv_scale: [f32; 2],

    // Textures
    pub base_texture: Option&lt;String&gt;,
    pub base_texture_uv_set: u32,
    pub emissive_texture: Option&lt;String&gt;,
    pub emissive_texture_uv_set: u32,
    pub normal_texture: Option&lt;String&gt;,
    pub normal_texture_uv_set: u32,
    pub normal_scale: f32,
    pub normal_map_flip_y: bool,
    pub normal_map_two_component: bool,
    pub metallic_roughness_texture: Option&lt;String&gt;,
    pub metallic_roughness_texture_uv_set: u32,
    pub occlusion_texture: Option&lt;String&gt;,
    pub occlusion_texture_uv_set: u32,
    pub occlusion_strength: f32,

    // Transmission (KHR_materials_transmission)
    pub transmission_factor: f32,
    pub transmission_texture: Option&lt;String&gt;,
    pub transmission_texture_uv_set: u32,

    // Volume (KHR_materials_volume)
    pub thickness: f32,
    pub thickness_texture: Option&lt;String&gt;,
    pub thickness_texture_uv_set: u32,
    pub attenuation_color: [f32; 3],
    pub attenuation_distance: f32,
    pub ior: f32,

    // Specular (KHR_materials_specular)
    pub specular_factor: f32,
    pub specular_color_factor: [f32; 3],
    pub specular_texture: Option&lt;String&gt;,
    pub specular_texture_uv_set: u32,
    pub specular_color_texture: Option&lt;String&gt;,
    pub specular_color_texture_uv_set: u32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="core-pbr-fields"><a class="header" href="#core-pbr-fields">Core PBR Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>base_color</code></td><td><code>[0.7, 0.7, 0.7, 1.0]</code></td><td>RGBA albedo color, multiplied with <code>base_texture</code></td></tr>
<tr><td><code>roughness</code></td><td><code>0.5</code></td><td>Surface roughness (0 = mirror, 1 = fully diffuse)</td></tr>
<tr><td><code>metallic</code></td><td><code>0.0</code></td><td>Metalness (0 = dielectric, 1 = conductor)</td></tr>
<tr><td><code>emissive_factor</code></td><td><code>[0.0, 0.0, 0.0]</code></td><td>RGB emissive color, multiplied with <code>emissive_texture</code></td></tr>
<tr><td><code>emissive_strength</code></td><td><code>1.0</code></td><td>HDR intensity multiplier for emissive output</td></tr>
<tr><td><code>alpha_mode</code></td><td><code>Opaque</code></td><td>Transparency handling mode</td></tr>
<tr><td><code>alpha_cutoff</code></td><td><code>0.5</code></td><td>Alpha threshold for <code>AlphaMode::Mask</code></td></tr>
<tr><td><code>unlit</code></td><td><code>false</code></td><td>Skip lighting calculations (flat shaded)</td></tr>
<tr><td><code>double_sided</code></td><td><code>false</code></td><td>Render both sides of faces</td></tr>
<tr><td><code>uv_scale</code></td><td><code>[1.0, 1.0]</code></td><td>UV coordinate scale multiplier</td></tr>
</tbody></table>
</div>
<h3 id="normal-map-options"><a class="header" href="#normal-map-options">Normal Map Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>normal_scale</code></td><td><code>1.0</code></td><td>Normal map intensity multiplier</td></tr>
<tr><td><code>normal_map_flip_y</code></td><td><code>false</code></td><td>Flip the Y (green) channel for DirectX-style normal maps</td></tr>
<tr><td><code>normal_map_two_component</code></td><td><code>false</code></td><td>Two-component normal map (RG only, B reconstructed)</td></tr>
<tr><td><code>occlusion_strength</code></td><td><code>1.0</code></td><td>Ambient occlusion effect strength (0 = none, 1 = full)</td></tr>
</tbody></table>
</div>
<h3 id="transmission-and-volume"><a class="header" href="#transmission-and-volume">Transmission and Volume</a></h3>
<p>These fields implement light transmission through surfaces (glass, water, thin-shell materials):</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>transmission_factor</code></td><td><code>0.0</code></td><td>Fraction of light transmitted through the surface (0 = opaque, 1 = fully transmissive)</td></tr>
<tr><td><code>thickness</code></td><td><code>0.0</code></td><td>Volume thickness for refraction (0 = thin-wall)</td></tr>
<tr><td><code>attenuation_color</code></td><td><code>[1.0, 1.0, 1.0]</code></td><td>Color of light absorbed inside the volume</td></tr>
<tr><td><code>attenuation_distance</code></td><td><code>0.0</code></td><td>Distance at which light is attenuated to <code>attenuation_color</code></td></tr>
<tr><td><code>ior</code></td><td><code>1.5</code></td><td>Index of refraction (1.0 = air, 1.33 = water, 1.5 = glass, 2.42 = diamond)</td></tr>
</tbody></table>
</div>
<h3 id="specular"><a class="header" href="#specular">Specular</a></h3>
<p>Overrides the default Fresnel reflectance for dielectric materials:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>specular_factor</code></td><td><code>1.0</code></td><td>Specular intensity override (0 = no specular, 1 = default F0)</td></tr>
<tr><td><code>specular_color_factor</code></td><td><code>[1.0, 1.0, 1.0]</code></td><td>Tints the specular reflection color</td></tr>
</tbody></table>
</div>
<h2 id="alpha-modes"><a class="header" href="#alpha-modes">Alpha Modes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AlphaMode {
    Opaque,  // Fully opaque, alpha ignored
    Mask,    // Binary transparency using alpha_cutoff
    Blend,   // Full alpha blending
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-materials"><a class="header" href="#creating-materials">Creating Materials</a></h2>
<h3 id="basic-colored-material"><a class="header" href="#basic-colored-material">Basic Colored Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red_material = Material {
    base_color: [1.0, 0.0, 0.0, 1.0],
    roughness: 0.5,
    metallic: 0.0,
    ..Default::default()
};

material_registry_insert(
    &amp;mut world.resources.material_registry,
    "red".to_string(),
    red_material,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="metallic-material"><a class="header" href="#metallic-material">Metallic Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let gold = Material {
    base_color: [1.0, 0.84, 0.0, 1.0],
    roughness: 0.3,
    metallic: 1.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="emissive-material"><a class="header" href="#emissive-material">Emissive Material</a></h3>
<p>The final emissive output is <code>emissive_factor * emissive_strength * emissive_texture</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let neon = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [0.2, 0.8, 1.0],
    emissive_strength: 10.0,
    roughness: 0.8,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="glass--transmissive-material"><a class="header" href="#glass--transmissive-material">Glass / Transmissive Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glass = Material {
    base_color: [0.95, 0.95, 1.0, 1.0],
    roughness: 0.05,
    metallic: 0.0,
    transmission_factor: 0.95,
    ior: 1.5,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="colored-glass-with-volume-absorption"><a class="header" href="#colored-glass-with-volume-absorption">Colored Glass with Volume Absorption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stained_glass = Material {
    base_color: [0.8, 0.2, 0.2, 1.0],
    roughness: 0.05,
    transmission_factor: 0.9,
    thickness: 0.02,
    attenuation_color: [0.8, 0.1, 0.1],
    attenuation_distance: 0.05,
    ior: 1.52,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="transparent-alpha-blended-material"><a class="header" href="#transparent-alpha-blended-material">Transparent (Alpha Blended) Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ghost = Material {
    base_color: [0.9, 0.95, 1.0, 0.3],
    alpha_mode: AlphaMode::Blend,
    roughness: 0.1,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="foliage-alpha-mask"><a class="header" href="#foliage-alpha-mask">Foliage (Alpha Mask)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foliage = Material {
    base_texture: Some("leaf_color".to_string()),
    alpha_mode: AlphaMode::Mask,
    alpha_cutoff: 0.5,
    double_sided: true,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="textured-materials"><a class="header" href="#textured-materials">Textured Materials</a></h2>
<h3 id="loading-textures"><a class="header" href="#loading-textures">Loading Textures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let texture_bytes = include_bytes!("../assets/wood.png");
let image = image::load_from_memory(texture_bytes).unwrap().to_rgba8();

world.queue_command(WorldCommand::LoadTexture {
    name: "wood".to_string(),
    rgba_data: image.to_vec(),
    width: image.width(),
    height: image.height(),
});
<span class="boring">}</span></code></pre></pre>
<h3 id="full-pbr-texture-set"><a class="header" href="#full-pbr-texture-set">Full PBR Texture Set</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let brick = Material {
    base_texture: Some("brick_color".to_string()),
    normal_texture: Some("brick_normal".to_string()),
    normal_scale: 1.0,
    metallic_roughness_texture: Some("brick_metallic_roughness".to_string()),
    occlusion_texture: Some("brick_ao".to_string()),
    roughness: 1.0,
    metallic: 1.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>When a <code>metallic_roughness_texture</code> is present, the <code>roughness</code> and <code>metallic</code> values are multiplied with the texture's green and blue channels respectively.</p>
<h3 id="uv-scaling"><a class="header" href="#uv-scaling">UV Scaling</a></h3>
<p>Tile a texture by scaling UV coordinates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tiled = Material {
    base_texture: Some("tile".to_string()),
    uv_scale: [4.0, 4.0],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="directx-normal-maps"><a class="header" href="#directx-normal-maps">DirectX Normal Maps</a></h3>
<p>Some normal maps (e.g., from Substance or older tools) use a flipped Y channel:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let material = Material {
    normal_texture: Some("dx_normal".to_string()),
    normal_map_flip_y: true,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>For two-component normal maps (RG only, B reconstructed from RG):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let material = Material {
    normal_texture: Some("bc5_normal".to_string()),
    normal_map_two_component: true,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="assigning-materials-to-entities"><a class="header" href="#assigning-materials-to-entities">Assigning Materials to Entities</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>material_registry_insert(
    &amp;mut world.resources.material_registry,
    "my_material".to_string(),
    my_material,
);

if let Some(&amp;index) = world.resources.material_registry.registry.name_to_index.get("my_material") {
    world.resources.material_registry.registry.add_reference(index);
}

world.set_material_ref(entity, MaterialRef::new("my_material"));
<span class="boring">}</span></code></pre></pre>
<h2 id="procedural-textures"><a class="header" href="#procedural-textures">Procedural Textures</a></h2>
<p>Generate textures at runtime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_checkerboard(size: usize) -&gt; Vec&lt;u8&gt; {
    let mut data = vec![0u8; size * size * 4];

    for y in 0..size {
        for x in 0..size {
            let index = (y * size + x) * 4;
            let checker = ((x / 32) + (y / 32)) % 2 == 0;
            let value = if checker { 255 } else { 64 };
            data[index] = value;
            data[index + 1] = value;
            data[index + 2] = value;
            data[index + 3] = 255;
        }
    }

    data
}

let checkerboard = create_checkerboard(256);
world.queue_command(WorldCommand::LoadTexture {
    name: "checkerboard".to_string(),
    rgba_data: checkerboard,
    width: 256,
    height: 256,
});
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshes--models"><a class="header" href="#meshes--models">Meshes &amp; Models</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/prefabs">Prefabs</a></p>
</blockquote>
<h2 id="built-in-primitives"><a class="header" href="#built-in-primitives">Built-in Primitives</a></h2>
<p>Nightshade provides basic geometric primitives:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

spawn_cube_at(world, Vec3::new(0.0, 1.0, 0.0));
spawn_sphere_at(world, Vec3::new(2.0, 1.0, 0.0));
spawn_plane_at(world, Vec3::zeros());
spawn_cylinder_at(world, Vec3::new(-2.0, 1.0, 0.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-gltfglb-models"><a class="header" href="#loading-gltfglb-models">Loading glTF/GLB Models</a></h2>
<h3 id="basic-loading"><a class="header" href="#basic-loading">Basic Loading</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

const MODEL_BYTES: &amp;[u8] = include_bytes!("../assets/character.glb");

fn load_model(world: &amp;mut World) -&gt; Option&lt;Entity&gt; {
    let result = import_gltf_from_bytes(MODEL_BYTES).ok()?;

    // Register textures
    for (name, (rgba_data, width, height)) in result.textures {
        world.queue_command(WorldCommand::LoadTexture {
            name,
            rgba_data,
            width,
            height,
        });
    }

    // Register meshes
    for (name, mesh) in result.meshes {
        mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
    }

    // Spawn first prefab
    result.prefabs.first().map(|prefab| {
        spawn_prefab_with_skins(
            world,
            prefab,
            &amp;result.animations,
            &amp;result.skins,
            Vec3::zeros(),
        )
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-custom-positiontransform"><a class="header" href="#with-custom-positiontransform">With Custom Position/Transform</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_model_at(world: &amp;mut World, prefab: &amp;Prefab, position: Vec3, scale: f32) -&gt; Entity {
    let entity = spawn_prefab(world, prefab, position);

    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.scale = Vec3::new(scale, scale, scale);
    }

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="filtered-animation-channels"><a class="header" href="#filtered-animation-channels">Filtered Animation Channels</a></h3>
<p>Remove root motion from animations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let root_bone_indices: HashSet&lt;usize&gt; = [0, 1, 2, 3].into();

let filtered_animations: Vec&lt;AnimationClip&gt; = result
    .animations
    .iter()
    .map(|clip| AnimationClip {
        name: clip.name.clone(),
        duration: clip.duration,
        channels: clip
            .channels
            .iter()
            .filter(|channel| {
                // Skip translation on all bones
                if channel.target_property == AnimationProperty::Translation {
                    return false;
                }
                // Skip rotation on root bones
                if root_bone_indices.contains(&amp;channel.target_node)
                    &amp;&amp; channel.target_property == AnimationProperty::Rotation
                {
                    return false;
                }
                true
            })
            .cloned()
            .collect(),
    })
    .collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="manual-mesh-creation"><a class="header" href="#manual-mesh-creation">Manual Mesh Creation</a></h2>
<p>Create meshes programmatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::mesh::*;

let vertices = vec![
    Vertex {
        position: [0.0, 0.0, 0.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [0.0, 0.0],
        ..Default::default()
    },
    Vertex {
        position: [1.0, 0.0, 0.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [1.0, 0.0],
        ..Default::default()
    },
    Vertex {
        position: [0.5, 0.0, 1.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [0.5, 1.0],
        ..Default::default()
    },
];

let indices = vec![0, 1, 2];

let mesh = Mesh {
    vertices,
    indices,
    ..Default::default()
};

mesh_cache_insert(&amp;mut world.resources.mesh_cache, "triangle".to_string(), mesh);
<span class="boring">}</span></code></pre></pre>
<h2 id="mesh-component"><a class="header" href="#mesh-component">Mesh Component</a></h2>
<p>Assign a mesh to an entity:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF,
    1
)[0];

world.set_render_mesh(entity, RenderMesh {
    name: "triangle".to_string(),
    id: None,
});

world.set_material_ref(entity, MaterialRef::new("default"));
<span class="boring">}</span></code></pre></pre>
<h2 id="instanced-meshes"><a class="header" href="#instanced-meshes">Instanced Meshes</a></h2>
<p>For rendering many copies of the same mesh efficiently:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_instanced_mesh(entity, InstancedMesh {
    mesh_name: "tree".to_string(),
    instance_count: 1000,
    instance_data: instance_transforms,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="mesh-cache"><a class="header" href="#mesh-cache">Mesh Cache</a></h2>
<p>Access the mesh cache:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if mesh exists
if world.resources.mesh_cache.contains("cube") {
    // Mesh is available
}

// Get mesh data (for physics, etc.)
if let Some(mesh) = world.resources.mesh_cache.get("terrain") {
    let vertices: Vec&lt;Vec3&gt; = mesh.vertices.iter()
        .map(|v| Vec3::new(v.position[0], v.position[1], v.position[2]))
        .collect();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="skinned-meshes"><a class="header" href="#skinned-meshes">Skinned Meshes</a></h2>
<p>For animated characters with skeletons:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = spawn_prefab_with_skins(
    world,
    &amp;prefab,
    &amp;animations,
    &amp;skins,
    position,
);

// The entity will have Skin and AnimationPlayer components
if let Some(player) = world.get_animation_player_mut(entity) {
    player.playing = true;
    player.looping = true;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shadow-casting"><a class="header" href="#shadow-casting">Shadow Casting</a></h2>
<p>Control whether a mesh casts shadows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable shadow casting
world.set_casts_shadow(entity, CastsShadow(true));

// Disable shadow casting (for UI elements, etc.)
world.set_casts_shadow(entity, CastsShadow(false));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighting-1"><a class="header" href="#lighting-1">Lighting</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/lights">Lights</a> | <a href="https://matthewberger.dev/nightshade/shadows">Shadows</a> | <a href="https://matthewberger.dev/nightshade/spotlight_shadows">Spotlight Shadows</a></p>
</blockquote>
<p>Nightshade supports three types of lights: directional, point, and spot lights.</p>
<h2 id="light-types"><a class="header" href="#light-types">Light Types</a></h2>
<h3 id="directional-light-sun"><a class="header" href="#directional-light-sun">Directional Light (Sun)</a></h3>
<p>Illuminates the entire scene from a direction, simulating distant light sources like the sun:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

let sun = spawn_sun(world);
<span class="boring">}</span></code></pre></pre>
<p><code>spawn_sun</code> returns the <code>Entity</code> for the directional light, which you can further configure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(light) = world.get_light_mut(sun) {
    light.color = Vec3::new(1.0, 0.98, 0.95);
    light.intensity = 2.0;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point Light</a></h3>
<p>Emits light in all directions from a point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_point_light(world: &amp;mut World, position: Vec3, color: Vec3, intensity: f32) -&gt; Entity {
    let entity = world.spawn_entities(
        LIGHT | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
        1
    )[0];

    world.set_light(entity, Light {
        light_type: LightType::Point,
        color,
        intensity,
        range: 10.0,
        cast_shadows: false,
        ..Default::default()
    });

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spot-light"><a class="header" href="#spot-light">Spot Light</a></h3>
<p>Cone-shaped light, perfect for flashlights or stage lighting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_spotlight(world: &amp;mut World, position: Vec3, direction: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LIGHT | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
        1
    )[0];

    world.set_light(entity, Light {
        light_type: LightType::Spot,
        color: Vec3::new(1.0, 0.95, 0.9),
        intensity: 15.0,
        range: 20.0,
        inner_cone_angle: 0.2,  // Full intensity cone
        outer_cone_angle: 0.5,  // Falloff cone
        cast_shadows: true,
        shadow_bias: 0.002,
    });

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation: nalgebra_glm::quat_look_at(&amp;direction.normalize(), &amp;Vec3::y()),
        ..Default::default()
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="light-properties"><a class="header" href="#light-properties">Light Properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>color</code></td><td>RGB color of the light</td></tr>
<tr><td><code>intensity</code></td><td>Brightness multiplier</td></tr>
<tr><td><code>range</code></td><td>Maximum distance for point/spot lights</td></tr>
<tr><td><code>cast_shadows</code></td><td>Whether this light creates shadows</td></tr>
<tr><td><code>shadow_bias</code></td><td>Offset to reduce shadow acne</td></tr>
<tr><td><code>inner_cone_angle</code></td><td>Spot light inner cone (full intensity)</td></tr>
<tr><td><code>outer_cone_angle</code></td><td>Spot light outer cone (falloff edge)</td></tr>
</tbody></table>
</div>
<h2 id="dynamic-lighting"><a class="header" href="#dynamic-lighting">Dynamic Lighting</a></h2>
<h3 id="flickering-light"><a class="header" href="#flickering-light">Flickering Light</a></h3>
<p>Create a flickering fire/torch effect:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_flickering_light(world: &amp;mut World, light_entity: Entity) {
    let time = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;

    if let Some(light) = world.get_light_mut(light_entity) {
        let flicker1 = (time * 8.0).sin() * 0.15;
        let flicker2 = (time * 12.5).sin() * 0.1;
        let flicker3 = (time * 23.0).sin() * 0.08;

        let base_intensity = 3.5;
        light.intensity = base_intensity + flicker1 + flicker2 + flicker3;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="color-cycling"><a class="header" href="#color-cycling">Color Cycling</a></h3>
<p>Animated color changes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_disco_light(world: &amp;mut World, light_entity: Entity) {
    let time = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;

    if let Some(light) = world.get_light_mut(light_entity) {
        light.color = Vec3::new(
            (time * 2.0).sin() * 0.5 + 0.5,
            (time * 2.0 + 2.094).sin() * 0.5 + 0.5,
            (time * 2.0 + 4.188).sin() * 0.5 + 0.5,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flashlight-camera-attached-spotlight"><a class="header" href="#flashlight-camera-attached-spotlight">Flashlight (Camera-Attached Spotlight)</a></h2>
<p>Attach a spotlight to the camera for a flashlight effect:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_flashlight(world: &amp;mut World, flashlight: Entity) {
    let Some(camera) = world.resources.active_camera else { return };
    let Some(camera_transform) = world.get_global_transform(camera) else { return };

    let position = camera_transform.translation();
    let forward = camera_transform.forward_vector();

    if let Some(transform) = world.get_local_transform_mut(flashlight) {
        transform.translation = position;
        transform.rotation = nalgebra_glm::quat_look_at(&amp;forward, &amp;Vec3::y());
    }
    world.mark_local_transform_dirty(flashlight);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-lighting-works"><a class="header" href="#how-lighting-works">How Lighting Works</a></h2>
<p>Nightshade uses a <strong>clustered forward rendering</strong> pipeline. The view frustum is divided into a 16x9x24 grid of clusters. A compute shader assigns each light to the clusters it overlaps, producing a per-cluster light list (up to 256 lights per cluster). During the mesh pass, each fragment looks up its cluster and only evaluates the lights assigned to it, avoiding the cost of testing every light for every pixel.</p>
<h3 id="pbr-lighting-model"><a class="header" href="#pbr-lighting-model">PBR Lighting Model</a></h3>
<p>All lights are evaluated using the <strong>Cook-Torrance microfacet BRDF</strong>:</p>
<ul>
<li>
<p><strong>Normal Distribution Function (D)</strong>: Trowbridge-Reitz GGX models the statistical distribution of microfacet orientations. The squared roughness parameter (<code>a = roughness * roughness</code>) controls how concentrated the specular highlight is.</p>
</li>
<li>
<p><strong>Geometry Function (G)</strong>: Schlick-Beckmann approximation with Smith's method accounts for self-shadowing between microfacets. Two terms are combined: one for the view direction and one for the light direction.</p>
</li>
<li>
<p><strong>Fresnel (F)</strong>: Schlick's approximation computes how reflectivity changes with viewing angle. For dielectrics, F0 is derived from the index of refraction. For metals, F0 equals the base color.</p>
</li>
</ul>
<p>The final light contribution per light is:</p>
<pre><code>(kD * albedo / PI + specular) * radiance * NdotL
</code></pre>
<p>where <code>kD = (1 - F) * (1 - metallic)</code> ensures metals have no diffuse component.</p>
<h3 id="image-based-lighting"><a class="header" href="#image-based-lighting">Image-Based Lighting</a></h3>
<p>Ambient lighting comes from two pre-computed cubemaps:</p>
<ul>
<li><strong>Irradiance map</strong>: Pre-convolved diffuse environment lighting, sampled in the surface normal direction</li>
<li><strong>Prefiltered environment map</strong>: 5 mip levels of increasingly blurred specular reflections, sampled in the reflection direction at a mip level determined by roughness</li>
</ul>
<p>A 2D BRDF lookup texture (computed via the split-sum approximation) combines with the prefiltered map to produce the final specular IBL contribution.</p>
<h2 id="atmosphere"><a class="header" href="#atmosphere">Atmosphere</a></h2>
<p>Set the sky rendering mode:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.atmosphere = Atmosphere::Sky;
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-lights"><a class="header" href="#multiple-lights">Multiple Lights</a></h2>
<p>Nightshade supports multiple lights in a scene. Create point and spot lights manually as shown above:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_lighting(world: &amp;mut World) {
    spawn_sun(world);

    create_point_light(world, Vec3::new(5.0, 3.0, 5.0), Vec3::new(0.8, 0.9, 1.0), 2.0);
    create_point_light(world, Vec3::new(-5.0, 3.0, -5.0), Vec3::new(1.0, 0.8, 0.7), 1.5);

    create_spotlight(world, Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.0, -1.0, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures--the-texture-cache"><a class="header" href="#textures--the-texture-cache">Textures &amp; the Texture Cache</a></h1>
<p>Nightshade manages GPU textures through a centralized <code>TextureCache</code> with generational indexing and reference counting. Textures can be loaded synchronously, asynchronously, or generated procedurally.</p>
<h2 id="texture-cache"><a class="header" href="#texture-cache">Texture Cache</a></h2>
<p>The <code>TextureCache</code> stores all loaded textures as <code>TextureEntry</code> values (wgpu texture + view + sampler) in a <code>GenerationalRegistry</code>. Each texture is identified by a <code>TextureId</code> containing an index and generation counter, ensuring stale references are detected.</p>
<h3 id="loading-textures-1"><a class="header" href="#loading-textures-1">Loading Textures</a></h3>
<p>The most common way to load a texture is through <code>WorldCommand::LoadTexture</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::LoadTexture {
    name: "my_texture".to_string(),
    rgba_data: image_bytes,
    width: 512,
    height: 512,
});
<span class="boring">}</span></code></pre></pre>
<p>The renderer processes this command and uploads the RGBA data to the GPU. The texture is stored in the cache under the given name.</p>
<h3 id="procedural-textures-1"><a class="header" href="#procedural-textures-1">Procedural Textures</a></h3>
<p>The engine provides built-in procedural textures loaded at startup via <code>load_procedural_textures()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_procedural_textures(world);
<span class="boring">}</span></code></pre></pre>
<p>This creates three textures:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>"checkerboard"</code></td><td>Black and white checkerboard pattern</td></tr>
<tr><td><code>"gradient"</code></td><td>Horizontal gradient</td></tr>
<tr><td><code>"uv_test"</code></td><td>UV coordinate visualization</td></tr>
</tbody></table>
</div>
<h3 id="looking-up-textures"><a class="header" href="#looking-up-textures">Looking Up Textures</a></h3>
<p>Find a loaded texture by name:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let texture_id = texture_cache_lookup_id(&amp;cache, "my_texture");
<span class="boring">}</span></code></pre></pre>
<h3 id="reference-counting"><a class="header" href="#reference-counting">Reference Counting</a></h3>
<p>Textures use reference counting for lifecycle management:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>texture_cache_add_reference(&amp;mut cache, "my_texture");
texture_cache_remove_reference(&amp;mut cache, "my_texture");
texture_cache_remove_unused(&amp;mut cache);
<span class="boring">}</span></code></pre></pre>
<p>When a texture's reference count reaches zero, <code>texture_cache_remove_unused()</code> will free it.</p>
<h3 id="dummy-textures"><a class="header" href="#dummy-textures">Dummy Textures</a></h3>
<p>If a texture is missing, <code>texture_cache_ensure_dummy()</code> creates a 64x64 purple-and-black checkerboard placeholder. This prevents rendering errors from missing assets.</p>
<h2 id="async-texture-loading"><a class="header" href="#async-texture-loading">Async Texture Loading</a></h2>
<p>For loading textures without blocking the main thread, use the <code>TextureLoadQueue</code> system.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::texture_loader::*;

struct MyState {
    queue: SharedTextureQueue,
    loading_state: AssetLoadingState,
}

fn initialize(&amp;mut self, world: &amp;mut World) {
    self.queue = create_shared_queue();

    queue_texture_from_path(&amp;self.queue, "assets/textures/albedo.png");
    queue_texture_from_path(&amp;self.queue, "assets/textures/normal.png");

    self.loading_state = AssetLoadingState::new(2);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="processing-each-frame"><a class="header" href="#processing-each-frame">Processing Each Frame</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let status = process_and_load_textures(
        &amp;self.queue,
        world,
        &amp;mut self.loading_state,
        4,
    );

    if status == AssetLoadingStatus::Complete {
        // All textures loaded
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-progress"><a class="header" href="#loading-progress">Loading Progress</a></h3>
<p>Track loading progress for loading screens:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let progress = self.loading_state.progress(); // 0.0 to 1.0
let is_done = self.loading_state.is_complete();
let loaded = self.loading_state.loaded_textures;
let failed = self.loading_state.failed_textures;
<span class="boring">}</span></code></pre></pre>
<h3 id="platform-behavior"><a class="header" href="#platform-behavior">Platform Behavior</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Loading Method</th></tr></thead><tbody>
<tr><td>Desktop</td><td>Synchronous file read from disk</td></tr>
<tr><td>WASM</td><td>Async HTTP fetch via ehttp</td></tr>
</tbody></table>
</div>
<h3 id="asset-search-paths"><a class="header" href="#asset-search-paths">Asset Search Paths</a></h3>
<p>Configure where texture files are searched:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_asset_search_paths(vec![
    "assets/".to_string(),
    "content/textures/".to_string(),
]);

queue_texture_from_path(&amp;queue, "player.png");
// Searches: assets/player.png, content/textures/player.png
<span class="boring">}</span></code></pre></pre>
<h2 id="sprite-texture-atlas"><a class="header" href="#sprite-texture-atlas">Sprite Texture Atlas</a></h2>
<p>Sprites use a separate texture atlas rather than the main texture cache. The atlas is a single large GPU texture divided into a grid of slots.</p>
<div class="table-wrapper"><table><thead><tr><th>Constant</th><th>Value</th></tr></thead><tbody>
<tr><td><code>SPRITE_ATLAS_TOTAL_SLOTS</code></td><td>128</td></tr>
<tr><td><code>SPRITE_ATLAS_SLOT_SIZE</code></td><td>512 x 512 pixels</td></tr>
</tbody></table>
</div>
<p>Upload textures to specific atlas slots via <code>WorldCommand::UploadSpriteTexture</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::UploadSpriteTexture {
    slot: 0,
    rgba_data: image_bytes,
    width: 256,
    height: 256,
});
<span class="boring">}</span></code></pre></pre>
<p>The <code>Sprite</code> component references textures by their slot index. See <a href="sprites.html">Sprites</a> for details.</p>
<h2 id="material-textures"><a class="header" href="#material-textures">Material Textures</a></h2>
<p>PBR materials reference textures by name through <code>MaterialRef</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let material = Material {
    base_texture: Some("albedo".to_string()),
    normal_texture: Some("normal_map".to_string()),
    metallic_roughness_texture: Some("metallic_roughness".to_string()),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>See <a href="materials.html">Materials</a> for the full PBR material workflow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="water"><a class="header" href="#water">Water</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/water">Water</a></p>
</blockquote>
<p>Nightshade includes a procedural water system with three rendering paths: ray-marched surface water, mesh-based water with vertex displacement, and volumetric water for waterfalls and mist.</p>
<h2 id="how-water-rendering-works"><a class="header" href="#how-water-rendering-works">How Water Rendering Works</a></h2>
<h3 id="wave-generation"><a class="header" href="#wave-generation">Wave Generation</a></h3>
<p>Water surfaces are animated using multi-octave procedural noise. The <code>sea_octave</code> function creates wave-like patterns by combining <code>abs(sin)</code> and <code>abs(cos)</code> of noise-distorted UV coordinates, then raising the result to a choppiness exponent. Higher choppiness values produce sharper wave peaks.</p>
<p>The height map evaluates 5 octaves of this function. Each octave doubles the frequency and reduces amplitude by 0.22x, while increasing choppiness by 20%. Between octaves, UV coordinates are rotated by a fixed 2x2 matrix <code>[1.6, 1.2; -1.2, 1.6]</code> to prevent visible repetition. Two offset directions (<code>uv + time</code> and <code>uv - time</code>) create coherent wave interference patterns.</p>
<h3 id="fresnel-reflections"><a class="header" href="#fresnel-reflections">Fresnel Reflections</a></h3>
<p>The water shader computes the Fresnel effect to blend between refraction (seeing into the water) and reflection (seeing the sky):</p>
<pre><code>fresnel = pow(1.0 - dot(normal, view_direction), fresnel_power)
</code></pre>
<p>At steep viewing angles (looking straight down), <code>fresnel</code> is near 0 and the water shows its base color. At grazing angles (looking across the surface), <code>fresnel</code> approaches 1 and the water reflects the sky. The <code>fresnel_power</code> parameter (default 3.0) controls how quickly this transition happens.</p>
<p>Specular sun reflections use a cosine power of 60 for tight, bright highlights on wave crests.</p>
<h3 id="three-rendering-paths"><a class="header" href="#three-rendering-paths">Three Rendering Paths</a></h3>
<p><strong>Path 1: Ray-Marched Surface Water</strong> - For bounded water regions without mesh geometry. The fragment shader traces rays from the camera through the 3D height field using <code>heightmap_tracing()</code> with 32 march steps and geometric refinement iterations. This produces per-pixel correct reflections and refractions. Supports polygon bounds with soft edge feathering. Limited to 16 simultaneous water regions.</p>
<p><strong>Path 2: Mesh-Based Water</strong> - For large flat surfaces. The vertex shader applies procedural wave displacement to mesh vertices using the same <code>water_height()</code> function. The fragment shader computes normals from height gradients, applies Fresnel-based sky reflection, and adds subsurface scattering: <code>pow(max(dot(view, -sun_dir), 0.0), 2.0) * 0.2</code>. More efficient than ray-marching and integrates properly with the depth buffer.</p>
<p><strong>Path 3: Volumetric Water</strong> - For waterfalls, mist, and cascading water. A per-pixel ray-marching shader traces through SDF-bounded volumes (box, cylinder, or sphere) with up to 64 steps. Three flow types have different density functions:</p>
<ul>
<li><strong>Waterfall</strong>: High vertical stretch with turbulence, top-to-bottom falloff</li>
<li><strong>Mist</strong>: Rising motion with horizontal drift, wispy patterns using 3D FBM noise</li>
<li><strong>Cascade</strong>: Multiple parallel streams using 3 layered FBM noise functions</li>
</ul>
<p>Volumetric water is lit with sun shadowing through the volume and foam blending based on accumulated density.</p>
<h3 id="vertical-water"><a class="header" href="#vertical-water">Vertical Water</a></h3>
<p>For waterfall surfaces, a separate shader (<code>water_mesh_vertical.wgsl</code>) displaces vertices along the surface normal instead of the Y-axis. Wave frequency is stretched (2.0x horizontally, 0.5x vertically) to create vertical streaks. Foam patterns are generated from layered noise and blended with the water color.</p>
<h3 id="frustum-culling"><a class="header" href="#frustum-culling">Frustum Culling</a></h3>
<p>A compute shader (<code>water_mesh_culling.wgsl</code>) tests each water object's bounding sphere against the 6 frustum planes. Culled objects skip rendering entirely. For volumetric water, the bounding sphere is derived from the volume's half-size. Visible instances are appended to an indirect draw buffer via atomic operations.</p>
<h2 id="water-component"><a class="header" href="#water-component">Water Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Water {
    pub wave_height: f32,           // Wave amplitude (default: 0.6)
    pub choppy: f32,                // Wave sharpness (default: 4.0, higher = sharper peaks)
    pub speed: f32,                 // Animation speed (default: 0.8)
    pub frequency: f32,             // Wave frequency (default: 0.16, lower = longer waves)
    pub base_height: f32,           // Water level (default: 0.0)
    pub base_color: Vec4,           // Dark water color
    pub water_color: Vec4,          // Light water color
    pub specular_strength: f32,     // Sun reflection intensity (default: 1.0)
    pub fresnel_power: f32,         // Reflection balance (default: 3.0)
    pub edge_feather_distance: f32, // Shore softness (default: 2.0)
    pub is_vertical: bool,          // Waterfall mode
    pub is_volumetric: bool,        // 3D volume mode
    pub volume_shape: VolumeShape,  // Box, Cylinder, or Sphere
    pub volume_flow_type: VolumeFlowType, // Waterfall, Mist, or Cascade
    pub volume_size: Vec3,          // Volume dimensions
    pub flow_direction: Vec2,       // Normalized flow direction
    pub flow_strength: f32,         // Flow intensity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spawning-water"><a class="header" href="#spawning-water">Spawning Water</a></h2>
<h3 id="planar-water"><a class="header" href="#planar-water">Planar Water</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let water_entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | WATER,
    1
)[0];

world.set_local_transform(water_entity, LocalTransform {
    translation: Vec3::new(0.0, 0.0, 0.0),
    ..Default::default()
});

world.set_water(water_entity, Water {
    wave_height: 0.5,
    speed: 1.0,
    frequency: 0.5,
    choppy: 4.0,
    base_color: Vec4::new(0.0, 0.1, 0.2, 1.0),
    water_color: Vec4::new(0.0, 0.3, 0.5, 1.0),
    fresnel_power: 3.0,
    specular_strength: 1.0,
    edge_feather_distance: 1.0,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="volumetric-water-waterfall"><a class="header" href="#volumetric-water-waterfall">Volumetric Water (Waterfall)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_water(waterfall_entity, Water {
    is_volumetric: true,
    volume_shape: VolumeShape::Box,
    volume_flow_type: VolumeFlowType::Waterfall,
    volume_size: Vec3::new(2.0, 10.0, 1.0),
    flow_direction: Vec2::new(0.0, -1.0),
    flow_strength: 2.0,
    base_color: Vec4::new(0.0, 0.15, 0.25, 1.0),
    water_color: Vec4::new(0.1, 0.4, 0.6, 1.0),
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="wave-parameters"><a class="header" href="#wave-parameters">Wave Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Range</th><th>Effect</th></tr></thead><tbody>
<tr><td><code>wave_height</code></td><td>0.1-2.0</td><td>Vertical amplitude of waves</td></tr>
<tr><td><code>choppy</code></td><td>1.0-8.0</td><td>Higher = sharper peaks, lower = smooth rounded waves</td></tr>
<tr><td><code>speed</code></td><td>0.1-2.0</td><td>Animation speed (time multiplier)</td></tr>
<tr><td><code>frequency</code></td><td>0.05-0.5</td><td>Lower = longer wavelengths, higher = finer detail</td></tr>
<tr><td><code>fresnel_power</code></td><td>1.0-10.0</td><td>Higher = stronger reflection at grazing angles</td></tr>
<tr><td><code>specular_strength</code></td><td>0.0-2.0</td><td>Sun reflection intensity</td></tr>
</tbody></table>
</div>
<h2 id="dynamic-weather"><a class="header" href="#dynamic-weather">Dynamic Weather</a></h2>
<p>Water properties can be changed at runtime for weather transitions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stormy_weather(world: &amp;mut World, water: Entity) {
    if let Some(w) = world.get_water_mut(water) {
        w.wave_height = 3.0;
        w.speed = 2.0;
        w.choppy = 6.0;
    }
}

fn calm_weather(world: &amp;mut World, water: Entity) {
    if let Some(w) = world.get_water_mut(water) {
        w.wave_height = 0.3;
        w.speed = 0.5;
        w.choppy = 2.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decals"><a class="header" href="#decals">Decals</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/decals">Decals</a></p>
</blockquote>
<p>Decals are textures projected onto scene geometry using deferred projection through the depth buffer. They are used for bullet holes, blood splatters, footprints, scorch marks, and environmental details without modifying the underlying mesh geometry.</p>
<h2 id="how-decal-rendering-works"><a class="header" href="#how-decal-rendering-works">How Decal Rendering Works</a></h2>
<p>Each decal is rendered as a unit cube positioned and oriented in world space. The fragment shader reconstructs the world position of the scene geometry behind the cube by sampling the depth buffer, then transforms that position into the decal's local space using the inverse model matrix. If the reconstructed point falls within the decal's projection volume (±1 in XY, 0 to depth in Z), the decal texture is sampled at those local XY coordinates and blended onto the scene.</p>
<p>The normal threshold test compares the scene surface normal (from the depth buffer gradients) against the decal's forward direction. Surfaces angled beyond the threshold are rejected, preventing decals from wrapping around sharp edges.</p>
<p>Distance fade uses a smoothstep between <code>fade_start</code> and <code>fade_end</code> based on the camera-to-decal distance.</p>
<h2 id="decal-component"><a class="header" href="#decal-component">Decal Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Decal {
    pub texture: Option&lt;String&gt;,
    pub emissive_texture: Option&lt;String&gt;,
    pub emissive_strength: f32,
    pub color: [f32; 4],
    pub size: Vec2,
    pub depth: f32,
    pub normal_threshold: f32,
    pub fade_start: f32,
    pub fade_end: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>texture</code></td><td><code>None</code></td><td>Texture name in the texture cache</td></tr>
<tr><td><code>emissive_texture</code></td><td><code>None</code></td><td>Optional emissive texture for glowing decals</td></tr>
<tr><td><code>emissive_strength</code></td><td><code>1.0</code></td><td>HDR multiplier for emissive texture</td></tr>
<tr><td><code>color</code></td><td><code>[1, 1, 1, 1]</code></td><td>RGBA tint multiplied with the texture</td></tr>
<tr><td><code>size</code></td><td><code>(1.0, 1.0)</code></td><td>Width and height of the projected decal</td></tr>
<tr><td><code>depth</code></td><td><code>1.0</code></td><td>Projection depth (how far the decal penetrates into surfaces)</td></tr>
<tr><td><code>normal_threshold</code></td><td><code>0.5</code></td><td>Surface angle cutoff (0 = accept all, 1 = perpendicular only)</td></tr>
<tr><td><code>fade_start</code></td><td><code>50.0</code></td><td>Distance where fade begins</td></tr>
<tr><td><code>fade_end</code></td><td><code>100.0</code></td><td>Distance where the decal is fully transparent</td></tr>
</tbody></table>
</div>
<h2 id="spawning-decals"><a class="header" href="#spawning-decals">Spawning Decals</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_bullet_hole(world: &amp;mut World, position: Vec3, normal: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | DECAL,
        1
    )[0];

    let rotation = nalgebra_glm::quat_look_at(&amp;normal, &amp;Vec3::y());

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation,
        ..Default::default()
    });

    world.set_decal(entity, Decal::new("bullet_hole")
        .with_size(0.2, 0.2)
        .with_depth(0.1)
        .with_normal_threshold(0.5)
        .with_fade(20.0, 30.0));

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="builder-api-1"><a class="header" href="#builder-api-1">Builder API</a></h2>
<p>The <code>Decal</code> struct supports a builder pattern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let decal = Decal::new("texture_name")
    .with_size(0.5, 0.5)
    .with_depth(0.2)
    .with_color([1.0, 0.0, 0.0, 1.0])
    .with_normal_threshold(0.3)
    .with_fade(30.0, 50.0)
    .with_emissive("rune_glow", 3.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="blood-splatter"><a class="header" href="#blood-splatter">Blood Splatter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_blood(world: &amp;mut World, position: Vec3, normal: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | DECAL,
        1
    )[0];

    let rotation = nalgebra_glm::quat_look_at(&amp;normal, &amp;Vec3::y());
    let random_angle = rand::random::&lt;f32&gt;() * std::f32::consts::TAU;
    let rotation = rotation * nalgebra_glm::quat_angle_axis(random_angle, &amp;Vec3::z());

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation,
        ..Default::default()
    });

    world.set_decal(entity, Decal::new("blood")
        .with_size(0.8, 0.8)
        .with_depth(0.1)
        .with_normal_threshold(0.3)
        .with_fade(30.0, 50.0));

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="emissive-rune"><a class="header" href="#emissive-rune">Emissive Rune</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_magic_rune(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | DECAL,
        1
    )[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation: nalgebra_glm::quat_angle_axis(
            -std::f32::consts::FRAC_PI_2,
            &amp;Vec3::x(),
        ),
        ..Default::default()
    });

    world.set_decal(entity, Decal::new("rune")
        .with_size(2.0, 2.0)
        .with_depth(0.5)
        .with_normal_threshold(0.7)
        .with_fade(50.0, 80.0)
        .with_emissive("rune_glow", 3.0));

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="footprints"><a class="header" href="#footprints">Footprints</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_footprint(world: &amp;mut World, position: Vec3, direction: Vec3, left: bool) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | DECAL,
        1
    )[0];

    let rotation = nalgebra_glm::quat_look_at(&amp;Vec3::y(), &amp;direction);
    let flip = if left { 1.0 } else { -1.0 };

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation,
        scale: Vec3::new(flip, 1.0, 1.0),
    });

    world.set_decal(entity, Decal::new("footprint")
        .with_size(0.15, 0.3)
        .with_depth(0.05)
        .with_normal_threshold(0.8)
        .with_fade(15.0, 25.0));

    entity
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites"><a class="header" href="#sprites">Sprites</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/sprites">Sprites</a></p>
</blockquote>
<p>Sprites are 2D textured quads rendered in 3D space. They support texture blending, animation, and GPU-instanced rendering with automatic z-sorting.</p>
<h2 id="sprite-component"><a class="header" href="#sprite-component">Sprite Component</a></h2>
<p>The <code>Sprite</code> component defines the visual properties of a sprite entity:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Sprite {
    pub color: [f32; 4],
    pub texture_index: u32,
    pub texture_index2: u32,
    pub blend_factor: f32,
    pub uv_min: Vec2,
    pub uv_max: Vec2,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>color</code></td><td>RGBA tint color, multiplied with the texture</td></tr>
<tr><td><code>texture_index</code></td><td>Primary texture slot in the sprite atlas</td></tr>
<tr><td><code>texture_index2</code></td><td>Secondary texture slot for blending</td></tr>
<tr><td><code>blend_factor</code></td><td>Blend weight between the two textures (0.0 = first, 1.0 = second)</td></tr>
<tr><td><code>uv_min</code> / <code>uv_max</code></td><td>UV coordinates within the atlas slot</td></tr>
</tbody></table>
</div>
<h2 id="creating-sprites"><a class="header" href="#creating-sprites">Creating Sprites</a></h2>
<p>Use the builder pattern:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sprite = Sprite::new()
    .with_texture(0)
    .with_color([1.0, 0.5, 0.5, 1.0]);

let entity = world.spawn_entities(
    SPRITE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM,
    1,
)[0];
world.set_sprite(entity, sprite);
world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),
    scale: Vec3::new(2.0, 2.0, 1.0),
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="texture-blending"><a class="header" href="#texture-blending">Texture Blending</a></h3>
<p>Blend between two textures for smooth transitions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sprite = Sprite::new()
    .with_multitexture(0, 1, 0.5);
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-sprite-textures"><a class="header" href="#loading-sprite-textures">Loading Sprite Textures</a></h2>
<p>Sprite textures are stored in the sprite texture atlas, not the main texture cache. Upload textures to atlas slots using <code>WorldCommand::UploadSpriteTexture</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::UploadSpriteTexture {
    slot: 0,
    rgba_data: image_bytes,
    width: 256,
    height: 256,
});
<span class="boring">}</span></code></pre></pre>
<p>Each slot is 512x512 pixels. There are 128 total slots. Textures smaller than the slot size are placed in the top-left corner of the slot.</p>
<h2 id="sprite-animation"><a class="header" href="#sprite-animation">Sprite Animation</a></h2>
<p>The <code>SpriteAnimator</code> component drives frame-based animation by updating the sprite's UV coordinates each frame.</p>
<h3 id="grid-based-animation"><a class="header" href="#grid-based-animation">Grid-Based Animation</a></h3>
<p>For sprite sheets arranged in a grid:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animator = SpriteAnimator::from_grid(
    8,      // columns
    4,      // rows
    32,     // total frames
    0.1,    // seconds per frame
);

world.set_sprite_animator(entity, animator);
<span class="boring">}</span></code></pre></pre>
<p>This computes UV coordinates for each frame automatically based on the grid layout.</p>
<h3 id="loop-modes"><a class="header" href="#loop-modes">Loop Modes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animator = SpriteAnimator::from_grid(4, 1, 4, 0.15)
    .with_loop_mode(LoopMode::Loop);      // default
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>LoopMode::Once</code></td><td>Plays once and stops on the last frame</td></tr>
<tr><td><code>LoopMode::Loop</code></td><td>Loops back to the first frame (default)</td></tr>
<tr><td><code>LoopMode::PingPong</code></td><td>Plays forward, then backward, repeating</td></tr>
</tbody></table>
</div>
<h3 id="playback-control"><a class="header" href="#playback-control">Playback Control</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>animator.play();
animator.pause();
animator.reset();
<span class="boring">}</span></code></pre></pre>
<h3 id="speed"><a class="header" href="#speed">Speed</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animator = SpriteAnimator::from_grid(4, 1, 4, 0.1)
    .with_speed(2.0); // 2x playback speed
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-frames"><a class="header" href="#manual-frames">Manual Frames</a></h3>
<p>For non-uniform frame layouts, define frames individually:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animator = SpriteAnimator {
    frames: vec![
        SpriteFrame {
            uv_min: Vec2::new(0.0, 0.0),
            uv_max: Vec2::new(0.25, 0.5),
            duration: 0.1,
            texture_index: None,
        },
        SpriteFrame {
            uv_min: Vec2::new(0.25, 0.0),
            uv_max: Vec2::new(0.5, 0.5),
            duration: 0.2,
            texture_index: Some(1), // switch to atlas slot 1
        },
    ],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>The <code>texture_index</code> field on <code>SpriteFrame</code> optionally switches the sprite's atlas slot on that frame.</p>
<h3 id="animation-system"><a class="header" href="#animation-system">Animation System</a></h3>
<p>The <code>sprite_animation_system</code> must run each frame to advance animations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    sprite_animation_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h2>
<p>The <code>SpritePass</code> renders all sprite entities using GPU instancing. It:</p>
<ul>
<li>Collects all entities with <code>Sprite</code> + <code>GlobalTransform</code> components</li>
<li>Performs frustum culling based on camera position</li>
<li>Sorts sprites by depth for correct alpha blending</li>
<li>Renders camera-facing quads with instanced draw calls</li>
</ul>
<p>Sprites are rendered as part of the geometry pass pipeline and write to both <code>scene_color</code> and <code>depth</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-overview"><a class="header" href="#physics-overview">Physics Overview</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/physics">Physics</a></p>
</blockquote>
<p>Nightshade integrates Rapier3D for physics simulation, providing rigid body dynamics, collision detection, and character controllers.</p>
<h2 id="enabling-physics"><a class="header" href="#enabling-physics">Enabling Physics</a></h2>
<p>Physics is enabled with the <code>physics</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "physics"] }
</code></pre>
<h2 id="physics-world"><a class="header" href="#physics-world">Physics World</a></h2>
<p>The physics world is accessed through resources:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let physics = &amp;mut world.resources.physics;

// Configuration
physics.gravity = Vec3::new(0.0, -9.81, 0.0);
physics.fixed_timestep = 1.0 / 60.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="rigid-bodies"><a class="header" href="#rigid-bodies">Rigid Bodies</a></h3>
<p>Objects that can move and be affected by forces:</p>
<ul>
<li><strong>Dynamic</strong>: Affected by gravity and forces</li>
<li><strong>Kinematic</strong>: Moved by code, affects dynamic bodies</li>
<li><strong>Fixed</strong>: Immovable, infinite mass</li>
</ul>
<h3 id="colliders"><a class="header" href="#colliders">Colliders</a></h3>
<p>Shapes used for collision detection:</p>
<ul>
<li>Cuboid, Ball, Capsule, Cylinder</li>
<li>Triangle mesh, Heightfield</li>
<li>Compound shapes</li>
</ul>
<h3 id="character-controllers"><a class="header" href="#character-controllers">Character Controllers</a></h3>
<p>Kinematic bodies with special handling for player movement.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_cube_at(world, Vec3::new(0.0, -0.5, 0.0));

    for index in 0..10 {
        spawn_cube_at(world, Vec3::new(0.0, 2.0 + index as f32 * 1.5, 0.0));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-synchronization"><a class="header" href="#physics-synchronization">Physics Synchronization</a></h2>
<p>Physics runs at a fixed timestep. Transforms are automatically synchronized:</p>
<ol>
<li>Game logic updates entity transforms</li>
<li>Physics simulation steps (may run multiple times per frame)</li>
<li>Physics transforms sync back to entities</li>
<li>Interpolation smooths visual positions</li>
</ol>
<h2 id="querying-physics"><a class="header" href="#querying-physics">Querying Physics</a></h2>
<h3 id="raycasting"><a class="header" href="#raycasting">Raycasting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::queries::*;

let ray_origin = Vec3::new(0.0, 5.0, 0.0);
let ray_direction = Vec3::new(0.0, -1.0, 0.0);
let max_distance = 100.0;

if let Some(hit) = raycast(world, ray_origin, ray_direction, max_distance) {
    let hit_point = hit.point;
    let hit_normal = hit.normal;
    let hit_entity = hit.entity;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="overlap-tests"><a class="header" href="#overlap-tests">Overlap Tests</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if a sphere overlaps any colliders
let overlaps = sphere_overlap(world, center, radius);
for entity in overlaps {
    // Handle collision
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-materials"><a class="header" href="#physics-materials">Physics Materials</a></h2>
<p>Control friction and bounciness:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_physics_material(entity, PhysicsMaterialComponent {
    friction: 0.5,
    restitution: 0.3,  // Bounciness
    density: 1.0,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization"><a class="header" href="#debug-visualization">Debug Visualization</a></h2>
<p>Enable physics debug drawing:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.physics.debug_draw = true;

// In run_systems
physics_debug_draw_system(world);
<span class="boring">}</span></code></pre></pre>
<p>This renders:</p>
<ul>
<li>Collider shapes (wireframe)</li>
<li>Contact points</li>
<li>Collision normals</li>
</ul>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li>Use simple collider shapes (boxes, spheres) when possible</li>
<li>Disable collision between groups that don't need it</li>
<li>Use compound colliders instead of many small colliders</li>
<li>Set bodies to sleep when inactive</li>
<li>Use appropriate fixed timestep (60 Hz is standard)</li>
</ol>
<h2 id="joints"><a class="header" href="#joints">Joints</a></h2>
<p>Connect bodies with joints for:</p>
<ul>
<li>Doors (revolute)</li>
<li>Drawers (prismatic)</li>
<li>Ropes (rope/spring)</li>
<li>Chains (spherical)</li>
</ul>
<p>See <a href="physics-joints.html">Physics Joints</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-bodies-1"><a class="header" href="#rigid-bodies-1">Rigid Bodies</a></h1>
<p>Rigid bodies are the foundation of physics simulation. They define how objects move and respond to forces.</p>
<h2 id="body-types"><a class="header" href="#body-types">Body Types</a></h2>
<h3 id="dynamic-bodies"><a class="header" href="#dynamic-bodies">Dynamic Bodies</a></h3>
<p>Fully simulated physics objects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RIGID_BODY | COLLIDER,
    1
)[0];

world.set_rigid_body(entity, RigidBodyComponent::new_dynamic());

world.set_collider(entity, ColliderComponent::new_ball(0.5));
<span class="boring">}</span></code></pre></pre>
<h3 id="kinematic-bodies"><a class="header" href="#kinematic-bodies">Kinematic Bodies</a></h3>
<p>Controlled by code, not affected by forces:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_rigid_body(entity, RigidBodyComponent::new_kinematic_position_based());
<span class="boring">}</span></code></pre></pre>
<p>Move kinematic bodies by updating their transform:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(transform) = world.get_local_transform_mut(kinematic_entity) {
    transform.translation.x += velocity.x * dt;
}
world.mark_local_transform_dirty(kinematic_entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="static-bodies"><a class="header" href="#static-bodies">Static Bodies</a></h3>
<p>Immovable objects (floors, walls):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_rigid_body(entity, RigidBodyComponent::new_static());
<span class="boring">}</span></code></pre></pre>
<h2 id="helper-functions-1"><a class="header" href="#helper-functions-1">Helper Functions</a></h2>
<h3 id="spawning-physics-cubes"><a class="header" href="#spawning-physics-cubes">Spawning Physics Cubes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::*;

let cube = spawn_cube_at(world, Vec3::new(0.0, 5.0, 0.0));
<span class="boring">}</span></code></pre></pre>
<h3 id="spawning-physics-spheres"><a class="header" href="#spawning-physics-spheres">Spawning Physics Spheres</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sphere = spawn_sphere_at(world, Vec3::new(0.0, 10.0, 0.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="applying-forces"><a class="header" href="#applying-forces">Applying Forces</a></h2>
<p>Access the Rapier rigid body directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_force(world: &amp;mut World, entity: Entity, force: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.add_force(
            rapier3d::prelude::Vector::new(force.x, force.y, force.z),
            true,  // wake up if sleeping
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="applying-impulses"><a class="header" href="#applying-impulses">Applying Impulses</a></h2>
<p>Instant velocity change:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_impulse(world: &amp;mut World, entity: Entity, impulse: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.apply_impulse(
            rapier3d::prelude::Vector::new(impulse.x, impulse.y, impulse.z),
            true,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-velocity"><a class="header" href="#setting-velocity">Setting Velocity</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_velocity(world: &amp;mut World, entity: Entity, velocity: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.set_linvel(
            rapier3d::prelude::Vector::new(velocity.x, velocity.y, velocity.z),
            true,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-velocity"><a class="header" href="#getting-velocity">Getting Velocity</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_velocity(world: &amp;World, entity: Entity) -&gt; Option&lt;Vec3&gt; {
    let rb_component = world.get_rigid_body(entity)?;
    let handle = rb_component.handle?;
    let rigid_body = world.resources.physics.rigid_body_set.get(handle.into())?;

    let vel = rigid_body.linvel();
    Some(Vec3::new(vel.x, vel.y, vel.z))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mass-properties"><a class="header" href="#mass-properties">Mass Properties</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_mass(world: &amp;mut World, entity: Entity, mass: f32) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.set_additional_mass(mass, true);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="locking-axes"><a class="header" href="#locking-axes">Locking Axes</a></h2>
<p>Prevent rotation or translation on specific axes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    // Lock rotation (useful for character controllers)
    rigid_body.lock_rotations(true, true);

    // Lock specific translation axes
    // rigid_body.lock_translations(true, true);  // Lock X and Y
}
<span class="boring">}</span></code></pre></pre>
<h2 id="damping"><a class="header" href="#damping">Damping</a></h2>
<p>Add drag to slow objects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    rigid_body.set_linear_damping(0.5);   // Translation damping
    rigid_body.set_angular_damping(0.5);  // Rotation damping
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sleeping"><a class="header" href="#sleeping">Sleeping</a></h2>
<p>Bodies automatically sleep when stationary. Wake them:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    rigid_body.wake_up(true);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colliders-1"><a class="header" href="#colliders-1">Colliders</a></h1>
<p>Colliders define the physical shape of objects for collision detection.</p>
<h2 id="collider-shapes"><a class="header" href="#collider-shapes">Collider Shapes</a></h2>
<h3 id="ball-sphere"><a class="header" href="#ball-sphere">Ball (Sphere)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent::new_ball(0.5));
<span class="boring">}</span></code></pre></pre>
<h3 id="cuboid-box"><a class="header" href="#cuboid-box">Cuboid (Box)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent::cuboid(1.0, 0.5, 1.0));
<span class="boring">}</span></code></pre></pre>
<h3 id="capsule"><a class="header" href="#capsule">Capsule</a></h3>
<p>Perfect for characters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent::capsule(1.0, 0.3));
<span class="boring">}</span></code></pre></pre>
<h3 id="cylinder"><a class="header" href="#cylinder">Cylinder</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Cylinder {
        radius: 0.5,
        height: 2.0,
    },
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cone"><a class="header" href="#cone">Cone</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Cone {
        radius: 0.5,
        height: 2.0,
    },
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="triangle-mesh"><a class="header" href="#triangle-mesh">Triangle Mesh</a></h3>
<p>For complex static geometry:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vertices: Vec&lt;Vec3&gt; = mesh.vertices.iter()
    .map(|v| Vec3::new(v.position[0], v.position[1], v.position[2]))
    .collect();

let indices: Vec&lt;[u32; 3]&gt; = mesh.indices
    .chunks(3)
    .map(|c| [c[0], c[1], c[2]])
    .collect();

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Trimesh { vertices, indices },
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="heightfield"><a class="header" href="#heightfield">Heightfield</a></h3>
<p>For terrain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heights: Vec&lt;Vec&lt;f32&gt;&gt; = generate_height_grid(64, 64);

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Heightfield {
        heights,
        scale: Vec3::new(100.0, 50.0, 100.0),
    },
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="compound"><a class="header" href="#compound">Compound</a></h3>
<p>Multiple shapes combined:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shapes = vec![
    (ColliderShape::Cuboid { x: 0.5, y: 0.1, z: 0.5 }, body_offset),
    (ColliderShape::Ball { radius: 0.3 }, head_offset),
];

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Compound { shapes },
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-materials-1"><a class="header" href="#physics-materials-1">Physics Materials</a></h2>
<p>Control surface properties:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_physics_material(entity, PhysicsMaterialComponent {
    friction: 0.5,      // Sliding resistance (0 = ice, 1 = rubber)
    restitution: 0.3,   // Bounciness (0 = no bounce, 1 = perfect bounce)
    density: 1.0,       // Mass per unit volume
});
<span class="boring">}</span></code></pre></pre>
<h3 id="material-examples"><a class="header" href="#material-examples">Material Examples</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ice
let ice = PhysicsMaterialComponent {
    friction: 0.05,
    restitution: 0.1,
    density: 0.9,
};

// Rubber
let rubber = PhysicsMaterialComponent {
    friction: 0.9,
    restitution: 0.8,
    density: 1.1,
};

// Metal
let metal = PhysicsMaterialComponent {
    friction: 0.4,
    restitution: 0.2,
    density: 7.8,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="collision-groups"><a class="header" href="#collision-groups">Collision Groups</a></h2>
<p>Filter which objects collide:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rapier3d::prelude::*;

// Define groups
const GROUP_PLAYER: Group = Group::GROUP_1;
const GROUP_ENEMY: Group = Group::GROUP_2;
const GROUP_PROJECTILE: Group = Group::GROUP_3;
const GROUP_WORLD: Group = Group::GROUP_4;

// Player collides with enemies and world, not own projectiles
let player_filter = CollisionGroups::new(
    GROUP_PLAYER,
    GROUP_ENEMY | GROUP_WORLD,
);
<span class="boring">}</span></code></pre></pre>
<h2 id="sensor-colliders"><a class="header" href="#sensor-colliders">Sensor Colliders</a></h2>
<p>Detect overlaps without physical response:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a trigger zone
if let Some(collider) = world.resources.physics.collider_set.get_mut(handle.into()) {
    collider.set_sensor(true);
}
<span class="boring">}</span></code></pre></pre>
<p>Check sensor overlaps in your game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_trigger_zone(world: &amp;World, trigger_entity: Entity) -&gt; Vec&lt;Entity&gt; {
    // Query overlapping entities
    let overlaps = overlap_test(world, trigger_entity);
    overlaps
}
<span class="boring">}</span></code></pre></pre>
<h2 id="collision-events"><a class="header" href="#collision-events">Collision Events</a></h2>
<p>Query collision pairs:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // Check for new collisions this frame
    for (entity_a, entity_b, started) in world.resources.physics.collision_events() {
        if started {
            handle_collision_start(entity_a, entity_b);
        } else {
            handle_collision_end(entity_a, entity_b);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="convex-decomposition"><a class="header" href="#convex-decomposition">Convex Decomposition</a></h2>
<p>For complex shapes on dynamic bodies, use convex decomposition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rapier3d::prelude::*;

// This creates multiple convex pieces from a concave mesh
let decomposed = SharedShape::convex_decomposition(&amp;vertices, &amp;indices);
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Shape</th><th>Performance</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Ball</td><td>Fastest</td><td>Rolling objects</td></tr>
<tr><td>Cuboid</td><td>Fast</td><td>Crates, buildings</td></tr>
<tr><td>Capsule</td><td>Fast</td><td>Characters</td></tr>
<tr><td>Cylinder</td><td>Medium</td><td>Barrels, pillars</td></tr>
<tr><td>Convex</td><td>Medium</td><td>Simple props</td></tr>
<tr><td>Trimesh</td><td>Slow</td><td>Static terrain only</td></tr>
<tr><td>Compound</td><td>Varies</td><td>Complex dynamic objects</td></tr>
</tbody></table>
</div>
<ul>
<li>Prefer primitive shapes over meshes</li>
<li>Use trimesh only for static geometry</li>
<li>Compound colliders are better than multiple entities</li>
<li>Simplify collision geometry vs visual geometry</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-controllers-1"><a class="header" href="#character-controllers-1">Character Controllers</a></h1>
<p>Character controllers provide smooth player movement with collision handling, slopes, and stairs.</p>
<h2 id="first-person-player"><a class="header" href="#first-person-player">First-Person Player</a></h2>
<p>The easiest way to get started:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::character::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let (player_entity, camera_entity) = spawn_first_person_player(
        world,
        Vec3::new(0.0, 2.0, 0.0),
    );

    self.player = Some(player_entity);

    if let Some(controller) = world.get_character_controller_mut(player_entity) {
        controller.max_speed = 5.0;
        controller.is_sprinting = false;
        controller.jump_impulse = 6.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-character-controller"><a class="header" href="#custom-character-controller">Custom Character Controller</a></h2>
<p>For third-person or specialized characters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_character(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        NAME | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | CHARACTER_CONTROLLER,
        1,
    )[0];

    world.set_name(entity, Name("Player".to_string()));
    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    if let Some(controller) = world.get_character_controller_mut(entity) {
        *controller = CharacterControllerComponent::new_capsule(0.5, 0.3);
        controller.max_speed = 3.0;
        controller.acceleration = 15.0;
        controller.jump_impulse = 4.0;
        controller.is_sprinting = false;
        controller.is_crouching = false;
    }

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="controller-properties"><a class="header" href="#controller-properties">Controller Properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>max_speed</code></td><td>Walking speed</td><td>5.0</td></tr>
<tr><td><code>is_sprinting</code></td><td>Sprint active</td><td>false</td></tr>
<tr><td><code>acceleration</code></td><td>Speed up rate</td><td>20.0</td></tr>
<tr><td><code>jump_impulse</code></td><td>Jump strength</td><td>5.0</td></tr>
<tr><td><code>can_jump</code></td><td>Allow jumping</td><td>true</td></tr>
<tr><td><code>is_crouching</code></td><td>Crouch active</td><td>false</td></tr>
</tbody></table>
</div>
<h2 id="movement-input"><a class="header" href="#movement-input">Movement Input</a></h2>
<p>Character controllers automatically process input, but you can also control them manually:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn custom_movement_system(world: &amp;mut World, player: Entity) {
    let input = &amp;world.resources.input;

    // Gather movement direction
    let mut direction = Vec3::zeros();
    if input.keyboard.is_key_pressed(KeyCode::KeyW) {
        direction.z -= 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyS) {
        direction.z += 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyA) {
        direction.x -= 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyD) {
        direction.x += 1.0;
    }

    if let Some(controller) = world.get_character_controller_mut(player) {
        controller.input_direction = direction;
        controller.wants_jump = input.keyboard.is_key_pressed(KeyCode::Space);
        controller.wants_sprint = input.keyboard.is_key_pressed(KeyCode::ShiftLeft);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ground-detection"><a class="header" href="#ground-detection">Ground Detection</a></h2>
<p>Check if the character is grounded:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller(player) {
    if controller.grounded {
        // On ground - can jump
    } else {
        // In air
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="slope-handling"><a class="header" href="#slope-handling">Slope Handling</a></h2>
<p>Controllers automatically handle slopes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller_mut(player) {
    controller.max_slope_angle = 0.8;  // ~45 degrees in radians
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-integration"><a class="header" href="#camera-integration">Camera Integration</a></h2>
<h3 id="first-person-camera"><a class="header" href="#first-person-camera">First-Person Camera</a></h3>
<p>The camera is a child of the player:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PERSPECTIVE_CAMERA | PARENT,
    1
)[0];

world.update_parent(camera, Some(Parent(Some(player))));
world.set_local_transform(camera, LocalTransform {
    translation: Vec3::new(0.0, 0.8, 0.0),  // Eye height
    ..Default::default()
});

world.resources.active_camera = Some(camera);
<span class="boring">}</span></code></pre></pre>
<h3 id="third-person-camera"><a class="header" href="#third-person-camera">Third-Person Camera</a></h3>
<p>Follow the character with an offset:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn third_person_camera_system(world: &amp;mut World, player: Entity, camera: Entity) {
    let Some(player_pos) = world.get_local_transform(player).map(|t| t.translation) else {
        return;
    };

    // Camera behind and above player
    let offset = Vec3::new(0.0, 3.0, 8.0);
    let target_pos = player_pos + offset;

    if let Some(pan_orbit) = world.get_pan_orbit_camera_mut(camera) {
        pan_orbit.target_focus = player_pos + Vec3::new(0.0, 1.0, 0.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-climbing"><a class="header" href="#step-climbing">Step Climbing</a></h2>
<p>Controllers can automatically climb small steps:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller_mut(player) {
    controller.max_step_height = 0.3;  // Can climb 30cm steps
    controller.min_step_width = 0.1;   // Minimum step width
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interaction-cooldowns"><a class="header" href="#interaction-cooldowns">Interaction Cooldowns</a></h2>
<p>Prevent rapid repeated actions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PlayerState {
    interaction_cooldown: f32,
}

fn update_cooldown(state: &amp;mut PlayerState, dt: f32) {
    state.interaction_cooldown = (state.interaction_cooldown - dt).max(0.0);
}

fn can_interact(state: &amp;PlayerState) -&gt; bool {
    state.interaction_cooldown &lt;= 0.0
}

fn set_cooldown(state: &amp;mut PlayerState, duration: f32) {
    state.interaction_cooldown = duration;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-joints"><a class="header" href="#physics-joints">Physics Joints</a></h1>
<p>Joints connect two rigid bodies together, constraining their relative motion.</p>
<h2 id="joint-types"><a class="header" href="#joint-types">Joint Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Joint</th><th>Description</th><th>Use Cases</th></tr></thead><tbody>
<tr><td>Fixed</td><td>Rigid connection</td><td>Welded objects</td></tr>
<tr><td>Spherical</td><td>Ball-and-socket</td><td>Pendulums, ragdolls</td></tr>
<tr><td>Revolute</td><td>Hinge</td><td>Doors, wheels</td></tr>
<tr><td>Prismatic</td><td>Slider</td><td>Drawers, pistons</td></tr>
<tr><td>Rope</td><td>Max distance</td><td>Ropes, chains</td></tr>
<tr><td>Spring</td><td>Elastic</td><td>Suspension, bouncy connections</td></tr>
</tbody></table>
</div>
<h2 id="fixed-joint"><a class="header" href="#fixed-joint">Fixed Joint</a></h2>
<p>Rigidly connects two bodies:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::joints::*;

create_fixed_joint(
    world,
    body_a,
    body_b,
    FixedJoint::new()
        .with_local_anchor1(Vec3::new(0.5, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="spherical-joint-ball-and-socket"><a class="header" href="#spherical-joint-ball-and-socket">Spherical Joint (Ball-and-Socket)</a></h2>
<p>Allows rotation in all directions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pendulum
let anchor = spawn_cube_at(world, Vec3::new(0.0, 5.0, 0.0));
let ball = spawn_sphere_at(world, Vec3::new(0.0, 3.0, 0.0));

create_spherical_joint(
    world,
    anchor,
    ball,
    SphericalJoint::new()
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 1.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="revolute-joint-hinge"><a class="header" href="#revolute-joint-hinge">Revolute Joint (Hinge)</a></h2>
<p>Rotates around a single axis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Door hinge
let door_frame = spawn_static_entity(world);
let door = spawn_cube_at(world, Vec3::new(0.5, 1.0, 0.0));

create_revolute_joint(
    world,
    door_frame,
    door,
    RevoluteJoint::new(JointAxisDirection::Y)  // Rotate around Y axis
        .with_local_anchor1(Vec3::new(0.0, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0))
        .with_limits(JointLimits::new(-1.5, 1.5)),  // Limit rotation
);
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-motor"><a class="header" href="#adding-motor">Adding Motor</a></h3>
<p>Make the door swing automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RevoluteJoint::new(JointAxisDirection::Y)
    .with_motor(0.0, 10.0, 5.0, 100.0)  // target_pos, target_vel, stiffness, damping
<span class="boring">}</span></code></pre></pre>
<h2 id="prismatic-joint-slider"><a class="header" href="#prismatic-joint-slider">Prismatic Joint (Slider)</a></h2>
<p>Slides along an axis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Drawer
let cabinet = spawn_static_entity(world);
let drawer = spawn_cube_at(world, Vec3::new(0.0, 0.0, 0.5));

create_prismatic_joint(
    world,
    cabinet,
    drawer,
    PrismaticJoint::new(JointAxisDirection::Z)  // Slide on Z axis
        .with_local_anchor1(Vec3::new(0.0, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.0, -0.5))
        .with_limits(JointLimits::new(0.0, 0.8)),  // Min/max extension
);
<span class="boring">}</span></code></pre></pre>
<h2 id="rope-joint"><a class="header" href="#rope-joint">Rope Joint</a></h2>
<p>Maximum distance constraint:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ceiling = spawn_static_entity(world);
let weight = spawn_sphere_at(world, Vec3::new(0.0, 0.0, 0.0));

create_rope_joint(
    world,
    ceiling,
    weight,
    RopeJoint::new(2.0)  // Max length
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="spring-joint"><a class="header" href="#spring-joint">Spring Joint</a></h2>
<p>Elastic connection:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let anchor = spawn_static_entity(world);
let bob = spawn_sphere_at(world, Vec3::new(0.0, -2.0, 0.0));

create_spring_joint(
    world,
    anchor,
    bob,
    SpringJoint::new(1.5, 50.0, 2.0)  // rest_length, stiffness, damping
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.2, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="joint-limits"><a class="header" href="#joint-limits">Joint Limits</a></h2>
<p>Constrain movement range:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rotation limits (radians)
RevoluteJoint::new(JointAxisDirection::Z)
    .with_limits(JointLimits::new(-1.57, 1.57))  // -90° to +90°

// Translation limits (meters)
PrismaticJoint::new(JointAxisDirection::X)
    .with_limits(JointLimits::new(-2.0, 2.0))
<span class="boring">}</span></code></pre></pre>
<h2 id="breaking-joints"><a class="header" href="#breaking-joints">Breaking Joints</a></h2>
<p>Joints can break under force:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(joint) = world.resources.physics.get_joint_mut(joint_handle) {
    joint.set_max_force(1000.0);  // Break if force exceeds this
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chain-example"><a class="header" href="#chain-example">Chain Example</a></h2>
<p>Create a chain of connected spheres:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_chain(world: &amp;mut World, start: Vec3, links: usize) {
    let mut previous = spawn_cube_at(world, start);

    for index in 0..links {
        let position = start - Vec3::new(0.0, (index + 1) as f32 * 0.5, 0.0);
        let link = spawn_sphere_at(world, position);

        create_spherical_joint(
            world,
            previous,
            link,
            SphericalJoint::new()
                .with_local_anchor1(Vec3::new(0.0, -0.2, 0.0))
                .with_local_anchor2(Vec3::new(0.0, 0.2, 0.0)),
        );

        previous = link;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interactive-door-example"><a class="header" href="#interactive-door-example">Interactive Door Example</a></h2>
<p>Complete door with momentum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_interactive_door(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let frame = spawn_cube_at(world, position);

    let door = spawn_cube_at(world, position + Vec3::new(0.5, 0.0, 0.0));

    // Lock vertical rotation
    if let Some(rb) = world.get_rigid_body(door) {
        if let Some(handle) = rb.handle {
            if let Some(body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
                body.lock_rotations(true, true);  // Only Y rotation allowed
            }
        }
    }

    create_revolute_joint(
        world,
        frame,
        door,
        RevoluteJoint::new(JointAxisDirection::Y)
            .with_local_anchor1(Vec3::new(0.05, 0.0, 0.0))
            .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0))
            .with_limits(JointLimits::new(-2.0, 2.0)),
    );

    door
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-animated-models"><a class="header" href="#loading-animated-models">Loading Animated Models</a></h1>
<p>Nightshade supports skeletal animation through glTF/GLB files.</p>
<h2 id="loading-an-animated-model"><a class="header" href="#loading-an-animated-model">Loading an Animated Model</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

const CHARACTER_GLB: &amp;[u8] = include_bytes!("../assets/character.glb");

fn load_character(world: &amp;mut World) -&gt; Option&lt;Entity&gt; {
    let result = import_gltf_from_bytes(CHARACTER_GLB).ok()?;

    // Register textures
    for (name, (rgba_data, width, height)) in result.textures {
        world.queue_command(WorldCommand::LoadTexture {
            name,
            rgba_data,
            width,
            height,
        });
    }

    // Register meshes
    for (name, mesh) in result.meshes {
        mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
    }

    // Spawn with animations and skins
    result.prefabs.first().map(|prefab| {
        spawn_prefab_with_animations(
            world,
            prefab,
            &amp;result.animations,
            Vec3::zeros(),
        )
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-data-structure"><a class="header" href="#animation-data-structure">Animation Data Structure</a></h2>
<p>Loaded animations contain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationClip {
    pub name: String,
    pub duration: f32,
    pub channels: Vec&lt;AnimationChannel&gt;,
}

pub struct AnimationChannel {
    pub target_node: usize,
    pub target_property: AnimationProperty,
    pub interpolation: Interpolation,
    pub times: Vec&lt;f32&gt;,
    pub values: Vec&lt;f32&gt;,
}

pub enum AnimationProperty {
    Translation,
    Rotation,
    Scale,
    MorphWeights,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering-animation-channels"><a class="header" href="#filtering-animation-channels">Filtering Animation Channels</a></h2>
<p>Remove unwanted channels (like root motion):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_animations(animations: &amp;[AnimationClip]) -&gt; Vec&lt;AnimationClip&gt; {
    let root_bone_indices: std::collections::HashSet&lt;usize&gt; = [0, 1, 2, 3].into();

    animations
        .iter()
        .map(|clip| AnimationClip {
            name: clip.name.clone(),
            duration: clip.duration,
            channels: clip
                .channels
                .iter()
                .filter(|channel| {
                    // Remove translation from all bones (prevent sliding)
                    if channel.target_property == AnimationProperty::Translation {
                        return false;
                    }
                    // Remove rotation from root bones
                    if root_bone_indices.contains(&amp;channel.target_node)
                        &amp;&amp; channel.target_property == AnimationProperty::Rotation
                    {
                        return false;
                    }
                    true
                })
                .cloned()
                .collect(),
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="storing-animation-indices"><a class="header" href="#storing-animation-indices">Storing Animation Indices</a></h2>
<p>Track which animations are which:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AnimationIndices {
    idle: Option&lt;usize&gt;,
    walk: Option&lt;usize&gt;,
    run: Option&lt;usize&gt;,
    jump: Option&lt;usize&gt;,
}

fn find_animation_indices(clips: &amp;[AnimationClip]) -&gt; AnimationIndices {
    let mut indices = AnimationIndices {
        idle: None,
        walk: None,
        run: None,
        jump: None,
    };

    for (index, clip) in clips.iter().enumerate() {
        let name = clip.name.to_lowercase();
        if name.contains("idle") {
            indices.idle = Some(index);
        } else if name.contains("walk") {
            indices.walk = Some(index);
        } else if name.contains("run") {
            indices.run = Some(index);
        } else if name.contains("jump") {
            indices.jump = Some(index);
        }
    }

    indices
}
<span class="boring">}</span></code></pre></pre>
<h2 id="skeleton-structure"><a class="header" href="#skeleton-structure">Skeleton Structure</a></h2>
<p>Skinned meshes have a skeleton:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Skin {
    pub joints: Vec&lt;Entity&gt;,
    pub inverse_bind_matrices: Vec&lt;Mat4&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>joints</code> array contains entities for each bone in the skeleton.</p>
<h2 id="attaching-objects-to-bones"><a class="header" href="#attaching-objects-to-bones">Attaching Objects to Bones</a></h2>
<p>Attach items to specific bones:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attach_to_bone(world: &amp;mut World, item: Entity, bone: Entity) {
    world.update_parent(item, Some(Parent(Some(bone))));

    if let Some(transform) = world.get_local_transform_mut(item) {
        transform.translation = Vec3::new(0.0, 0.1, 0.0);  // Local offset
        transform.scale = Vec3::new(1.0, 1.0, 1.0);
    }
}

// Example: Attach hat to head bone
fn attach_hat(world: &amp;mut World, character: Entity, hat: Entity) {
    // Find head bone (usually named "Head" or similar in the model)
    if let Some(skin) = world.get_skin(character) {
        for joint in &amp;skin.joints {
            if let Some(name) = world.get_name(*joint) {
                if name.0.contains("Head") {
                    attach_to_bone(world, hat, *joint);
                    return;
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="finding-bones-by-name"><a class="header" href="#finding-bones-by-name">Finding Bones by Name</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_bone_by_name(world: &amp;World, character: Entity, bone_name: &amp;str) -&gt; Option&lt;Entity&gt; {
    let skin = world.get_skin(character)?;

    for joint in &amp;skin.joints {
        if let Some(name) = world.get_name(*joint) {
            if name.0.contains(bone_name) {
                return Some(*joint);
            }
        }
    }
    None
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-animated-characters"><a class="header" href="#multiple-animated-characters">Multiple Animated Characters</a></h2>
<p>Load once, spawn many:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CharacterFactory {
    prefab: Prefab,
    animations: Vec&lt;AnimationClip&gt;,
}

impl CharacterFactory {
    fn new(bytes: &amp;[u8]) -&gt; Option&lt;Self&gt; {
        let result = import_gltf_from_bytes(bytes).ok()?;
        Some(Self {
            prefab: result.prefabs.into_iter().next()?,
            animations: result.animations,
        })
    }

    fn spawn(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        spawn_prefab_with_animations(
            world,
            &amp;self.prefab,
            &amp;self.animations,
            position,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-playback"><a class="header" href="#animation-playback">Animation Playback</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/dance">Dance</a></p>
</blockquote>
<p>Control animation playback through the <code>AnimationPlayer</code> component.</p>
<h2 id="animationplayer-component"><a class="header" href="#animationplayer-component">AnimationPlayer Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationPlayer {
    pub clips: Vec&lt;AnimationClip&gt;,
    pub current_clip: Option&lt;usize&gt;,
    pub time: f32,
    pub speed: f32,
    pub looping: bool,
    pub playing: bool,
    pub blend_from_clip: Option&lt;usize&gt;,
    pub blend_factor: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-playback"><a class="header" href="#basic-playback">Basic Playback</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_animation(world: &amp;mut World, entity: Entity, clip_index: usize) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.play(clip_index);
        player.looping = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="controlling-speed"><a class="header" href="#controlling-speed">Controlling Speed</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_animation_speed(world: &amp;mut World, entity: Entity, speed: f32) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.speed = speed;  // 1.0 = normal, 0.5 = half speed, 2.0 = double
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pausing-and-resuming"><a class="header" href="#pausing-and-resuming">Pausing and Resuming</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pause_animation(world: &amp;mut World, entity: Entity) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.pause();
    }
}

fn resume_animation(world: &amp;mut World, entity: Entity) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.resume();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="looping"><a class="header" href="#looping">Looping</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_looping(world: &amp;mut World, entity: Entity, looping: bool) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.looping = looping;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-animation-state"><a class="header" href="#checking-animation-state">Checking Animation State</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_animation_finished(world: &amp;World, entity: Entity) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        if !player.looping {
            if let Some(index) = player.current_clip {
                let clip = &amp;player.clips[index];
                return player.time &gt;= clip.duration;
            }
        }
    }
    false
}

fn get_animation_progress(world: &amp;World, entity: Entity) -&gt; f32 {
    if let Some(player) = world.get_animation_player(entity) {
        if let Some(index) = player.current_clip {
            let clip = &amp;player.clips[index];
            return player.time / clip.duration;
        }
    }
    0.0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-by-name"><a class="header" href="#animation-by-name">Animation by Name</a></h2>
<p>Find and play animations by name:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_animation_by_name(world: &amp;mut World, entity: Entity, name: &amp;str) -&gt; bool {
    if let Some(player) = world.get_animation_player_mut(entity) {
        for (index, clip) in player.clips.iter().enumerate() {
            if clip.name.to_lowercase().contains(&amp;name.to_lowercase()) {
                player.play(index);
                return true;
            }
        }
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-based-animation"><a class="header" href="#state-based-animation">State-Based Animation</a></h2>
<p>Common pattern for character animation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq)]
enum MovementState {
    Idle,
    Walking,
    Running,
    Jumping,
}

fn update_character_animation(
    world: &amp;mut World,
    entity: Entity,
    state: MovementState,
    indices: &amp;AnimationIndices,
    current: &amp;mut Option&lt;usize&gt;,
) {
    let target = match state {
        MovementState::Idle =&gt; indices.idle,
        MovementState::Walking =&gt; indices.walk,
        MovementState::Running =&gt; indices.run,
        MovementState::Jumping =&gt; indices.jump,
    };

    // Only change if different
    if target != *current {
        if let Some(index) = target {
            if let Some(player) = world.get_animation_player_mut(entity) {
                player.blend_to(index, 0.2);  // Smooth transition
                *current = Some(index);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="speed-based-on-movement"><a class="header" href="#speed-based-on-movement">Speed Based on Movement</a></h2>
<p>Match animation speed to movement speed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sync_animation_to_movement(world: &amp;mut World, entity: Entity, velocity: f32) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        // Assuming walk animation matches 3 m/s
        let base_speed = 3.0;
        player.speed = (velocity / base_speed).clamp(0.5, 2.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="one-shot-animations"><a class="header" href="#one-shot-animations">One-Shot Animations</a></h2>
<p>Play an animation once without looping:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_once(world: &amp;mut World, entity: Entity, clip_index: usize) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.play(clip_index);
        player.looping = false;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-events"><a class="header" href="#animation-events">Animation Events</a></h2>
<p>Trigger events at specific times:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_animation_events(world: &amp;World, entity: Entity, event_time: f32) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        let prev_time = player.time - world.resources.window.timing.delta_time * player.speed;
        // Check if we crossed the event time this frame
        prev_time &lt; event_time &amp;&amp; player.time &gt;= event_time
    } else {
        false
    }
}

// Usage: Play footstep sound at specific animation times
fn footstep_system(world: &amp;mut World, character: Entity) {
    if check_animation_events(world, character, 0.3) {
        play_sound(world, "footstep_left");
    }
    if check_animation_events(world, character, 0.8) {
        play_sound(world, "footstep_right");
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blending--transitions"><a class="header" href="#blending--transitions">Blending &amp; Transitions</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/dance">Dance</a> | <a href="https://matthewberger.dev/nightshade/morph">Morph Targets</a></p>
</blockquote>
<p>Smooth transitions between animations using cross-fading.</p>
<h2 id="cross-fade-transition"><a class="header" href="#cross-fade-transition">Cross-Fade Transition</a></h2>
<p>The <code>blend_to</code> method smoothly transitions between animations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(player) = world.get_animation_player_mut(entity) {
    player.blend_to(new_animation_index, 0.2);  // 0.2 second transition
}
<span class="boring">}</span></code></pre></pre>
<h2 id="blend-duration"><a class="header" href="#blend-duration">Blend Duration</a></h2>
<p>Choose appropriate durations:</p>
<div class="table-wrapper"><table><thead><tr><th>Transition</th><th>Duration</th><th>Notes</th></tr></thead><tbody>
<tr><td>Idle → Walk</td><td>0.2s</td><td>Natural start</td></tr>
<tr><td>Walk → Run</td><td>0.15s</td><td>Quick acceleration</td></tr>
<tr><td>Run → Idle</td><td>0.3s</td><td>Gradual stop</td></tr>
<tr><td>Any → Jump</td><td>0.1s</td><td>Responsive</td></tr>
<tr><td>Attack</td><td>0.05s</td><td>Immediate</td></tr>
</tbody></table>
</div>
<h2 id="movement-state-machine"><a class="header" href="#movement-state-machine">Movement State Machine</a></h2>
<p>Manage animation states cleanly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq)]
enum CharacterState {
    Idle,
    Walking,
    Running,
    Jumping,
    Falling,
    Landing,
}

struct AnimationController {
    state: CharacterState,
    current_animation: Option&lt;usize&gt;,
    indices: AnimationIndices,
}

impl AnimationController {
    fn update(&amp;mut self, world: &amp;mut World, entity: Entity, new_state: CharacterState) {
        if self.state == new_state {
            return;
        }

        let blend_time = self.get_blend_time(self.state, new_state);
        let target_anim = self.get_animation_for_state(new_state);

        if let Some(index) = target_anim {
            if let Some(player) = world.get_animation_player_mut(entity) {
                player.blend_to(index, blend_time);
                self.current_animation = Some(index);
            }
        }

        self.state = new_state;
    }

    fn get_blend_time(&amp;self, from: CharacterState, to: CharacterState) -&gt; f32 {
        match (from, to) {
            (CharacterState::Idle, CharacterState::Walking) =&gt; 0.2,
            (CharacterState::Walking, CharacterState::Running) =&gt; 0.15,
            (CharacterState::Running, CharacterState::Idle) =&gt; 0.3,
            (_, CharacterState::Jumping) =&gt; 0.1,
            _ =&gt; 0.2,
        }
    }

    fn get_animation_for_state(&amp;self, state: CharacterState) -&gt; Option&lt;usize&gt; {
        match state {
            CharacterState::Idle =&gt; self.indices.idle,
            CharacterState::Walking =&gt; self.indices.walk,
            CharacterState::Running =&gt; self.indices.run,
            CharacterState::Jumping =&gt; self.indices.jump,
            CharacterState::Falling =&gt; self.indices.jump,  // Reuse jump
            CharacterState::Landing =&gt; self.indices.idle,   // Brief idle
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="speed-based-blending"><a class="header" href="#speed-based-blending">Speed-Based Blending</a></h2>
<p>Blend between walk and run based on speed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_locomotion(world: &amp;mut World, entity: Entity, speed: f32, indices: &amp;AnimationIndices) {
    let walk_threshold = 2.0;
    let run_threshold = 5.0;

    let state = if speed &lt; 0.1 {
        MovementState::Idle
    } else if speed &lt; walk_threshold {
        MovementState::Walking
    } else {
        MovementState::Running
    };

    let target_anim = match state {
        MovementState::Idle =&gt; indices.idle,
        MovementState::Walking =&gt; indices.walk,
        MovementState::Running =&gt; indices.run,
    };

    if let Some(index) = target_anim {
        if let Some(player) = world.get_animation_player_mut(entity) {
            if player.current_clip != Some(index) {
                player.blend_to(index, 0.2);
            }

            // Adjust playback speed
            player.speed = match state {
                MovementState::Idle =&gt; 1.0,
                MovementState::Walking =&gt; speed / walk_threshold,
                MovementState::Running =&gt; speed / run_threshold,
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interrupt-handling"><a class="header" href="#interrupt-handling">Interrupt Handling</a></h2>
<p>Handle animation interrupts gracefully:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_attack(world: &amp;mut World, entity: Entity, attack_anim: usize, current_state: &amp;mut CharacterState) -&gt; bool {
    if let Some(player) = world.get_animation_player_mut(entity) {
        // Quick blend to attack
        player.blend_to(attack_anim, 0.05);
        player.looping = false;
        *current_state = CharacterState::Attacking;
        return true;
    }
    false
}

fn check_attack_finished(world: &amp;World, entity: Entity) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        if !player.looping {
            if let Some(index) = player.current_clip {
                let clip = &amp;player.clips[index];
                return player.time &gt;= clip.duration * 0.9;
            }
        }
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<h2 id="additive-blending"><a class="header" href="#additive-blending">Additive Blending</a></h2>
<p>Layer animations (e.g., breathing on top of idle):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: This is a conceptual example - actual implementation depends on engine support
struct LayeredAnimation {
    base_animation: usize,
    additive_animations: Vec&lt;(usize, f32)&gt;,  // (index, weight)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="root-motion"><a class="header" href="#root-motion">Root Motion</a></h2>
<p>When animations include movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_root_motion(world: &amp;mut World, entity: Entity) {
    let Some(player) = world.get_animation_player(entity) else { return };

    let Some(current_index) = player.current_clip else { return };
    let clip = &amp;player.clips[current_index];
    // Extract root bone translation from animation
    // Apply to character controller

    // Note: Often you'll want to remove root motion from animations
    // and drive movement from game code instead
}
<span class="boring">}</span></code></pre></pre>
<h2 id="transition-rules"><a class="header" href="#transition-rules">Transition Rules</a></h2>
<p>Define clear rules for when transitions can occur:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn can_transition(from: CharacterState, to: CharacterState) -&gt; bool {
    match (from, to) {
        // Can always go to these states
        (_, CharacterState::Idle) =&gt; true,
        (_, CharacterState::Falling) =&gt; true,

        // Can't interrupt attacks
        (CharacterState::Attacking, _) =&gt; false,

        // Can only jump from ground
        (CharacterState::Falling, CharacterState::Jumping) =&gt; false,
        (CharacterState::Jumping, CharacterState::Jumping) =&gt; false,

        _ =&gt; true,
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-system"><a class="header" href="#audio-system">Audio System</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/audio">Audio</a></p>
</blockquote>
<p>Nightshade uses Kira for audio playback, supporting both sound effects and music.</p>
<h2 id="enabling-audio"><a class="header" href="#enabling-audio">Enabling Audio</a></h2>
<p>Audio requires the <code>audio</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "audio"] }
</code></pre>
<h2 id="loading-sounds"><a class="header" href="#loading-sounds">Loading Sounds</a></h2>
<p>Load sounds at initialization using <code>world.resources.audio.load_sound</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::audio::*;

const EXPLOSION_WAV: &amp;[u8] = include_bytes!("../assets/sounds/explosion.wav");
const MUSIC_OGG: &amp;[u8] = include_bytes!("../assets/sounds/music.ogg");

fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.audio.load_sound("explosion", EXPLOSION_WAV);
    world.resources.audio.load_sound("music", MUSIC_OGG);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="playing-sounds"><a class="header" href="#playing-sounds">Playing Sounds</a></h2>
<h3 id="basic-playback-1"><a class="header" href="#basic-playback-1">Basic Playback</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle = world.resources.audio.load_sound("explosion", EXPLOSION_WAV);
world.resources.audio.play(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-source-component"><a class="header" href="#audio-source-component">Audio Source Component</a></h2>
<p>Attach sounds to entities:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ENGINE_LOOP: &amp;[u8] = include_bytes!("../assets/sounds/engine_loop.wav");

let entity = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];

world.set_audio_source(entity, AudioSource::new(ENGINE_LOOP)
    .with_spatial(true)
    .with_looping(true)
    .playing(),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-listener"><a class="header" href="#audio-listener">Audio Listener</a></h2>
<p>Mark the entity that "hears" sounds (usually the camera):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_audio_listener(camera_entity, AudioListener);
<span class="boring">}</span></code></pre></pre>
<h2 id="sound-variations"><a class="header" href="#sound-variations">Sound Variations</a></h2>
<p>Play random variations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOOTSTEP_1: &amp;[u8] = include_bytes!("../assets/sounds/footstep_1.wav");
const FOOTSTEP_2: &amp;[u8] = include_bytes!("../assets/sounds/footstep_2.wav");
const FOOTSTEP_3: &amp;[u8] = include_bytes!("../assets/sounds/footstep_3.wav");
const FOOTSTEP_4: &amp;[u8] = include_bytes!("../assets/sounds/footstep_4.wav");

fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.audio.load_sound("footstep_1", FOOTSTEP_1);
    world.resources.audio.load_sound("footstep_2", FOOTSTEP_2);
    world.resources.audio.load_sound("footstep_3", FOOTSTEP_3);
    world.resources.audio.load_sound("footstep_4", FOOTSTEP_4);
}

fn play_footstep(world: &amp;mut World) {
    let sounds = ["footstep_1", "footstep_2", "footstep_3", "footstep_4"];
    let index = rand::random::&lt;usize&gt;() % sounds.len();
    let handle = world.resources.audio.load_sound(sounds[index], &amp;[]);
    world.resources.audio.play(handle);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="triggering-sounds-on-events"><a class="header" href="#triggering-sounds-on-events">Triggering Sounds on Events</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    for event in world.resources.physics.collision_events() {
        if event.started {
            let handle = world.resources.audio.load_sound("impact", IMPACT_WAV);
            world.resources.audio.play(handle);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="stopping-sounds"><a class="header" href="#stopping-sounds">Stopping Sounds</a></h2>
<p>Stop a sound attached to an entity:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.audio.stop_sound(entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Extension</th><th>Notes</th></tr></thead><tbody>
<tr><td>WAV</td><td>.wav</td><td>Uncompressed, fast loading</td></tr>
<tr><td>OGG</td><td>.ogg</td><td>Compressed, good for music</td></tr>
<tr><td>MP3</td><td>.mp3</td><td>Compressed, widely supported</td></tr>
<tr><td>FLAC</td><td>.flac</td><td>Lossless compression</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h1>
<p>3D positional audio creates immersive soundscapes where sounds have position and direction.</p>
<h2 id="audio-listener-1"><a class="header" href="#audio-listener-1">Audio Listener</a></h2>
<p>The listener is the "ear" in the scene, represented as an entity with the <code>AUDIO_LISTENER</code> component. Usually attached to the camera:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(world, Vec3::new(0.0, 2.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    world.set_audio_listener(camera, AudioListener);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spatial-audio-source"><a class="header" href="#spatial-audio-source">Spatial Audio Source</a></h2>
<p>Attach sounds to entities for positional audio:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const AMBIENT_LOOP: &amp;[u8] = include_bytes!("../assets/sounds/ambient.wav");

fn spawn_ambient_sound(world: &amp;mut World, position: Vec3, data: &amp;[u8]) -&gt; Entity {
    let entity = world.spawn_entities(
        AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM,
        1
    )[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    world.set_audio_source(entity, AudioSource::new(data)
        .with_spatial(true)
        .with_looping(true)
        .playing(),
    );

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="distance-attenuation"><a class="header" href="#distance-attenuation">Distance Attenuation</a></h2>
<p>Sounds get quieter with distance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WATERFALL: &amp;[u8] = include_bytes!("../assets/sounds/waterfall.wav");

world.set_audio_source(entity, AudioSource::new(WATERFALL)
    .with_spatial(true)
    .with_looping(true)
    .playing(),
);
<span class="boring">}</span></code></pre></pre>
<h3 id="rolloff-modes"><a class="header" href="#rolloff-modes">Rolloff Modes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Linear</code></td><td>Linear falloff between min/max distance</td></tr>
<tr><td><code>Inverse</code></td><td>Realistic 1/distance falloff</td></tr>
<tr><td><code>Exponential</code></td><td>Steep falloff, good for small sounds</td></tr>
</tbody></table>
</div>
<h2 id="moving-sound-sources"><a class="header" href="#moving-sound-sources">Moving Sound Sources</a></h2>
<p>Sounds automatically track their entity's position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_helicopter(world: &amp;mut World, helicopter: Entity, dt: f32) {
    if let Some(transform) = world.get_local_transform_mut(helicopter) {
        transform.translation.x += 10.0 * dt;
    }
    world.mark_local_transform_dirty(helicopter);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="non-spatial-2d-audio"><a class="header" href="#non-spatial-2d-audio">Non-Spatial (2D) Audio</a></h2>
<p>UI sounds and music should not be spatial:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const UI_CLICK: &amp;[u8] = include_bytes!("../assets/sounds/ui_click.wav");

world.set_audio_source(entity, AudioSource::new(UI_CLICK)
    .playing(),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="directional-audio-sources"><a class="header" href="#directional-audio-sources">Directional Audio Sources</a></h2>
<p>Some sounds are directional (like a speaker):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ANNOUNCEMENT: &amp;[u8] = include_bytes!("../assets/sounds/announcement.wav");

world.set_audio_source(entity, AudioSource::new(ANNOUNCEMENT)
    .with_spatial(true)
    .playing(),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-occlusion"><a class="header" href="#audio-occlusion">Audio Occlusion</a></h2>
<p>Simple occlusion with raycast:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_audio_occlusion(world: &amp;mut World, source: Entity, listener: Entity) {
    let source_pos = world.get_global_transform(source).map(|t| t.translation());
    let listener_pos = world.get_global_transform(listener).map(|t| t.translation());

    if let (Some(src), Some(lst)) = (source_pos, listener_pos) {
        let direction = (lst - src).normalize();
        let distance = (lst - src).magnitude();

        if let Some(_hit) = raycast(world, src, direction, distance) {
            if let Some(audio) = world.get_audio_source_mut(source) {
                audio.volume = 0.3;
            }
        } else {
            if let Some(audio) = world.get_audio_source_mut(source) {
                audio.volume = 1.0;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="ambient-soundscape"><a class="header" href="#ambient-soundscape">Ambient Soundscape</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOREST_AMBIENT: &amp;[u8] = include_bytes!("../assets/sounds/forest_ambient.wav");
const BIRD_CHIRP: &amp;[u8] = include_bytes!("../assets/sounds/bird_chirp.wav");
const BIRD_SONG: &amp;[u8] = include_bytes!("../assets/sounds/bird_song.wav");
const STREAM: &amp;[u8] = include_bytes!("../assets/sounds/stream.wav");

fn setup_forest_ambience(world: &amp;mut World) {
    spawn_ambient_sound(world, Vec3::zeros(), FOREST_AMBIENT);

    spawn_ambient_sound(world, Vec3::new(10.0, 5.0, 0.0), BIRD_CHIRP);
    spawn_ambient_sound(world, Vec3::new(-8.0, 4.0, 5.0), BIRD_SONG);

    spawn_ambient_sound(world, Vec3::new(0.0, 0.0, 20.0), STREAM);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="footstep-system"><a class="header" href="#footstep-system">Footstep System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOOTSTEP: &amp;[u8] = include_bytes!("../assets/sounds/footstep.wav");

fn play_footstep_at_position(world: &amp;mut World, position: Vec3) {
    let entity = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    world.set_audio_source(entity, AudioSource::new(FOOTSTEP)
        .with_spatial(true)
        .playing(),
    );
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egui-integration"><a class="header" href="#egui-integration">egui Integration</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/ui">UI</a></p>
</blockquote>
<p>Nightshade integrates <a href="https://github.com/emilk/egui">egui</a>, a popular immediate-mode GUI library for Rust. Use it for debug interfaces, tools, and in-game menus.</p>
<h2 id="enabling-egui"><a class="header" href="#enabling-egui">Enabling egui</a></h2>
<p>Add the <code>egui</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "wgpu", "egui"] }
</code></pre>
<h2 id="the-ui-method"><a class="header" href="#the-ui-method">The ui() Method</a></h2>
<p>Implement the <code>ui()</code> method on your <code>State</code> to render egui:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
        egui::Window::new("Debug")
            .show(ctx, |ui| {
                ui.label("Hello, World!");
            });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-widgets"><a class="header" href="#common-widgets">Common Widgets</a></h2>
<h3 id="labels"><a class="header" href="#labels">Labels</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.label("Static text");
ui.label(format!("FPS: {:.0}", world.resources.window.timing.frames_per_second));
ui.colored_label(egui::Color32::RED, "Warning!");
<span class="boring">}</span></code></pre></pre>
<h3 id="buttons"><a class="header" href="#buttons">Buttons</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ui.button("Click me").clicked() {
    self.counter += 1;
}

if ui.button("Spawn Enemy").clicked() {
    spawn_enemy(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sliders"><a class="header" href="#sliders">Sliders</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.add(egui::Slider::new(&amp;mut self.speed, 0.0..=10.0).text("Speed"));

ui.add(egui::Slider::new(&amp;mut world.resources.graphics.bloom_intensity, 0.0..=2.0)
    .text("Bloom Intensity"));
<span class="boring">}</span></code></pre></pre>
<h3 id="checkboxes"><a class="header" href="#checkboxes">Checkboxes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.checkbox(&amp;mut self.paused, "Paused");

ui.checkbox(&amp;mut world.resources.graphics.bloom_enabled, "Bloom");
ui.checkbox(&amp;mut world.resources.graphics.ssao_enabled, "SSAO");
<span class="boring">}</span></code></pre></pre>
<h3 id="text-input"><a class="header" href="#text-input">Text Input</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.text_edit_singleline(&amp;mut self.player_name);

ui.text_edit_multiline(&amp;mut self.notes);
<span class="boring">}</span></code></pre></pre>
<h3 id="combo-boxes"><a class="header" href="#combo-boxes">Combo Boxes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::ComboBox::from_label("Difficulty")
    .selected_text(format!("{:?}", self.difficulty))
    .show_ui(ui, |ui| {
        ui.selectable_value(&amp;mut self.difficulty, Difficulty::Easy, "Easy");
        ui.selectable_value(&amp;mut self.difficulty, Difficulty::Normal, "Normal");
        ui.selectable_value(&amp;mut self.difficulty, Difficulty::Hard, "Hard");
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="color-picker"><a class="header" href="#color-picker">Color Picker</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.color_edit_button_rgb(&amp;mut self.light_color);

let mut color = [
    world.resources.graphics.ambient_color.x,
    world.resources.graphics.ambient_color.y,
    world.resources.graphics.ambient_color.z,
];
if ui.color_edit_button_rgb(&amp;mut color).changed() {
    world.resources.graphics.ambient_color = Vec3::new(color[0], color[1], color[2]);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="layouts"><a class="header" href="#layouts">Layouts</a></h2>
<h3 id="horizontal"><a class="header" href="#horizontal">Horizontal</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.horizontal(|ui| {
    ui.label("Name:");
    ui.text_edit_singleline(&amp;mut self.name);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="vertical"><a class="header" href="#vertical">Vertical</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.vertical(|ui| {
    ui.label("Line 1");
    ui.label("Line 2");
    ui.label("Line 3");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="columns"><a class="header" href="#columns">Columns</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.columns(2, |columns| {
    columns[0].label("Left column");
    columns[1].label("Right column");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="spacing"><a class="header" href="#spacing">Spacing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.add_space(10.0);
ui.separator();
<span class="boring">}</span></code></pre></pre>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<h3 id="basic-window"><a class="header" href="#basic-window">Basic Window</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::Window::new("Settings")
    .show(ctx, |ui| {
        ui.label("Settings content");
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="configurable-window"><a class="header" href="#configurable-window">Configurable Window</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::Window::new("Inspector")
    .resizable(true)
    .collapsible(true)
    .default_pos([10.0, 10.0])
    .default_size([300.0, 400.0])
    .show(ctx, |ui| {
        // Content
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-window"><a class="header" href="#conditional-window">Conditional Window</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.show_inventory {
    egui::Window::new("Inventory")
        .open(&amp;mut self.show_inventory)
        .show(ctx, |ui| {
            // Inventory content
        });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="panels"><a class="header" href="#panels">Panels</a></h2>
<h3 id="side-panel"><a class="header" href="#side-panel">Side Panel</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::SidePanel::left("left_panel")
    .default_width(200.0)
    .show(ctx, |ui| {
        ui.heading("Tools");
        if ui.button("Select").clicked() {
            self.tool = Tool::Select;
        }
        if ui.button("Move").clicked() {
            self.tool = Tool::Move;
        }
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="topbottom-panel"><a class="header" href="#topbottom-panel">Top/Bottom Panel</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::TopBottomPanel::top("menu_bar").show(ctx, |ui| {
    egui::menu::bar(ui, |ui| {
        ui.menu_button("File", |ui| {
            if ui.button("New").clicked() {
                self.new_scene();
            }
            if ui.button("Open").clicked() {
                self.open_scene();
            }
            if ui.button("Save").clicked() {
                self.save_scene();
            }
        });
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="central-panel"><a class="header" href="#central-panel">Central Panel</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>egui::CentralPanel::default().show(ctx, |ui| {
    ui.heading("Main Content Area");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-ui-example"><a class="header" href="#debug-ui-example">Debug UI Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
    egui::Window::new("Debug Info").show(ctx, |ui| {
        ui.heading("Performance");
        ui.label(format!("FPS: {:.0}", world.resources.window.timing.frames_per_second));
        ui.label(format!("Frame Time: {:.2}ms", world.resources.window.timing.delta_time * 1000.0));
        ui.label(format!("Entities: {}", world.query_entities(RENDER_MESH).count()));

        ui.separator();

        ui.heading("Graphics");
        ui.checkbox(&amp;mut world.resources.graphics.bloom_enabled, "Bloom");
        ui.checkbox(&amp;mut world.resources.graphics.ssao_enabled, "SSAO");
        ui.add(egui::Slider::new(&amp;mut world.resources.graphics.bloom_intensity, 0.0..=2.0).text("Bloom Intensity"));

        ui.separator();

        ui.heading("Player");
        if let Some(transform) = world.get_local_transform(self.player) {
            ui.label(format!("Position: ({:.1}, {:.1}, {:.1})",
                transform.translation.x,
                transform.translation.y,
                transform.translation.z
            ));
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h2>
<p>Check if egui wants keyboard/mouse input in the <code>ui()</code> method, then store the state for use in <code>run_systems()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
        self.ui_wants_keyboard = ctx.wants_keyboard_input();
        self.ui_wants_pointer = ctx.wants_pointer_input();

        egui::Window::new("Debug").show(ctx, |ui| {
            ui.label("Hello, World!");
        });
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        if !self.ui_wants_keyboard {
            handle_game_keyboard(world);
        }

        if !self.ui_wants_pointer {
            handle_game_mouse(world);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or check input state directly in the <code>ui()</code> method to control behavior immediately:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
    egui::Window::new("Debug").show(ctx, |ui| {
        ui.label("Hello, World!");
    });

    if !ctx.wants_keyboard_input() {
        handle_game_keyboard(world);
    }

    if !ctx.wants_pointer_input() {
        handle_game_mouse(world);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="styling"><a class="header" href="#styling">Styling</a></h2>
<h3 id="dark-theme-default"><a class="header" href="#dark-theme-default">Dark Theme (Default)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.set_visuals(egui::Visuals::dark());
<span class="boring">}</span></code></pre></pre>
<h3 id="light-theme"><a class="header" href="#light-theme">Light Theme</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.set_visuals(egui::Visuals::light());
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-colors"><a class="header" href="#custom-colors">Custom Colors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut visuals = egui::Visuals::dark();
visuals.widgets.active.bg_fill = egui::Color32::from_rgb(60, 60, 120);
ctx.set_visuals(visuals);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Keep debug UI toggleable</strong>: Add a key to show/hide debug windows</li>
<li><strong>Group related settings</strong>: Use collapsing headers and separators</li>
<li><strong>Show real-time data</strong>: FPS, entity counts, memory usage</li>
<li><strong>Provide quick actions</strong>: Spawn entities, reload assets, reset state</li>
<li><strong>Don't block gameplay</strong>: Check <code>wants_keyboard_input()</code> before processing game input</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosaic-framework"><a class="header" href="#mosaic-framework">Mosaic Framework</a></h1>
<p>The <code>mosaic</code> feature provides a multi-pane desktop application framework built on <code>egui_tiles</code>. It handles dockable tile-based layouts, serializable widgets, theming, modals, notifications, and more.</p>
<h2 id="enabling-mosaic"><a class="header" href="#enabling-mosaic">Enabling Mosaic</a></h2>
<pre><code class="language-toml">nightshade = { git = "...", features = ["mosaic"] }
</code></pre>
<p>The <code>mosaic</code> feature requires <code>egui</code> (pulled in automatically).</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Widget&lt;C, M&gt;</code> trait</td><td>Implement for each widget type - title, ui, lifecycle hooks, closability, camera requirements, catalog</td></tr>
<tr><td><code>Mosaic&lt;W, C, M&gt;</code></td><td>Manages the tile tree, rendering, widget lifecycle, modals, layout persistence, messaging, and tree walking</td></tr>
<tr><td><code>MosaicConfig</code></td><td>Configurable behavior - tab bar height, gap width, closability, add button visibility</td></tr>
<tr><td><code>TileBehavior&lt;W, C, M&gt;</code></td><td>Implements <code>egui_tiles::Behavior</code> with closable tabs, drag-and-drop, and an add-widget popup with search</td></tr>
<tr><td><code>ViewportWidget</code></td><td>Built-in 3D viewport with camera rendering, selection, and multi-camera selector</td></tr>
<tr><td><code>WidgetContext&lt;C, M&gt;</code></td><td>Passed to widgets during rendering with world access, modal service, viewport state, app context, and message sending</td></tr>
<tr><td><code>Modals</code></td><td>Modal dialog service for confirm and text input dialogs</td></tr>
<tr><td><code>Pane&lt;W&gt;</code></td><td>Wraps a widget instance for the tile tree</td></tr>
</tbody></table>
</div>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="the-widget-trait"><a class="header" href="#the-widget-trait">The Widget Trait</a></h3>
<p>Every pane in a mosaic layout implements the <code>Widget</code> trait. Widgets must be <code>Clone + serde::Serialize + serde::Deserialize + 'static</code> so layouts can be saved and restored.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;
use nightshade::mosaic::{Widget, WidgetContext, WidgetEntry, Pane, ViewportWidget};

#[derive(Clone, serde::Serialize, serde::Deserialize)]
enum AppWidget {
    Viewport(ViewportWidget),
    Inspector(InspectorWidget),
}

impl Widget for AppWidget {
    fn title(&amp;self) -&gt; String {
        match self {
            AppWidget::Viewport(v) =&gt; v.title(),
            AppWidget::Inspector(_) =&gt; "Inspector".to_string(),
        }
    }

    fn ui(&amp;mut self, ui: &amp;mut egui::Ui, context: &amp;mut WidgetContext) {
        match self {
            AppWidget::Viewport(v) =&gt; v.ui(ui, context),
            AppWidget::Inspector(v) =&gt; v.ui(ui, context),
        }
    }

    fn catalog() -&gt; Vec&lt;WidgetEntry&lt;Self&gt;&gt; {
        vec![
            WidgetEntry {
                name: "Viewport".to_string(),
                create: || AppWidget::Viewport(ViewportWidget::default()),
            },
            WidgetEntry {
                name: "Inspector".to_string(),
                create: || AppWidget::Inspector(InspectorWidget),
            },
        ]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>catalog()</code> method defines the list of widgets available in the "+" add-widget popup.</p>
<p>Full trait definition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Widget&lt;C = (), M = ()&gt;: Clone + Serialize + DeserializeOwned + 'static {
    fn title(&amp;self) -&gt; String;
    fn ui(&amp;mut self, ui: &amp;mut egui::Ui, context: &amp;mut WidgetContext&lt;C, M&gt;);

    fn on_add(&amp;mut self, _context: &amp;mut WidgetContext&lt;C, M&gt;) {}
    fn on_remove(&amp;mut self, _context: &amp;mut WidgetContext&lt;C, M&gt;) {}
    fn closable(&amp;self) -&gt; bool { true }
    fn required_camera(&amp;self, _cached_cameras: &amp;[Entity]) -&gt; Option&lt;Entity&gt; { None }

    fn catalog() -&gt; Vec&lt;WidgetEntry&lt;Self&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-mosaic-struct"><a class="header" href="#the-mosaic-struct">The Mosaic Struct</a></h3>
<p><code>Mosaic&lt;W, C, M&gt;</code> manages a tile tree of widgets. The three type parameters are:</p>
<ul>
<li><code>W</code> - your widget enum (implements <code>Widget&lt;C, M&gt;</code>)</li>
<li><code>C</code> - shared application context passed to all widgets (default <code>()</code>)</li>
<li><code>M</code> - message type for inter-widget communication (default <code>()</code>)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::Mosaic;

struct MyApp {
    mosaic: Mosaic&lt;AppWidget&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Construction:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Mosaic::new()                              // Empty mosaic
Mosaic::with_panes(vec![...])              // Single tab group with panes
Mosaic::with_tree(tree)                    // Custom egui_tiles::Tree
Mosaic::from_window_layout(layout)         // From a saved WindowLayout
mosaic.with_config(config)                 // Builder: set MosaicConfig
mosaic.with_title(title)                   // Builder: set window title
<span class="boring">}</span></code></pre></pre>
<p>Create with initial panes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mosaic = Mosaic::with_panes(vec![
    AppWidget::Viewport(ViewportWidget::default()),
    AppWidget::Inspector(InspectorWidget),
]);
<span class="boring">}</span></code></pre></pre>
<p>Or with an explicit <code>egui_tiles::Tree</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tiles = egui_tiles::Tiles::default();
let viewport = tiles.insert_pane(Pane::new(AppWidget::Viewport(ViewportWidget::default())));
let inspector = tiles.insert_pane(Pane::new(AppWidget::Inspector(InspectorWidget)));
let root = tiles.insert_tab_tile(vec![viewport, inspector]);
let tree = egui_tiles::Tree::new("my_tree", root, tiles);
let mosaic = Mosaic::with_tree(tree);
<span class="boring">}</span></code></pre></pre>
<h3 id="rendering-2"><a class="header" href="#rendering-2">Rendering</a></h3>
<p>Call <code>mosaic.show()</code> inside your <code>State::ui()</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyApp {
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
        self.mosaic.show(world, ctx, &amp;mut ());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For rendering inside a specific <code>egui::Ui</code> region instead of the full window, use <code>show_inside</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.mosaic.show_inside(world, ui, &amp;mut ());
<span class="boring">}</span></code></pre></pre>
<h3 id="widgetcontext"><a class="header" href="#widgetcontext">WidgetContext</a></h3>
<p>Every widget receives a <code>WidgetContext</code> in its <code>ui()</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.world()                            // &amp;World
context.world_mut()                        // &amp;mut World
context.world_and_app()                    // (&amp;mut World, &amp;mut C)
context.world_app_modals()                 // (&amp;mut World, &amp;mut C, &amp;mut Modals)
context.send(message)                      // Send an M message to the app
context.receive()                          // Receive messages sent to this widget
context.has_incoming()                     // Check if there are pending messages
context.viewport_textures                  // Rendered viewport textures
context.current_tile_id                    // This widget's tile ID
context.selected_viewport_tile             // Currently selected viewport
context.modals                             // &amp;mut Modals for showing dialogs
context.app                                // &amp;mut C application context
context.window_index                       // Optional window index
context.is_active_window                   // Whether this is the active window
context.cached_cameras                     // &amp;[Entity] of all camera entities
<span class="boring">}</span></code></pre></pre>
<h2 id="application-context-and-messages"><a class="header" href="#application-context-and-messages">Application Context and Messages</a></h2>
<p>For non-trivial apps, use the context and message type parameters to share state and communicate between widgets and the app.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AppContext {
    selected_entity: Option&lt;Entity&gt;,
    fps_counter: FpsCounter,
}

enum AppMessage {
    EntitySelected(Entity),
    Log(String),
}

struct MyApp {
    mosaic: Mosaic&lt;AppWidget, AppContext, AppMessage&gt;,
    context: AppContext,
}

impl State for MyApp {
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
        self.mosaic.show(world, ctx, &amp;mut self.context);

        for message in self.mosaic.drain_messages() {
            match message {
                AppMessage::EntitySelected(entity) =&gt; {
                    self.context.selected_entity = Some(entity);
                }
                AppMessage::Log(text) =&gt; {
                    // ...
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="targeted-messaging"><a class="header" href="#targeted-messaging">Targeted Messaging</a></h3>
<p>Send messages to specific widgets or broadcast to all:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.send_to(tile_id, AppMessage::Refresh);
mosaic.broadcast(AppMessage::ThemeChanged);
mosaic.send_matching(|w| matches!(w, AppWidget::Log(_)), AppMessage::NewEntry);
<span class="boring">}</span></code></pre></pre>
<p>Widgets receive targeted messages via <code>context.receive()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, ui: &amp;mut egui::Ui, context: &amp;mut WidgetContext&lt;AppContext, AppMessage&gt;) {
    for message in context.receive() {
        match message {
            AppMessage::Refresh =&gt; { /* handle */ }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-viewportwidget"><a class="header" href="#built-in-viewportwidget">Built-in ViewportWidget</a></h2>
<p><code>ViewportWidget</code> renders a camera's output into a pane. It supports camera selection when multiple cameras exist, viewport selection highlighting, and automatic active camera management.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::ViewportWidget;

let viewport = ViewportWidget { camera_index: 0 };
<span class="boring">}</span></code></pre></pre>
<p>Implement <code>required_camera</code> on your widget enum to tell the mosaic which cameras need rendering. The <code>cached_cameras</code> slice contains all camera entities, pre-sorted by entity ID:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn required_camera(&amp;self, cached_cameras: &amp;[Entity]) -&gt; Option&lt;Entity&gt; {
    match self {
        AppWidget::Viewport(v) =&gt; v.required_camera(cached_cameras),
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p><code>MosaicConfig</code> controls layout behavior:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::MosaicConfig;

let config = MosaicConfig {
    tab_bar_height: 24.0,
    close_button_size: 16.0,
    gap_width: 1.0,
    min_size: 32.0,
    all_closable: true,
    show_add_button: true,
    simplification_options: egui_tiles::SimplificationOptions {
        all_panes_must_have_tabs: true,
        ..Default::default()
    },
};

let mosaic = Mosaic::with_panes(vec![/* ... */]).with_config(config);
<span class="boring">}</span></code></pre></pre>
<h2 id="theming"><a class="header" href="#theming">Theming</a></h2>
<p>The mosaic module includes a theme system with 11 built-in presets and a visual theme editor.</p>
<p>Built-in presets: Dark, Light, Dracula, Nord, Gruvbox Dark, Solarized Dark, Solarized Light, Monokai, One Dark, Tokyo Night, Catppuccin Mocha.</p>
<p><code>ThemeConfig</code> supports ~80 override fields covering all egui visual properties: colors, stroke widths, corner radii, expansion, shadow sizes, and miscellaneous flags (button frames, striped backgrounds, slider trailing fill, etc.).</p>
<p>The preset combo box supports hover-to-preview - hovering a preset temporarily applies its visuals so you can see the effect before committing.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{ThemeState, ThemeConfig, apply_theme, get_active_theme_visuals, render_theme_editor_window};

let mut theme_state = ThemeState::default();

// Apply theme each frame (uses preview theme when hovering presets)
apply_theme(ctx, &amp;theme_state);

// Show the editor window
if render_theme_editor_window(ctx, &amp;mut theme_state) {
    // theme changed - save if desired
}

// Switch preset by name
theme_state.select_preset_by_name("Dracula");

// Get the effective visuals (preview-aware)
let visuals = get_active_theme_visuals(&amp;theme_state);
<span class="boring">}</span></code></pre></pre>
<h2 id="modals"><a class="header" href="#modals">Modals</a></h2>
<p>Show confirmation dialogs and text input prompts:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, ui: &amp;mut egui::Ui, context: &amp;mut WidgetContext&lt;AppContext, AppMessage&gt;) {
    if ui.button("Delete").clicked() {
        context.modals.show_confirm("delete", "Confirm Delete", "Are you sure?");
    }

    if let Some(result) = context.modals.take_result("delete") {
        match result {
            ModalResult::Confirmed =&gt; { /* delete */ }
            ModalResult::Cancelled =&gt; {}
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Text input modals:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.modals.show_text_input("rename", "Rename", "Enter new name:", "default");

if let Some(ModalResult::TextInput(name)) = context.modals.take_result("rename") {
    // use name
}
<span class="boring">}</span></code></pre></pre>
<p>Full <code>Modals</code> API:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>modals.show_confirm(id, title, body)
modals.show_confirm_with_text(id, title, body, confirm_text, cancel_text)
modals.show_text_input(id, title, prompt, default_text)
modals.show_text_input_with_text(id, title, prompt, default_text, confirm_text, cancel_text)
modals.take_result(id) -&gt; Option&lt;ModalResult&gt;
modals.has_open_modal() -&gt; bool
<span class="boring">}</span></code></pre></pre>
<h2 id="toast-notifications"><a class="header" href="#toast-notifications">Toast Notifications</a></h2>
<p>Four toast kinds: Info, Success, Warning, Error - each with a distinct accent color and fade-out animation.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{Toasts, ToastKind};

let mut toasts = Toasts::new();
toasts.push(ToastKind::Success, "Project saved", 3.0);
toasts.push(ToastKind::Error, "Failed to load file", 4.0);
toasts.push(ToastKind::Warning, "Low disk space", 3.0);
toasts.push(ToastKind::Info, "Update available", 3.0);

// Each frame:
toasts.tick(delta_time);
toasts.render(ctx);
<span class="boring">}</span></code></pre></pre>
<h2 id="status-bar"><a class="header" href="#status-bar">Status Bar</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::StatusBar;

let mut status_bar = StatusBar::new();
status_bar.add_left("FPS: 60");
status_bar.add_left_colored("Ready", egui::Color32::GREEN);
status_bar.add_right("Theme: Nord");
status_bar.add_right_with_tooltip("v1.0", "Application version");
status_bar.render(ctx);
<span class="boring">}</span></code></pre></pre>
<h2 id="command-palette"><a class="header" href="#command-palette">Command Palette</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::CommandPalette;

let mut palette = CommandPalette::new();
palette.register("New File", Some("Ctrl+N".to_string()), || { /* ... */ });
palette.register("Save", Some("Ctrl+S".to_string()), || { /* ... */ });

// Toggle with a keybinding
palette.toggle();

// Each frame:
palette.render(ctx);
<span class="boring">}</span></code></pre></pre>
<h2 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{ShortcutManager, KeyBinding};

let mut shortcuts = ShortcutManager::new();
shortcuts.register("Save", KeyBinding::ctrl(egui::Key::S), || { /* ... */ });
shortcuts.register("Undo", KeyBinding::ctrl(egui::Key::Z), || { /* ... */ });
shortcuts.register("Redo", KeyBinding::ctrl_shift(egui::Key::Z), || { /* ... */ });

// Each frame:
shortcuts.process(ctx);
<span class="boring">}</span></code></pre></pre>
<p><code>KeyBinding</code> constructors: <code>new(key)</code>, <code>ctrl(key)</code>, <code>shift(key)</code>, <code>ctrl_shift(key)</code>, <code>alt(key)</code>.</p>
<h2 id="file-dialogs"><a class="header" href="#file-dialogs">File Dialogs</a></h2>
<p>Mosaic re-exports the cross-platform file I/O functions from <code>nightshade::filesystem</code> for convenience. See the <a href="filesystem.html">File System</a> chapter for full documentation of all types and functions.</p>
<p>Native-only functions (<code>pick_file</code>, <code>pick_folder</code>, <code>save_file_dialog</code>, <code>read_file</code>, <code>write_file</code>) require the <code>file_dialog</code> feature, which is included in <code>engine</code> by default:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{FileFilter, pick_file, pick_folder, save_file_dialog, read_file, write_file};

let filters = [FileFilter {
    name: "JSON".to_string(),
    extensions: vec!["json".to_string()],
}];

if let Some(path) = pick_file(&amp;filters) {
    let bytes = read_file(&amp;path).unwrap();
}

if let Some(path) = save_file_dialog(&amp;filters, Some("data.json")) {
    write_file(&amp;path, data.as_bytes()).unwrap();
}

if let Some(folder) = pick_folder() {
    // use folder path
}
<span class="boring">}</span></code></pre></pre>
<p>For cross-platform save/load that works on both native and WASM without <code>#[cfg]</code> gates, use <code>save_file</code> and <code>request_file_load</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::filesystem::{save_file, request_file_load, FileFilter};

// Save (native: save dialog, WASM: browser download)
let filters = [FileFilter {
    name: "JSON".to_string(),
    extensions: vec!["json".to_string()],
}];
save_file("data.json", &amp;bytes, &amp;filters)?;

// Load (native: file picker + sync read, WASM: file input + async read)
let pending = request_file_load(&amp;filters);
// poll pending.take() each frame
<span class="boring">}</span></code></pre></pre>
<h2 id="settings-persistence"><a class="header" href="#settings-persistence">Settings Persistence</a></h2>
<p>Save and load application settings to <code>&lt;config_dir&gt;/app_name/settings.json</code>. Falls back to <code>T::default()</code> on missing or corrupt files.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::Settings;

#[derive(Default, serde::Serialize, serde::Deserialize)]
struct AppSettings {
    theme_name: Option&lt;String&gt;,
    recent_files: Vec&lt;String&gt;,
}

let settings: Settings&lt;AppSettings&gt; = Settings::load("my-app-name");
// settings.data.theme_name ...
settings.save().ok();
<span class="boring">}</span></code></pre></pre>
<h2 id="fps-counter"><a class="header" href="#fps-counter">FPS Counter</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::FpsCounter;

let mut fps = FpsCounter::new(0.5); // update every 0.5 seconds
// or: let mut fps = FpsCounter::default(); // same 0.5s interval

// Each frame:
fps.tick(delta_time);

// Read smoothed FPS:
let fps_value = fps.fps();           // f32
let fps_rounded = fps.fps_rounded(); // u32
<span class="boring">}</span></code></pre></pre>
<h2 id="event-log"><a class="header" href="#event-log">Event Log</a></h2>
<p>Timestamped event log with category coloring and automatic scroll-to-bottom.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::EventLog;

let mut log = EventLog::new(500);
log.log("SYS", "Application started");
log.tick(delta_time);
log.render(ui, |category| match category {
    "SYS" =&gt; egui::Color32::GRAY,
    "ERR" =&gt; egui::Color32::RED,
    _ =&gt; egui::Color32::WHITE,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="recent-files"><a class="header" href="#recent-files">Recent Files</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::RecentFiles;

let mut recent = RecentFiles::new(10);
recent.add(path);
for path in recent.paths() { /* render menu items */ }
<span class="boring">}</span></code></pre></pre>
<h2 id="clipboard"><a class="header" href="#clipboard">Clipboard</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{get_clipboard_text, set_clipboard_text};

set_clipboard_text(ctx, "copied text");
if let Some(text) = get_clipboard_text(ctx) { /* paste */ }
<span class="boring">}</span></code></pre></pre>
<h2 id="drag-and-drop"><a class="header" href="#drag-and-drop">Drag and Drop</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{get_dropped_files, is_file_hovering, render_drop_overlay};

render_drop_overlay(ctx, "Drop files here");
for file in get_dropped_files(ctx) {
    if let Some(path) = file.path { /* handle file */ }
    if let Some(bytes) = file.bytes { /* handle raw bytes */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="project-saveload"><a class="header" href="#project-saveload">Project Save/Load</a></h2>
<p>Save and load entire mosaic layouts. <code>ProjectSaveFile&lt;W, D&gt;</code> supports an optional generic <code>data</code> field for storing application-specific state alongside the layout:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::{save_project, load_project};

// Save (with no extra data)
let project = save_project("My Project", "1.0", &amp;[&amp;mosaic], None::&lt;()&gt;);
let json = serde_json::to_string_pretty(&amp;project).unwrap();

// Save (with application data)
let project = save_project("My Project", "1.0", &amp;[&amp;mosaic], Some(app_data));

// Load
let project = serde_json::from_str(&amp;json).unwrap();
let (windows, data) = load_project(project);
for window in windows {
    let mosaic = Mosaic::from_window_layout(window);
}
<span class="boring">}</span></code></pre></pre>
<p><code>ProjectSaveFile</code> also supports direct file I/O (native only) with JSON and binary (bincode) formats:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::mosaic::ProjectSaveFile;

project.save_to_path(Path::new("project.json"))?;
project.save_to_path(Path::new("project.bin"))?;
let project = ProjectSaveFile::load_from_path(Path::new("project.json"))?;
<span class="boring">}</span></code></pre></pre>
<p>Or save/load just the tile tree:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tree_json = mosaic.save_tree().unwrap();
mosaic.load_tree(tree_json).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Or save/load a named layout:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let save = mosaic.save_layout("Main", "1.0.0");
mosaic.load_layout(save);
<span class="boring">}</span></code></pre></pre>
<h3 id="cross-platform-file-saveload"><a class="header" href="#cross-platform-file-saveload">Cross-Platform File Save/Load</a></h3>
<p>Mosaic provides convenience methods that use <code>nightshade::filesystem</code> under the hood. These work on both native and WASM with no <code>#[cfg]</code> gates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Save layout to file (native: save dialog, WASM: browser download)
mosaic.save_project_to_file("my_layout.json")?;

// Request file load (returns PendingFileLoad)
let pending = mosaic.request_project_load();

// Poll each frame:
if let Some(file) = pending.take() {
    mosaic.load_project_from_bytes(&amp;file.bytes)?;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>save_project_to_file(filename)</code> — serializes the tile tree to JSON and calls <code>nightshade::filesystem::save_file</code></li>
<li><code>request_project_load()</code> — calls <code>nightshade::filesystem::request_file_load</code> with a JSON filter</li>
<li><code>load_project_from_bytes(bytes)</code> — deserializes and restores the tile tree from raw bytes</li>
</ul>
<h2 id="widget-management"><a class="header" href="#widget-management">Widget Management</a></h2>
<p>Add and remove widgets programmatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.insert_pane(widget)                     // Add widget to root container
mosaic.insert_pane_in(container_id, widget)    // Add widget to specific container
mosaic.remove_pane(tile_id)                    // Remove widget, returns owned widget
mosaic.find_widget(|w| predicate)              // Find first matching widget's TileId
mosaic.get_widget(tile_id)                     // Get &amp;W by TileId
mosaic.get_widget_mut(tile_id)                 // Get &amp;mut W by TileId
mosaic.activate_tab(tile_id)                   // Focus a widget's tab
mosaic.widget_count()                          // Number of widget panes
<span class="boring">}</span></code></pre></pre>
<h3 id="tree-walking"><a class="header" href="#tree-walking">Tree Walking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.for_each_widget(|widget| { ... });
mosaic.for_each_widget_mut(|widget| { ... });
mosaic.for_each_widget_with_id(|tile_id, widget| { ... });
mosaic.for_each_widget_with_id_mut(|tile_id, widget| { ... });
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-state"><a class="header" href="#layout-state">Layout State</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.layout_modified()                   // Check if layout changed (drag, close, add)
mosaic.take_layout_modified()              // Check and reset layout flag
mosaic.layout_name                         // Current layout name (pub field)
mosaic.title                               // Window title (pub field)
mosaic.viewport_rects()                    // Rendered pane rectangles by TileId
mosaic.selected_viewport_tile()            // Currently selected viewport
Mosaic::clear_required_cameras(world)      // Clear the required cameras list
mosaic.modals()                            // Get &amp;mut Modals
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-management"><a class="header" href="#layout-management">Layout Management</a></h2>
<p>Mosaic supports multiple named layouts that can be switched, created, saved, and deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.switch_layout(index)                // Switch to layout by index
mosaic.create_layout("name", default_tree) // Create a new layout
mosaic.save_current_layout()               // Save current tree to active layout
mosaic.delete_current_layout()             // Delete active layout (if more than one)
mosaic.rename_layout(index, name)          // Rename a layout
mosaic.reset_layout(default_tree)          // Reset active layout to default
mosaic.active_layout_name()                // Name of the active layout
mosaic.active_layout_index()               // Index of the active layout
mosaic.layout_count()                      // Number of layouts
mosaic.layouts()                           // &amp;[WindowLayout&lt;W&gt;]
mosaic.load_layouts(layouts, active_index) // Load layouts from saved data
mosaic.save_layouts()                      // (Vec&lt;WindowLayout&lt;W&gt;&gt;, usize) for persistence
<span class="boring">}</span></code></pre></pre>
<p>A built-in layout menu UI is available:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let events = mosaic.render_layout_section(ui, || create_default_tree());
for event in events {
    match event {
        LayoutEvent::Switched(name) =&gt; { /* layout switched */ }
        LayoutEvent::Created(name) =&gt; { /* new layout created */ }
        LayoutEvent::Saved(name) =&gt; { /* layout saved */ }
        LayoutEvent::Deleted(name) =&gt; { /* layout deleted */ }
        LayoutEvent::Reset =&gt; { /* layout reset to default */ }
        LayoutEvent::Renamed(name) =&gt; { /* layout renamed */ }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-window-support"><a class="header" href="#multi-window-support">Multi-Window Support</a></h2>
<p>Create one <code>Mosaic</code> per window. Each has its own layout, modals, and config:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mosaic.is_active_window = true;            // Set whether this window is active (pub field)
mosaic.window_index = Some(index);         // Set the window index (pub field)
mosaic.set_viewport_textures(textures);    // Set viewport textures for secondary windows
<span class="boring">}</span></code></pre></pre>
<p>Use nightshade's secondary window system to spawn additional windows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyApp {
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {
        self.primary.show(world, ctx, &amp;mut self.context);
    }

    fn secondary_ui(&amp;mut self, world: &amp;mut World, window_index: usize, ctx: &amp;egui::Context) {
        let mosaic = self.secondary.entry(window_index).or_insert_with(|| {
            let mut m = Mosaic::with_panes(vec![AppWidget::Viewport(ViewportWidget::default())]);
            m.window_index = Some(window_index);
            m
        });
        mosaic.show(world, ctx, &amp;mut self.context);
    }

    fn pre_render(&amp;mut self, renderer: &amp;mut dyn Render, world: &amp;mut World) {
        let cameras = world.resources.user_interface.required_cameras.clone();
        for (&amp;window_index, mosaic) in &amp;mut self.secondary {
            let textures = renderer.register_camera_viewports_for_secondary(window_index, &amp;cameras);
            mosaic.set_viewport_textures(textures);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Use <code>save_project</code> / <code>load_project</code> to persist all windows together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immediate-mode-ui"><a class="header" href="#immediate-mode-ui">Immediate Mode UI</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/menu">Menu</a></p>
</blockquote>
<p>In addition to egui, Nightshade provides a lightweight custom immediate-mode UI system for simple in-game interfaces.</p>
<h2 id="the-immediate_ui-method"><a class="header" href="#the-immediate_ui-method">The immediate_ui() Method</a></h2>
<p>Implement the <code>immediate_ui()</code> method on your <code>State</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
        ui.panel(PanelPosition::Left, 200.0, |ui| {
            ui.label("Left Panel");
            if ui.button("Click me") {
                self.counter += 1;
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="panel-positions"><a class="header" href="#panel-positions">Panel Positions</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum PanelPosition {
    Left,
    Right,
    Top,
    Bottom,
    Central,
    Floating { x: f32, y: f32 },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="side-panels"><a class="header" href="#side-panels">Side Panels</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.panel(PanelPosition::Left, 250.0, |ui| {
    ui.label("Tools");
});

ui.panel(PanelPosition::Right, 300.0, |ui| {
    ui.label("Inspector");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="topbottom-panels"><a class="header" href="#topbottom-panels">Top/Bottom Panels</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.panel(PanelPosition::Top, 50.0, |ui| {
    ui.horizontal(|ui| {
        ui.label("Menu Bar");
    });
});

ui.panel(PanelPosition::Bottom, 100.0, |ui| {
    ui.label("Status Bar");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-panels"><a class="header" href="#floating-panels">Floating Panels</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.panel(PanelPosition::Floating { x: 100.0, y: 100.0 }, 200.0, |ui| {
    ui.label("Floating Window");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="central-panel-1"><a class="header" href="#central-panel-1">Central Panel</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.panel(PanelPosition::Central, 0.0, |ui| {
    ui.label("Main content area");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="widgets"><a class="header" href="#widgets">Widgets</a></h2>
<h3 id="labels-1"><a class="header" href="#labels-1">Labels</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.label("Simple text");
ui.label(format!("Score: {}", self.score));
<span class="boring">}</span></code></pre></pre>
<h3 id="buttons-1"><a class="header" href="#buttons-1">Buttons</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ui.button("Start Game") {
    self.start_game();
}

if ui.button("Exit") {
    std::process::exit(0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sliders-1"><a class="header" href="#sliders-1">Sliders</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.slider("Volume", &amp;mut self.volume, 0.0..100.0);
ui.slider("Brightness", &amp;mut self.brightness, 0.0..2.0);
<span class="boring">}</span></code></pre></pre>
<h3 id="text-input-1"><a class="header" href="#text-input-1">Text Input</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.horizontal(|ui| {
    ui.label("Name:");
    ui.text_input(&amp;mut self.player_name);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="checkboxes-1"><a class="header" href="#checkboxes-1">Checkboxes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.checkbox("Fullscreen", &amp;mut self.fullscreen);
ui.checkbox("VSync", &amp;mut self.vsync);
<span class="boring">}</span></code></pre></pre>
<h2 id="layouts-1"><a class="header" href="#layouts-1">Layouts</a></h2>
<h3 id="horizontal-layout"><a class="header" href="#horizontal-layout">Horizontal Layout</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.horizontal(|ui| {
    if ui.button("Previous") {
        self.page -= 1;
    }
    ui.label(format!("Page {}", self.page));
    if ui.button("Next") {
        self.page += 1;
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="vertical-layout"><a class="header" href="#vertical-layout">Vertical Layout</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.vertical(|ui| {
    ui.label("Option 1");
    ui.label("Option 2");
    ui.label("Option 3");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="spacing-1"><a class="header" href="#spacing-1">Spacing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ui.space(10.0);
ui.separator();
<span class="boring">}</span></code></pre></pre>
<h2 id="pause-menu-example"><a class="header" href="#pause-menu-example">Pause Menu Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    if self.paused {
        ui.panel(PanelPosition::Central, 300.0, |ui| {
            ui.label("PAUSED");
            ui.space(20.0);

            if ui.button("Resume") {
                self.paused = false;
            }

            if ui.button("Settings") {
                self.show_settings = true;
            }

            if ui.button("Quit to Menu") {
                self.quit_to_menu();
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="settings-menu-example"><a class="header" href="#settings-menu-example">Settings Menu Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    if self.show_settings {
        ui.panel(PanelPosition::Central, 400.0, |ui| {
            ui.label("Settings");
            ui.separator();

            ui.label("Audio");
            ui.slider("Master Volume", &amp;mut self.master_volume, 0.0..100.0);
            ui.slider("Music Volume", &amp;mut self.music_volume, 0.0..100.0);
            ui.slider("SFX Volume", &amp;mut self.sfx_volume, 0.0..100.0);

            ui.separator();

            ui.label("Graphics");
            ui.checkbox("Fullscreen", &amp;mut self.fullscreen);
            ui.checkbox("VSync", &amp;mut self.vsync);
            ui.slider("Brightness", &amp;mut self.brightness, 0.5..1.5);

            ui.separator();

            ui.horizontal(|ui| {
                if ui.button("Apply") {
                    self.apply_settings(world);
                }
                if ui.button("Cancel") {
                    self.show_settings = false;
                }
            });
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="inventory-ui-example"><a class="header" href="#inventory-ui-example">Inventory UI Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    ui.panel(PanelPosition::Right, 250.0, |ui| {
        ui.label("Inventory");
        ui.separator();

        for (index, item) in self.inventory.items.iter().enumerate() {
            ui.horizontal(|ui| {
                ui.label(&amp;item.name);
                ui.label(format!("x{}", item.quantity));
                if ui.button("Use") {
                    self.use_item(index);
                }
            });
        }

        ui.separator();
        ui.label(format!("Gold: {}", self.gold));
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dialog-box-example"><a class="header" href="#dialog-box-example">Dialog Box Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    if let Some(dialog) = &amp;self.current_dialog {
        ui.panel(PanelPosition::Bottom, 150.0, |ui| {
            ui.label(&amp;dialog.speaker);
            ui.separator();
            ui.label(&amp;dialog.text);
            ui.space(10.0);

            ui.horizontal(|ui| {
                for (index, choice) in dialog.choices.iter().enumerate() {
                    if ui.button(choice) {
                        self.select_dialog_choice(index);
                    }
                }
            });
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="styling-1"><a class="header" href="#styling-1">Styling</a></h2>
<p>The immediate UI uses the engine's built-in styling. Colors and fonts are controlled through the <code>UserInterface</code> resource:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.user_interface.text_color = Vec4::new(1.0, 1.0, 1.0, 1.0);
world.resources.user_interface.background_color = Vec4::new(0.1, 0.1, 0.1, 0.9);
world.resources.user_interface.button_color = Vec4::new(0.2, 0.2, 0.2, 1.0);
world.resources.user_interface.button_hover_color = Vec4::new(0.3, 0.3, 0.3, 1.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p>Use the immediate UI for:</p>
<ul>
<li>Simple in-game menus (pause, settings)</li>
<li>HUD elements that don't need complex layouts</li>
<li>Quick prototyping</li>
</ul>
<p>Use egui for:</p>
<ul>
<li>Complex debug tools</li>
<li>Editor interfaces</li>
<li>Forms with many input types</li>
<li>Dockable windows</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hud-text"><a class="header" href="#hud-text">HUD Text</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/hud_text">HUD Text</a></p>
</blockquote>
<p>Screen-space text rendering for UI, scores, and debug information.</p>
<h2 id="creating-hud-text"><a class="header" href="#creating-hud-text">Creating HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::text::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_hud_text(world, "Score: 0", HudAnchor::TopLeft, Vec2::new(20.0, 20.0));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hud-anchors"><a class="header" href="#hud-anchors">HUD Anchors</a></h2>
<p>Text can be anchored to any screen position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HudAnchor {
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="anchor-examples"><a class="header" href="#anchor-examples">Anchor Examples</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Score in top-left corner
spawn_hud_text(world, "Score: 0", HudAnchor::TopLeft, Vec2::new(20.0, 20.0));

// Centered title
spawn_hud_text(world, "GAME OVER", HudAnchor::Center, Vec2::zeros());

// Health bar label bottom-left
spawn_hud_text(world, "HP", HudAnchor::BottomLeft, Vec2::new(20.0, -60.0));

// Timer top-center
spawn_hud_text(world, "3:00", HudAnchor::TopCenter, Vec2::new(0.0, 30.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="text-properties"><a class="header" href="#text-properties">Text Properties</a></h2>
<p>Customize text appearance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    font_size: 32.0,
    color: [1.0, 1.0, 1.0, 1.0],
    text_alignment: TextAlignment::Left,
    vertical_alignment: VerticalAlignment::Top,
    line_height: 1.2,
    letter_spacing: 0.0,
    outline_width: 0.0,
    outline_color: [0.0, 0.0, 0.0, 1.0],
    smoothing: 0.003,
    monospace_width: None,
    anchor_character: None,
};

spawn_hud_text_with_properties(
    world,
    "Custom Text",
    HudAnchor::TopLeft,
    Vec2::new(20.0, 20.0),
    properties,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="text-alignment"><a class="header" href="#text-alignment">Text Alignment</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Left aligned (default)
TextAlignment::Left

// Center aligned
TextAlignment::Center

// Right aligned
TextAlignment::Right
<span class="boring">}</span></code></pre></pre>
<h3 id="vertical-alignment"><a class="header" href="#vertical-alignment">Vertical Alignment</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>VerticalAlignment::Top      // Align to top
VerticalAlignment::Middle   // Center vertically
VerticalAlignment::Bottom   // Align to bottom
VerticalAlignment::Baseline // Align to text baseline
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-text"><a class="header" href="#updating-text">Updating Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(text_entity) = self.score_text {
        if let Some(hud_text) = world.get_hud_text_mut(text_entity) {
            let text = format!("Score: {}", self.score);
            world.resources.text_cache.set_text(hud_text.text_index, &amp;text);
            hud_text.dirty = true;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-outlines"><a class="header" href="#text-outlines">Text Outlines</a></h2>
<p>Add outlines for better visibility:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    font_size: 24.0,
    color: [1.0, 1.0, 1.0, 1.0],
    outline_width: 2.0,
    outline_color: [0.0, 0.0, 0.0, 1.0],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-custom-fonts"><a class="header" href="#loading-custom-fonts">Loading Custom Fonts</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let font_bytes = include_bytes!("assets/fonts/custom.ttf");
    let font_index = load_font_from_bytes(world, font_bytes);

    self.custom_font = Some(font_index);
}

fn spawn_custom_text(&amp;self, world: &amp;mut World) {
    let entity = world.spawn_entities(HUD_TEXT, 1)[0];

    let text_index = world.resources.text_cache.add_text("Custom Font Text");

    world.set_hud_text(entity, HudText {
        text_index,
        properties: TextProperties::default(),
        font_index: self.custom_font.unwrap(),
        position: Vec2::new(100.0, 100.0),
        anchor: HudAnchor::TopLeft,
        cached_mesh: None,
        dirty: true,
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hudtext-component"><a class="header" href="#hudtext-component">HudText Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HudText {
    pub text_index: usize,              // Index in TextCache
    pub properties: TextProperties,     // Visual properties
    pub font_index: usize,              // Which font to use
    pub position: Vec2,                 // Offset from anchor
    pub anchor: HudAnchor,              // Screen anchor point
    pub cached_mesh: Option&lt;TextMesh&gt;,  // Pre-generated mesh
    pub dirty: bool,                    // Needs regeneration
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-line-text"><a class="header" href="#multi-line-text">Multi-line Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let multiline = "Line 1\nLine 2\nLine 3";
spawn_hud_text(world, multiline, HudAnchor::TopLeft, Vec2::new(20.0, 20.0));
<span class="boring">}</span></code></pre></pre>
<p>Line height is controlled by <code>TextProperties::line_height</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    line_height: 1.5,  // 150% of font size
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="colored-text-spans"><a class="header" href="#colored-text-spans">Colored Text Spans</a></h2>
<p>For per-character coloring, modify the text cache:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.text_cache.set_character_colors(
    text_index,
    vec![
        [1.0, 0.0, 0.0, 1.0],  // Red
        [0.0, 1.0, 0.0, 1.0],  // Green
        [0.0, 0.0, 1.0, 1.0],  // Blue
    ],
);
<span class="boring">}</span></code></pre></pre>
<h2 id="3d-world-space-text"><a class="header" href="#3d-world-space-text">3D World-Space Text</a></h2>
<p>For text in 3D space (billboards, signs):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | TEXT,
    1
)[0];

world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 2.0, 0.0),
    ..Default::default()
});

let text_index = world.resources.text_cache.add_text("Hello World");

world.set_text(entity, Text {
    text_index,
    properties: TextProperties {
        font_size: 0.5,  // World units
        ..Default::default()
    },
    billboard: true,  // Face camera
    dirty: true,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-ui-patterns"><a class="header" href="#common-ui-patterns">Common UI Patterns</a></h2>
<h3 id="score-display"><a class="header" href="#score-display">Score Display</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameState {
    score: u32,
    score_text: Option&lt;Entity&gt;,
}

impl State for GameState {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.score_text = Some(spawn_hud_text(
            world,
            "Score: 0",
            HudAnchor::TopRight,
            Vec2::new(-20.0, 20.0),
        ));
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        if let Some(entity) = self.score_text {
            update_hud_text(world, entity, &amp;format!("Score: {}", self.score));
        }
    }
}

fn update_hud_text(world: &amp;mut World, entity: Entity, text: &amp;str) {
    if let Some(hud_text) = world.get_hud_text_mut(entity) {
        world.resources.text_cache.set_text(hud_text.text_index, text);
        hud_text.dirty = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fps-counter-1"><a class="header" href="#fps-counter-1">FPS Counter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FpsCounter {
    text_entity: Option&lt;Entity&gt;,
    frame_times: Vec&lt;f32&gt;,
}

impl FpsCounter {
    fn update(&amp;mut self, world: &amp;mut World, dt: f32) {
        self.frame_times.push(dt);
        if self.frame_times.len() &gt; 60 {
            self.frame_times.remove(0);
        }

        let avg_dt: f32 = self.frame_times.iter().sum::&lt;f32&gt;() / self.frame_times.len() as f32;
        let fps = (1.0 / avg_dt) as u32;

        if let Some(entity) = self.text_entity {
            update_hud_text(world, entity, &amp;format!("FPS: {}", fps));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-bar-label"><a class="header" href="#health-bar-label">Health Bar Label</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_health_ui(world: &amp;mut World) -&gt; Entity {
    let properties = TextProperties {
        font_size: 18.0,
        color: [1.0, 0.2, 0.2, 1.0],
        outline_width: 1.0,
        outline_color: [0.0, 0.0, 0.0, 1.0],
        ..Default::default()
    };

    spawn_hud_text_with_properties(
        world,
        "100 / 100",
        HudAnchor::BottomLeft,
        Vec2::new(80.0, -30.0),
        properties,
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="centered-message"><a class="header" href="#centered-message">Centered Message</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_game_over(world: &amp;mut World) -&gt; Entity {
    let properties = TextProperties {
        font_size: 64.0,
        color: [1.0, 0.0, 0.0, 1.0],
        text_alignment: TextAlignment::Center,
        outline_width: 3.0,
        outline_color: [0.0, 0.0, 0.0, 1.0],
        ..Default::default()
    };

    spawn_hud_text_with_properties(
        world,
        "GAME OVER\nPress R to Restart",
        HudAnchor::Center,
        Vec2::zeros(),
        properties,
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="removing-hud-text"><a class="header" href="#removing-hud-text">Removing HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_text(world: &amp;mut World, entity: Entity) {
    world.despawn_entities(&amp;[entity]);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visibility-control"><a class="header" href="#visibility-control">Visibility Control</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(visible) = world.get_visible_mut(text_entity) {
    visible.0 = false;  // Hide text
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terrain"><a class="header" href="#terrain">Terrain</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/terrain">Terrain</a></p>
</blockquote>
<p>Nightshade supports procedural terrain generation with noise-based heightmaps, physics collision, and PBR materials.</p>
<h2 id="how-terrain-works"><a class="header" href="#how-terrain-works">How Terrain Works</a></h2>
<p>Terrain in Nightshade is a regular mesh generated from a noise-based heightmap. The engine creates a grid of vertices at configurable resolution, samples a noise function at each vertex to determine its height, computes per-vertex normals from the surrounding triangle faces, and registers the result in the mesh cache. The terrain entity is then rendered through the standard mesh pipeline with full PBR material support, shadow casting, and physics collision.</p>
<h3 id="mesh-generation-pipeline"><a class="header" href="#mesh-generation-pipeline">Mesh Generation Pipeline</a></h3>
<p>The <code>generate_terrain_mesh</code> function builds the terrain in four steps:</p>
<ol>
<li>
<p><strong>Vertex generation</strong> - Creates a grid of <code>resolution_x * resolution_z</code> vertices. The grid is centered at the origin, with X coordinates ranging from <code>-width/2</code> to <code>+width/2</code> and Z from <code>-depth/2</code> to <code>+depth/2</code>. Each vertex's Y coordinate is sampled from the noise function and multiplied by <code>height_scale</code>. UV coordinates are computed as the normalized grid position multiplied by <code>uv_scale</code>, controlling how textures tile across the surface.</p>
</li>
<li>
<p><strong>Index generation</strong> - Creates two triangles per grid cell with counter-clockwise winding order. For a cell at grid position <code>(x, z)</code>, the two triangles use indices <code>[top_left, bottom_left, top_right]</code> and <code>[top_right, bottom_left, bottom_right]</code>. Total indices: <code>(resolution_x - 1) * (resolution_z - 1) * 6</code>.</p>
</li>
<li>
<p><strong>Normal calculation</strong> - Per-vertex normals are accumulated from the face normals of all adjacent triangles. Each face normal is computed from the cross product of two triangle edges. After accumulation, normals are normalized to unit length.</p>
</li>
<li>
<p><strong>Bounding volume</strong> - An OBB (Oriented Bounding Box) is computed from the min/max heights, used for frustum culling during rendering.</p>
</li>
</ol>
<h3 id="noise-sampling"><a class="header" href="#noise-sampling">Noise Sampling</a></h3>
<p>The terrain uses the <code>noise</code> crate with four algorithms:</p>
<div class="table-wrapper"><table><thead><tr><th>NoiseType</th><th>Algorithm</th><th>Character</th></tr></thead><tbody>
<tr><td><code>Perlin</code></td><td>Fbm<Perlin></td><td>Smooth rolling hills</td></tr>
<tr><td><code>Simplex</code></td><td>Fbm<OpenSimplex></td><td>Similar to Perlin, fewer directional artifacts</td></tr>
<tr><td><code>Billow</code></td><td>Billow<Perlin></td><td>Rounded, cloud-like features</td></tr>
<tr><td><code>RidgedMulti</code></td><td>RidgedMulti<Perlin></td><td>Sharp ridges, good for mountains</td></tr>
</tbody></table>
</div>
<p>All types are wrapped in multi-octave fractional Brownian motion (fBm), which layers multiple noise samples at increasing frequency and decreasing amplitude. The <code>octaves</code> parameter controls how many layers are added: more octaves add finer detail but cost more to evaluate. <code>Lacunarity</code> is the frequency multiplier per octave (default 2.0), and <code>persistence</code> is the amplitude multiplier per octave (default 0.5).</p>
<h3 id="physics-integration"><a class="header" href="#physics-integration">Physics Integration</a></h3>
<p><code>spawn_terrain</code> automatically creates a static rigid body with a heightfield collider. The heightfield shape stores a 2D grid of height values with a scale factor. The height data is transposed from mesh ordering (<code>z * resolution_x + x</code>) to heightfield ordering (<code>z + resolution_z * x</code>) because Rapier expects column-major layout. The collider has high friction (0.9), no restitution, and all collision groups enabled.</p>
<h2 id="enabling-terrain"><a class="header" href="#enabling-terrain">Enabling Terrain</a></h2>
<p>Terrain requires the <code>terrain</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "terrain"] }
</code></pre>
<h2 id="basic-terrain"><a class="header" href="#basic-terrain">Basic Terrain</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::terrain::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let config = TerrainConfig::new(100.0, 100.0, 64, 64)
        .with_height_scale(10.0)
        .with_frequency(0.02);

    spawn_terrain(world, &amp;config, Vec3::zeros());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-configuration"><a class="header" href="#terrain-configuration">Terrain Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TerrainConfig {
    pub width: f32,           // Terrain width in world units
    pub depth: f32,           // Terrain depth in world units
    pub resolution_x: u32,   // Vertex count along X
    pub resolution_z: u32,   // Vertex count along Z
    pub height_scale: f32,   // Height multiplier for noise values
    pub noise: NoiseConfig,  // Noise generation settings
    pub uv_scale: [f32; 2],  // Texture tiling [u, v]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-methods-1"><a class="header" href="#builder-methods-1">Builder Methods</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = TerrainConfig::new(200.0, 200.0, 128, 128)
    .with_height_scale(25.0)
    .with_noise(NoiseConfig {
        noise_type: NoiseType::RidgedMulti,
        frequency: 0.01,
        octaves: 6,
        lacunarity: 2.0,
        persistence: 0.5,
        seed: 42,
    })
    .with_uv_scale([8.0, 8.0]);
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-with-material"><a class="header" href="#terrain-with-material">Terrain with Material</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let material = Material {
    base_color: [0.3, 0.5, 0.2, 1.0],
    roughness: 0.85,
    metallic: 0.0,
    ..Default::default()
};

spawn_terrain_with_material(world, &amp;config, Vec3::zeros(), material);
<span class="boring">}</span></code></pre></pre>
<h2 id="sampling-terrain-height"><a class="header" href="#sampling-terrain-height">Sampling Terrain Height</a></h2>
<p>Query the terrain height at any world position without mesh lookup. This samples the noise function directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let height = sample_terrain_height(x, z, &amp;config);
<span class="boring">}</span></code></pre></pre>
<p>Use this to place objects on the terrain surface:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn place_on_terrain(world: &amp;mut World, entity: Entity, x: f32, z: f32, config: &amp;TerrainConfig) {
    let y = sample_terrain_height(x, z, config);

    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.translation = Vec3::new(x, y, z);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-3"><a class="header" href="#rendering-3">Rendering</a></h2>
<p>Terrain is rendered through the standard mesh pipeline (<code>MeshPass</code>). It uses the same PBR shader as all other meshes, which means terrain automatically gets:</p>
<ul>
<li>Directional and point light shadows (cascaded shadow maps)</li>
<li>Screen-space ambient occlusion (SSAO)</li>
<li>Screen-space global illumination (SSGI)</li>
<li>Image-based lighting (IBL)</li>
<li>Normal mapping if a normal texture is provided in the material</li>
<li>Full Cook-Torrance BRDF with metallic-roughness workflow</li>
</ul>
<p>The mesh is uploaded to GPU vertex and index buffers once at creation time. During rendering, the MeshPass performs frustum culling using the terrain's bounding volume, then draws it with the assigned material's textures bound.</p>
<h2 id="entity-components"><a class="header" href="#entity-components">Entity Components</a></h2>
<p><code>spawn_terrain</code> creates an entity with these components:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>NAME</code></td><td>"Terrain"</td></tr>
<tr><td><code>LOCAL_TRANSFORM</code></td><td>Position in world</td></tr>
<tr><td><code>GLOBAL_TRANSFORM</code></td><td>Computed world matrix</td></tr>
<tr><td><code>LOCAL_TRANSFORM_DIRTY</code></td><td>Triggers transform update</td></tr>
<tr><td><code>RENDER_MESH</code></td><td>References cached mesh</td></tr>
<tr><td><code>MATERIAL_REF</code></td><td>PBR material</td></tr>
<tr><td><code>BOUNDING_VOLUME</code></td><td>OBB for frustum culling</td></tr>
<tr><td><code>CASTS_SHADOW</code></td><td>Enabled by default</td></tr>
<tr><td><code>RIGID_BODY</code></td><td>Static physics body</td></tr>
<tr><td><code>COLLIDER</code></td><td>HeightField shape</td></tr>
<tr><td><code>VISIBILITY</code></td><td>Visible by default</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="particle-systems"><a class="header" href="#particle-systems">Particle Systems</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/fireworks">Fireworks</a></p>
</blockquote>
<p>GPU-accelerated particle systems for fire, smoke, fireworks, sparks, and weather effects.</p>
<h2 id="how-particles-work"><a class="header" href="#how-particles-work">How Particles Work</a></h2>
<p>Nightshade's particle system is entirely GPU-driven. Up to 1,000,000 particles are simulated and rendered without CPU involvement per frame. The system uses three compute shaders (reset, update, spawn) followed by a render pass, all operating on GPU storage buffers.</p>
<h3 id="gpu-simulation-pipeline"><a class="header" href="#gpu-simulation-pipeline">GPU Simulation Pipeline</a></h3>
<p>Each frame executes four stages:</p>
<ol>
<li>
<p><strong>Reset</strong> (1 workgroup) - Clears the alive count and draw command instance count to zero.</p>
</li>
<li>
<p><strong>Update</strong> (max_particles / 256 workgroups) - For each alive particle:</p>
<ul>
<li>Increment age by <code>delta_time</code></li>
<li>If age exceeds lifetime, mark as dead and push index to the free list</li>
<li>Apply gravity: <code>velocity += gravity * delta_time</code></li>
<li>Apply drag: <code>velocity *= (1 - drag * delta_time)</code></li>
<li>Apply turbulence: curl noise computed from <code>simplex_noise_3d()</code> with spatial derivatives creates a divergence-free vector field that swirls particles naturally</li>
<li>Integrate position: <code>position += velocity * delta_time</code></li>
<li>Interpolate size and color between start/end values based on <code>age / lifetime</code></li>
<li>Push to alive list and increment draw counter via atomics</li>
</ul>
</li>
<li>
<p><strong>Spawn</strong> (one workgroup per emitter, 256 threads each) - Each thread:</p>
<ul>
<li>Atomically decrements the free list to allocate a particle slot</li>
<li>Seeds an RNG using <code>particle_index * 1973 + time * 10000 + spawn_index * 7919 + emitter_index * 6997</code></li>
<li>Generates a spawn offset based on emitter shape (point, sphere, cone, or box)</li>
<li>Applies velocity spread as a random cone angle around the emission direction</li>
<li>Samples the color gradient at t=0.15 and t=0.9 for lifetime interpolation endpoints</li>
<li>Writes initial position, velocity, color, lifetime, size range, gravity, drag, turbulence, and texture index</li>
</ul>
</li>
<li>
<p><strong>Render</strong> - Camera-facing billboard quads using <code>draw_indirect</code> with the alive count. The vertex shader generates 6 vertices (2 triangles) per particle using camera right/up basis vectors extracted from the inverse view matrix. The fragment shader applies either procedural shapes or texture sampling.</p>
</li>
</ol>
<h3 id="procedural-particle-shapes"><a class="header" href="#procedural-particle-shapes">Procedural Particle Shapes</a></h3>
<p>The fragment shader generates several built-in shapes mathematically:</p>
<div class="table-wrapper"><table><thead><tr><th>Shape</th><th>Algorithm</th></tr></thead><tbody>
<tr><td>Firework glow</td><td>Multiple stacked exponential falloffs (coefficients 120, 40, 15, 6, 2.5)</td></tr>
<tr><td>Fire</td><td>Vertically stretched (y *= 0.65) with core, flame, and outer glow layers</td></tr>
<tr><td>Smoke</td><td>Gaussian soft circle (coefficient 4.0)</td></tr>
<tr><td>Spark</td><td>Tight bright core with steep exponential falloff</td></tr>
<tr><td>Star</td><td>Cosine-based pointiness with adjustable sharpness</td></tr>
</tbody></table>
</div>
<h3 id="blending-modes"><a class="header" href="#blending-modes">Blending Modes</a></h3>
<p>Two render pipelines handle different particle types:</p>
<ul>
<li><strong>Alpha blending</strong> (<code>SrcAlpha, OneMinusSrcAlpha</code>) for standard particles like smoke</li>
<li><strong>Additive blending</strong> (<code>SrcAlpha, One</code>) for emissive particles like fire and sparks, which accumulate brightness and interact with HDR bloom. The additive fragment shader boosts color: <code>hdr_color + hdr_color^2 * 0.3</code></li>
</ul>
<p>Both pipelines disable depth writes (particles are transparent) but enable depth testing with <code>GreaterEqual</code> (reversed-Z).</p>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<p>Particle slots are managed with a GPU-side free list. Dead particles push their index onto the free list via atomic operations. Spawning particles pop indices off the free list. This lock-free approach handles millions of spawn/death events per second entirely on the GPU.</p>
<h2 id="particle-emitter-component"><a class="header" href="#particle-emitter-component">Particle Emitter Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ParticleEmitter {
    pub emitter_type: EmitterType,       // Firework, Fire, Smoke, Sparks, Trail
    pub shape: EmitterShape,             // Point, Sphere, Cone, Box
    pub position: Vec3,                  // Local offset from transform
    pub direction: Vec3,                 // Primary emission direction
    pub spawn_rate: f32,                 // Particles per second
    pub burst_count: u32,               // One-time spawn count
    pub particle_lifetime_min: f32,      // Minimum lifetime (seconds)
    pub particle_lifetime_max: f32,      // Maximum lifetime (seconds)
    pub initial_velocity_min: f32,       // Min velocity along direction
    pub initial_velocity_max: f32,       // Max velocity along direction
    pub velocity_spread: f32,            // Cone angle (radians)
    pub gravity: Vec3,                   // Acceleration vector
    pub drag: f32,                       // Velocity damping (0-1)
    pub size_start: f32,                 // Billboard size at birth
    pub size_end: f32,                   // Billboard size at death
    pub color_gradient: ColorGradient,   // Color over lifetime
    pub emissive_strength: f32,          // HDR multiplier for bloom
    pub turbulence_strength: f32,        // Curl noise strength
    pub turbulence_frequency: f32,       // Curl noise scale
    pub texture_index: u32,             // 0 = procedural, 1+ = texture array slot
    pub enabled: bool,
    pub one_shot: bool,                  // Burst once then disable
}
<span class="boring">}</span></code></pre></pre>
<h2 id="emitter-shapes"><a class="header" href="#emitter-shapes">Emitter Shapes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EmitterShape::Point                             // Spawn from center
EmitterShape::Sphere { radius: 0.5 }           // Random within sphere
EmitterShape::Cone { angle: 0.5, height: 1.0 } // Cone spread
EmitterShape::Box { half_extents: Vec3::new(1.0, 0.1, 1.0) }
<span class="boring">}</span></code></pre></pre>
<h2 id="color-gradients"><a class="header" href="#color-gradients">Color Gradients</a></h2>
<p>Define how particles change color over their lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ColorGradient {
    pub colors: Vec&lt;(f32, Vec4)&gt;,  // (normalized_time, rgba_color)
}
<span class="boring">}</span></code></pre></pre>
<p>Built-in gradients:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ColorGradient::fire()       // Yellow -&gt; orange -&gt; red -&gt; black
ColorGradient::smoke()      // Gray with varying alpha
ColorGradient::sparks()     // Bright yellow -&gt; orange -&gt; red
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-presets"><a class="header" href="#built-in-presets">Built-in Presets</a></h2>
<p>The <code>ParticleEmitter</code> struct provides 30+ factory methods:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParticleEmitter::fire(position)
ParticleEmitter::smoke(position)
ParticleEmitter::sparks(position)
ParticleEmitter::explosion(position)
ParticleEmitter::willow(position)
ParticleEmitter::chrysanthemum(position)
ParticleEmitter::palm_explosion(position, color)
ParticleEmitter::comet_shell(position)
ParticleEmitter::strobe_effect(position)
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-emitters"><a class="header" href="#creating-emitters">Creating Emitters</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    PARTICLE_EMITTER | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
    1
)[0];

world.set_particle_emitter(entity, ParticleEmitter::fire(Vec3::zeros()));

world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-emitter"><a class="header" href="#custom-emitter">Custom Emitter</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_particle_emitter(entity, ParticleEmitter {
    emitter_type: EmitterType::Fire,
    shape: EmitterShape::Sphere { radius: 0.1 },
    direction: Vec3::y(),
    spawn_rate: 100.0,
    particle_lifetime_min: 0.3,
    particle_lifetime_max: 0.8,
    initial_velocity_min: 1.0,
    initial_velocity_max: 2.0,
    velocity_spread: 0.3,
    gravity: Vec3::new(0.0, -2.0, 0.0),
    drag: 0.1,
    size_start: 0.15,
    size_end: 0.02,
    color_gradient: ColorGradient::fire(),
    emissive_strength: 3.0,
    turbulence_strength: 0.5,
    turbulence_frequency: 1.0,
    enabled: true,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-emitters"><a class="header" href="#updating-emitters">Updating Emitters</a></h2>
<p>The CPU-side update system must run each frame to accumulate spawn counts:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    update_particle_emitters(world);
}
<span class="boring">}</span></code></pre></pre>
<p>For continuous emitters, this adds <code>spawn_rate * delta_time</code> to an accumulator. For one-shot bursts, it sets the spawn count to <code>burst_count</code> once.</p>
<h2 id="controlling-emitters"><a class="header" href="#controlling-emitters">Controlling Emitters</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(emitter) = world.get_particle_emitter_mut(entity) {
    emitter.enabled = false;
    emitter.emissive_strength = 5.0;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-particle-textures"><a class="header" href="#custom-particle-textures">Custom Particle Textures</a></h2>
<p>Upload textures to the particle texture array (64 slots, 512x512 each):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.pending_particle_textures.push(ParticleTextureUpload {
    slot: 1,
    rgba_data: image_bytes,
    width: 512,
    height: 512,
});
<span class="boring">}</span></code></pre></pre>
<p>Set <code>texture_index</code> to the slot number (1+) to use a custom texture instead of procedural shapes.</p>
<h2 id="capacity"><a class="header" href="#capacity">Capacity</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Limit</th><th>Value</th></tr></thead><tbody>
<tr><td>Maximum particles</td><td>1,000,000</td></tr>
<tr><td>Maximum emitters</td><td>512</td></tr>
<tr><td>Texture slots</td><td>64</td></tr>
<tr><td>Texture slot size</td><td>512 x 512</td></tr>
<tr><td>Compute workgroup size</td><td>256</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="navigation-mesh"><a class="header" href="#navigation-mesh">Navigation Mesh</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/navmesh">NavMesh</a></p>
</blockquote>
<p>AI pathfinding using Recast navigation mesh generation, A*/Dijkstra/Greedy pathfinding, funnel path smoothing, and agent movement with local avoidance.</p>
<h2 id="how-navigation-meshes-work"><a class="header" href="#how-navigation-meshes-work">How Navigation Meshes Work</a></h2>
<p>A navigation mesh (navmesh) is a set of convex polygons (usually triangles) that represent the walkable surfaces of a level. Instead of testing every point in the world for walkability, AI agents pathfind through connected triangles, then smooth the resulting path through shared edges.</p>
<h3 id="navmesh-generation-recast-pipeline"><a class="header" href="#navmesh-generation-recast-pipeline">Navmesh Generation (Recast Pipeline)</a></h3>
<p>Nightshade uses the Recast algorithm (via the <code>rerecast</code> crate) to automatically generate a navmesh from world geometry. The pipeline has 13 steps:</p>
<ol>
<li><strong>Build trimesh</strong> - Collect all mesh vertices and indices from the scene</li>
<li><strong>Mark walkable triangles</strong> - Classify each triangle by its slope angle against the walkable threshold</li>
<li><strong>Create heightfield</strong> - Rasterize the scene into a voxel grid with configurable cell size and height</li>
<li><strong>Rasterize triangles</strong> - Project each walkable triangle into the heightfield</li>
<li><strong>Filter obstacles</strong> - Remove low-hanging obstacles, ledge spans, and low-height spans that agents can't traverse</li>
<li><strong>Compact heightfield</strong> - Convert to a more efficient representation for region building</li>
<li><strong>Erode walkable area</strong> - Shrink walkable areas by the agent radius to prevent wall clipping</li>
<li><strong>Build distance field</strong> - Compute the distance from each cell to the nearest boundary</li>
<li><strong>Create regions</strong> - Group connected cells into regions using watershed partitioning. <code>min_region_size</code> (default 8) filters tiny regions, <code>merge_region_size</code> (default 20) combines small adjacent regions</li>
<li><strong>Build contours</strong> - Trace region boundaries into simplified contour polygons, controlled by <code>max_simplification_error</code></li>
<li><strong>Convert to polygon mesh</strong> - Triangulate contours into convex polygons (up to <code>max_vertices_per_polygon</code>, default 6)</li>
<li><strong>Generate detail mesh</strong> - Add interior detail vertices for height accuracy, controlled by <code>detail_sample_dist</code> and <code>detail_sample_max_error</code></li>
<li><strong>Convert to NavMeshWorld</strong> - Build the engine's navmesh data structure with adjacency and spatial hash</li>
</ol>
<h3 id="pathfinding-algorithms"><a class="header" href="#pathfinding-algorithms">Pathfinding Algorithms</a></h3>
<p>Three algorithms are available:</p>
<p><strong>A*</strong> (default) - Explores nodes ordered by <code>f = g + h</code> where <code>g</code> is the cost so far and <code>h</code> is the heuristic (straight-line distance to goal). Finds the optimal path efficiently by prioritizing nodes closer to the destination.</p>
<p><strong>Dijkstra</strong> - Explores nodes ordered only by <code>g</code> cost, ignoring direction to goal. Explores more nodes but guarantees the shortest path even with complex cost functions.</p>
<p><strong>Greedy Best-First</strong> - Explores nodes ordered only by heuristic <code>h</code>, ignoring path cost. Very fast but may not find optimal paths, especially around concave obstacles.</p>
<p>All three operate on the triangle adjacency graph, where edges connect triangles that share an edge and costs are the distances between triangle centers.</p>
<h3 id="funnel-algorithm-path-smoothing"><a class="header" href="#funnel-algorithm-path-smoothing">Funnel Algorithm (Path Smoothing)</a></h3>
<p>Raw paths through the navmesh are sequences of triangle centers, which zig-zag unnecessarily. The <strong>funnel algorithm</strong> produces smooth, natural-looking paths:</p>
<ol>
<li><strong>Portal collection</strong> - Extract the shared edges (portals) between consecutive triangles in the path</li>
<li><strong>Funnel narrowing</strong> - Maintain a funnel (left and right boundaries) that starts wide at the first portal. As you advance through portals, narrow the funnel. When a portal would flip the funnel inside-out, emit the funnel apex as a waypoint and restart</li>
<li><strong>Simplification</strong> - Remove waypoints that don't improve the path within an epsilon tolerance (collinear point removal)</li>
</ol>
<p>The result is the shortest path through the triangle corridor that doesn't cross any triangle boundaries.</p>
<h3 id="agent-movement-system"><a class="header" href="#agent-movement-system">Agent Movement System</a></h3>
<p>Five systems run each frame via <code>run_navmesh_systems</code>:</p>
<ol>
<li><strong>Triangle tracking</strong> - Finds which navmesh triangle each agent currently occupies using point-in-triangle tests with barycentric coordinates</li>
<li><strong>Path processing</strong> - Agents in <code>PathPending</code> state get their path computed, smoothed, and simplified. State transitions to <code>Moving</code> or <code>NoPath</code></li>
<li><strong>Local avoidance</strong> - Repulsive forces between nearby agents (within <code>agent_radius * 2.5</code>) prevent crowding. Avoidance velocity is blended at 25% with the primary movement direction</li>
<li><strong>Movement</strong> - Advances agents along waypoints at their configured speed. Samples navmesh height at each new position using barycentric interpolation for vertical alignment. Maximum step height of 1.0 unit prevents teleporting through terrain</li>
<li><strong>Surface snapping</strong> - Idle and arrived agents are snapped to the navmesh surface when their Y position drifts more than 0.01 units</li>
</ol>
<h2 id="enabling-navmesh"><a class="header" href="#enabling-navmesh">Enabling NavMesh</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "navmesh"] }
</code></pre>
<h2 id="generating-a-navmesh"><a class="header" href="#generating-a-navmesh">Generating a NavMesh</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::navmesh::*;

fn setup_navmesh(world: &amp;mut World) {
    let config = RecastNavMeshConfig::default();
    generate_navmesh_recast(world, &amp;config);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navmesh-configuration"><a class="header" href="#navmesh-configuration">NavMesh Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RecastNavMeshConfig {
    pub agent_radius: f32,              // Character collision radius (0.4)
    pub agent_height: f32,              // Character height (1.8)
    pub cell_size_fraction: f32,        // XZ voxel resolution divisor (3.0)
    pub cell_height_fraction: f32,      // Y voxel resolution divisor (6.0)
    pub walkable_climb: f32,            // Max step height (0.4)
    pub walkable_slope_angle: f32,      // Max walkable slope in degrees (45)
    pub min_region_size: i32,           // Min region area (8)
    pub merge_region_size: i32,         // Region merge threshold (20)
    pub max_simplification_error: f32,  // Contour simplification (1.3)
    pub max_vertices_per_polygon: i32,  // Polygon complexity (6)
    pub detail_sample_dist: f32,        // Detail mesh sampling (6.0)
    pub detail_sample_max_error: f32,   // Detail mesh error (1.0)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-state-machine"><a class="header" href="#agent-state-machine">Agent State Machine</a></h2>
<pre><code>Idle → PathPending → Moving → Arrived
              ↓
           NoPath
</code></pre>
<h2 id="creating-agents"><a class="header" href="#creating-agents">Creating Agents</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let agent = spawn_navmesh_agent(world, position, speed);
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-destinations"><a class="header" href="#setting-destinations">Setting Destinations</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_agent_destination(world, agent, target_position);
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-navigation-system"><a class="header" href="#running-the-navigation-system">Running the Navigation System</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    run_navmesh_systems(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-agent-status"><a class="header" href="#checking-agent-status">Checking Agent Status</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match get_agent_state(world, agent) {
    NavMeshAgentState::Idle =&gt; { /* waiting */ }
    NavMeshAgentState::PathPending =&gt; { /* computing */ }
    NavMeshAgentState::Moving =&gt; { /* walking */ }
    NavMeshAgentState::Arrived =&gt; { /* at destination */ }
    NavMeshAgentState::NoPath =&gt; { /* unreachable */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="patrol-behavior"><a class="header" href="#patrol-behavior">Patrol Behavior</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PatrolBehavior {
    waypoints: Vec&lt;Vec3&gt;,
    current_waypoint: usize,
}

fn update_patrol(world: &amp;mut World, agent: Entity, patrol: &amp;mut PatrolBehavior) {
    if matches!(get_agent_state(world, agent), NavMeshAgentState::Arrived) {
        patrol.current_waypoint = (patrol.current_waypoint + 1) % patrol.waypoints.len();
        set_agent_destination(world, agent, patrol.waypoints[patrol.current_waypoint]);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization-1"><a class="header" href="#debug-visualization-1">Debug Visualization</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_navmesh_debug_draw(world, true);
<span class="boring">}</span></code></pre></pre>
<p>The debug visualization draws:</p>
<ul>
<li>Navmesh triangles as green wireframe (offset 0.15 units above surface)</li>
<li>Agent paths as yellow lines between waypoints</li>
<li>Current path segment as cyan from agent to next waypoint</li>
<li>Waypoints as orange crosses</li>
<li>Destination as a magenta diamond marker with a vertical pole</li>
</ul>
<h2 id="navmeshworld-resource"><a class="header" href="#navmeshworld-resource">NavMeshWorld Resource</a></h2>
<p>The generated navmesh is stored in <code>world.resources.navmesh</code> as a <code>NavMeshWorld</code>:</p>
<ul>
<li><strong>Vertices</strong> - All navmesh vertex positions</li>
<li><strong>Triangles</strong> - Walkable triangles with center, normal, area, and edge indices</li>
<li><strong>Edges</strong> - Triangle edges with indices of the two triangles they belong to (for portal detection)</li>
<li><strong>Adjacency</strong> - <code>HashMap&lt;usize, Vec&lt;NavMeshConnection&gt;&gt;</code> mapping each triangle to its neighbors with traversal costs</li>
<li><strong>Spatial Hash</strong> - Grid-based spatial index for fast point-in-triangle queries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grass-system"><a class="header" href="#grass-system">Grass System</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/grass">Grass</a></p>
</blockquote>
<p>GPU-accelerated grass rendering with wind animation, character interaction, LOD, and subsurface scattering.</p>
<h2 id="how-grass-rendering-works"><a class="header" href="#how-grass-rendering-works">How Grass Rendering Works</a></h2>
<p>The grass system renders up to 500,000 blades using a multi-stage compute + render pipeline. Each blade is a 7-vertex triangle strip generated in the vertex shader from per-instance data stored in GPU storage buffers.</p>
<h3 id="rendering-pipeline"><a class="header" href="#rendering-pipeline">Rendering Pipeline</a></h3>
<p>Each frame executes five stages:</p>
<ol>
<li>
<p><strong>Interaction update</strong> (compute, 16x16 workgroups) - Updates a 128x128 bend map texture from interactor positions. Each texel stores an XZ displacement vector. Interactors (player, NPCs) apply force based on proximity with smooth falloff. Velocity influences strength: <code>strength * (1 + velocity_length * 0.3)</code>. Previous-frame bend values decay at a configurable rate, creating persistent trails. Double-buffered (ping-pong) to avoid read-write hazards.</p>
</li>
<li>
<p><strong>Bend sampling</strong> (compute, instances/256 workgroups) - Each grass instance samples the bend map at its world position to get an XZ displacement vector, stored in the instance buffer's <code>bend</code> field.</p>
</li>
<li>
<p><strong>Reset</strong> (compute, 1 workgroup) - Atomically resets the indirect draw command's instance count to zero.</p>
</li>
<li>
<p><strong>Culling</strong> (compute, instances/256 workgroups) - Each blade is tested against the camera frustum using its center position plus a radius. Blades outside the frustum are discarded. Distance-based LOD selects a density scale from 4 configurable thresholds. Statistical culling uses a hash of the instance ID: <code>hash(id) &gt; density_scale</code> skips the blade. Surviving blades are appended to a visible index buffer via atomic operations, capped at 200,000.</p>
</li>
<li>
<p><strong>Render</strong> - Triangle strip rendering using indirect draw with the culled instance count. Each blade generates 7 vertices: 2 base (wide), 2 mid (narrowing), 2 upper (narrower), 1 tip point. The vertex shader applies width narrowing and curvature per segment, rotates around the Y-axis using the instance's random rotation, displaces by wind and interaction bend, and outputs a height factor for color interpolation.</p>
</li>
</ol>
<h3 id="blade-geometry"><a class="header" href="#blade-geometry">Blade Geometry</a></h3>
<p>Each blade is a curved triangle strip with width tapering from base to tip:</p>
<pre><code>    *          (tip, 1 vertex)
   / \
  /   \        (upper, 2 vertices)
 /     \
|       |      (mid, 2 vertices)
|       |
|_______|      (base, 2 vertices)
</code></pre>
<p>Curvature is applied per-segment by offsetting vertices forward based on their height squared, creating a natural forward lean.</p>
<h3 id="wind-animation"><a class="header" href="#wind-animation">Wind Animation</a></h3>
<p>Wind uses multi-layered sine waves in the vertex shader:</p>
<ul>
<li><strong>Base wave</strong>: <code>sin(position.x * frequency + time * speed)</code> at the configured strength</li>
<li><strong>Gust layer</strong>: Higher frequency oscillation layered on top</li>
</ul>
<p>Wind displacement scales with the square of the blade's height factor, so the base stays anchored while the tip sways. The <code>wind_direction</code> vector controls the primary direction on the XZ plane.</p>
<h3 id="interaction-bend"><a class="header" href="#interaction-bend">Interaction Bend</a></h3>
<p>The bend map is a 128x128 <code>RG32Float</code> storage texture covering the grass region. When an interactor (entity with <code>GrassInteractor</code> component) moves through the grass:</p>
<ol>
<li>The compute shader samples each texel's distance to each interactor</li>
<li>Within the interactor's radius, a smooth-step falloff function computes a bend direction away from the interactor</li>
<li>The bend accumulates with the existing value (from previous frames)</li>
<li>A decay rate gradually returns the bend to zero, creating a visible recovery trail</li>
</ol>
<p>In the vertex shader, the bend displacement is applied with quadratic falloff based on height: the base barely moves while the tip receives full displacement.</p>
<h3 id="kajiya-kay-specular"><a class="header" href="#kajiya-kay-specular">Kajiya-Kay Specular</a></h3>
<p>The fragment shader implements <strong>Kajiya-Kay anisotropic specular</strong> lighting, originally developed for hair rendering. Instead of computing a standard Phong or GGX specular highlight, it uses the blade's tangent direction to produce elongated highlights that run perpendicular to the blade direction, mimicking how light reflects off thin strands.</p>
<h3 id="subsurface-scattering"><a class="header" href="#subsurface-scattering">Subsurface Scattering</a></h3>
<p>Light passing through grass blades creates a bright rim when the sun is behind the blade relative to the camera. The fragment shader computes a subsurface scattering contribution based on the dot product between the view direction and the negated sun direction, with edge fade for natural falloff. The <code>sss_color</code> and <code>sss_intensity</code> per-species parameters control the appearance.</p>
<h3 id="distance-fade"><a class="header" href="#distance-fade">Distance Fade</a></h3>
<p>Blades beyond 180m begin alpha fading, reaching full transparency at 200m (smoothstep). Blade tips also have a separate fade (smoothstep 0.9-1.0 of the height factor) for soft tip transparency.</p>
<h2 id="enabling-grass"><a class="header" href="#enabling-grass">Enabling Grass</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "grass"] }
</code></pre>
<h2 id="basic-grass-region"><a class="header" href="#basic-grass-region">Basic Grass Region</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::grass::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let config = GrassConfig::default();
    spawn_grass_region(world, config);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-configuration"><a class="header" href="#grass-configuration">Grass Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GrassConfig {
    pub blades_per_patch: u32,        // Density (default: 64)
    pub patch_size: f32,              // Patch size (default: 8.0)
    pub stream_radius: f32,           // Render distance (default: 200.0)
    pub unload_radius: f32,           // Unload distance (default: 220.0)
    pub wind_strength: f32,           // Wind intensity (default: 1.0)
    pub wind_frequency: f32,          // Wind speed (default: 1.0)
    pub wind_direction: [f32; 2],     // XZ direction (default: [1.0, 0.0])
    pub interaction_radius: f32,      // Player interaction radius (default: 1.0)
    pub interaction_strength: f32,    // Bending strength (default: 1.0)
    pub interactors_enabled: bool,    // Enable grass bending (default: true)
    pub cast_shadows: bool,           // Shadow casting (default: true)
    pub receive_shadows: bool,        // Shadow receiving (default: true)
    pub lod_distances: [f32; 4],      // LOD thresholds
    pub lod_density_scales: [f32; 4], // Density at each LOD
}
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-species"><a class="header" href="#grass-species">Grass Species</a></h2>
<p>Define visual characteristics:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GrassSpecies {
    pub blade_width: f32,
    pub blade_height_min: f32,
    pub blade_height_max: f32,
    pub blade_curvature: f32,
    pub base_color: [f32; 4],
    pub tip_color: [f32; 4],
    pub sss_color: [f32; 4],        // Subsurface scattering color
    pub sss_intensity: f32,
    pub specular_power: f32,         // Kajiya-Kay exponent
    pub specular_strength: f32,
    pub density_scale: f32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preset-species"><a class="header" href="#preset-species">Preset Species</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>GrassSpecies::meadow()   // Short, dense lawn
GrassSpecies::tall()     // Tall field grass
GrassSpecies::short()    // Very short grass
GrassSpecies::flowers()  // Colorful flowers mixed with grass
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-species-grass"><a class="header" href="#multi-species-grass">Multi-Species Grass</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = spawn_grass_region(world, config);

add_grass_species(world, entity, GrassSpecies::meadow(), 0.6);
add_grass_species(world, entity, GrassSpecies::flowers(), 0.4);
<span class="boring">}</span></code></pre></pre>
<h2 id="wind-control"><a class="header" href="#wind-control">Wind Control</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_grass_wind(world, entity, 1.5, 2.0);
set_grass_wind_direction(world, entity, 1.0, 0.5);
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-interaction"><a class="header" href="#grass-interaction">Grass Interaction</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>attach_grass_interactor(world, player_entity, 1.0, 1.0);
<span class="boring">}</span></code></pre></pre>
<p>Or spawn a standalone interactor:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let interactor = spawn_grass_interactor(world, 1.0, 1.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="lod-system"><a class="header" href="#lod-system">LOD System</a></h2>
<p>Statistical density culling reduces blade count at distance:</p>
<div class="table-wrapper"><table><thead><tr><th>LOD Level</th><th>Default Distance</th><th>Default Density</th></tr></thead><tbody>
<tr><td>0</td><td>0-20m</td><td>100%</td></tr>
<tr><td>1</td><td>20-50m</td><td>60%</td></tr>
<tr><td>2</td><td>50-100m</td><td>30%</td></tr>
<tr><td>3</td><td>100-200m</td><td>10%</td></tr>
</tbody></table>
</div>
<p>Transitions are smooth because culling uses a per-instance hash compared against the density threshold. No popping artifacts.</p>
<h2 id="shadow-casting-1"><a class="header" href="#shadow-casting-1">Shadow Casting</a></h2>
<p>Grass uses a separate shadow depth shader (<code>grass_shadow_depth.wgsl</code>) that generates simplified blades (fixed curvature 0.3) with the same wind animation, projected into light space. This shader writes only depth, no color.</p>
<h2 id="capacity-1"><a class="header" href="#capacity-1">Capacity</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Limit</th><th>Value</th></tr></thead><tbody>
<tr><td>Maximum blades</td><td>500,000</td></tr>
<tr><td>Maximum visible per frame</td><td>200,000</td></tr>
<tr><td>Vertices per blade</td><td>7 (triangle strip)</td></tr>
<tr><td>Maximum species</td><td>8</td></tr>
<tr><td>Maximum interactors</td><td>16</td></tr>
<tr><td>Heightmap resolution</td><td>256 x 256</td></tr>
<tr><td>Bend map resolution</td><td>128 x 128</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lines-rendering"><a class="header" href="#lines-rendering">Lines Rendering</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/lines">Lines</a></p>
</blockquote>
<p>Debug line drawing for visualization, gizmos, and wireframes.</p>
<h2 id="how-lines-rendering-works"><a class="header" href="#how-lines-rendering-works">How Lines Rendering Works</a></h2>
<p>The lines system is a GPU-driven rendering pipeline that uses instanced rendering with compute-based frustum culling. Rather than submitting geometry for each line, the engine uploads all line data to a GPU storage buffer and renders them using a two-vertex line primitive with one instance per line.</p>
<h3 id="the-two-vertex-trick"><a class="header" href="#the-two-vertex-trick">The Two-Vertex Trick</a></h3>
<p>The vertex buffer contains only two vertices: position <code>[0, 0, 0]</code> and position <code>[1, 0, 0]</code>. Every line in the scene reuses these same two vertices through instancing. The vertex shader uses the instance index to look up the actual line data (start, end, color) from a storage buffer, then uses the vertex position's X coordinate (0.0 or 1.0) to interpolate between start and end:</p>
<pre><code class="language-wgsl">let line = lines[in.instance_index];
let pos = mix(line.start.xyz, line.end.xyz, in.position.x);
out.clip_position = uniforms.view_proj * vec4&lt;f32&gt;(pos, 1.0);
out.color = line.color;
</code></pre>
<p>This means rendering 100,000 lines requires only 2 vertices in GPU memory regardless of line count. All line data lives in a storage buffer that grows dynamically (starting at 1,024 lines, doubling as needed, up to 1,000,000).</p>
<h3 id="gpu-frustum-culling"><a class="header" href="#gpu-frustum-culling">GPU Frustum Culling</a></h3>
<p>A compute shader (<code>line_culling_gpu.wgsl</code>) runs before the render pass to determine which lines are visible. For each line, it tests both endpoints against the camera frustum planes. If either endpoint is inside the frustum, the line is visible. If neither is, the shader samples 8 intermediate points along the line segment to catch lines that span across the view without either endpoint being visible.</p>
<p>Visible lines generate <code>DrawIndexedIndirectCommand</code> structs via atomic append:</p>
<pre><code class="language-wgsl">let command_index = atomicAdd(&amp;draw_count, 1u);
draw_commands[command_index].index_count = 2u;
draw_commands[command_index].instance_count = 1u;
draw_commands[command_index].first_instance = line_index;
</code></pre>
<p>The render pass then executes these commands with <code>multi_draw_indexed_indirect_count</code> (or <code>multi_draw_indexed_indirect</code> on macOS/WASM/OpenXR where count buffers are unavailable).</p>
<h3 id="bounding-volume-lines"><a class="header" href="#bounding-volume-lines">Bounding Volume Lines</a></h3>
<p>When <code>show_bounding_volumes</code> is enabled, a separate compute shader (<code>bounding_volume_lines.wgsl</code>) generates wireframe lines from entity OBBs (Oriented Bounding Boxes). Each bounding volume produces exactly 12 edge lines. The shader:</p>
<ol>
<li>Computes the 8 OBB corners using quaternion rotation in local space</li>
<li>Transforms all corners to world space via the entity's model matrix</li>
<li>Writes 12 edge lines (the box wireframe) into the line buffer at a pre-allocated offset</li>
</ol>
<h3 id="normal-visualization-lines"><a class="header" href="#normal-visualization-lines">Normal Visualization Lines</a></h3>
<p>Another compute shader (<code>normal_lines.wgsl</code>) generates lines showing mesh surface normals. For each vertex, it:</p>
<ol>
<li>Transforms the vertex position to world space using the model matrix</li>
<li>Transforms the normal using the upper-left 3x3 of the model matrix (the normal matrix)</li>
<li>Computes the endpoint by extending along the normal by the configured length</li>
<li>Writes a single line from the vertex position to the endpoint</li>
</ol>
<h3 id="gpu-data-layout"><a class="header" href="#gpu-data-layout">GPU Data Layout</a></h3>
<p>Each line on the GPU is a 64-byte structure aligned to 16 bytes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GpuLineData {
    start: [f32; 4],      // World-space start + padding
    end: [f32; 4],        // World-space end + padding
    color: [f32; 4],      // RGBA color
    entity_id: u32,        // Source entity ID
    visible: u32,          // Visibility flag
    _padding: [u32; 2],
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-synchronization"><a class="header" href="#data-synchronization">Data Synchronization</a></h3>
<p>Each frame, <code>sync_lines_data</code> queries all entities with <code>LINES | GLOBAL_TRANSFORM | VISIBILITY</code> components, transforms each line's start and end positions to world space using the entity's global transform matrix, packs them into <code>GpuLineData</code> structs, and uploads them to the GPU via <code>queue.write_buffer</code>. The total buffer includes user lines, bounding volume lines, and normal visualization lines.</p>
<h2 id="lines-component"><a class="header" href="#lines-component">Lines Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lines {
    pub lines: Vec&lt;Line&gt;,
    pub version: u64,
}

pub struct Line {
    pub start: Vec3,
    pub end: Vec3,
    pub color: Vec4,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>version</code> field is a dirty counter. Calling <code>push()</code>, <code>clear()</code>, or <code>mark_dirty()</code> increments it, enabling the renderer to detect changes and skip re-uploading unchanged line data.</p>
<h2 id="basic-line-drawing"><a class="header" href="#basic-line-drawing">Basic Line Drawing</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let entity = world.spawn_entities(LINES, 1)[0];

    let mut lines = Lines::new();
    lines.add(
        Vec3::new(0.0, 0.0, 0.0),
        Vec3::new(1.0, 1.0, 1.0),
        Vec4::new(1.0, 0.0, 0.0, 1.0),
    );

    world.set_lines(entity, lines);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-lines"><a class="header" href="#adding-lines">Adding Lines</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut lines = Lines::new();

// Single line
lines.add(start, end, color);

// Coordinate axes
lines.add(Vec3::zeros(), Vec3::x(), Vec4::new(1.0, 0.0, 0.0, 1.0));
lines.add(Vec3::zeros(), Vec3::y(), Vec4::new(0.0, 1.0, 0.0, 1.0));
lines.add(Vec3::zeros(), Vec3::z(), Vec4::new(0.0, 0.0, 1.0, 1.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="drawing-shapes"><a class="header" href="#drawing-shapes">Drawing Shapes</a></h2>
<h3 id="wireframe-box"><a class="header" href="#wireframe-box">Wireframe Box</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_box(lines: &amp;mut Lines, center: Vec3, half_extents: Vec3, color: Vec4) {
    let min = center - half_extents;
    let max = center + half_extents;

    // Bottom face
    lines.add(Vec3::new(min.x, min.y, min.z), Vec3::new(max.x, min.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, min.z), Vec3::new(max.x, min.y, max.z), color);
    lines.add(Vec3::new(max.x, min.y, max.z), Vec3::new(min.x, min.y, max.z), color);
    lines.add(Vec3::new(min.x, min.y, max.z), Vec3::new(min.x, min.y, min.z), color);

    // Top face
    lines.add(Vec3::new(min.x, max.y, min.z), Vec3::new(max.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, max.y, min.z), Vec3::new(max.x, max.y, max.z), color);
    lines.add(Vec3::new(max.x, max.y, max.z), Vec3::new(min.x, max.y, max.z), color);
    lines.add(Vec3::new(min.x, max.y, max.z), Vec3::new(min.x, max.y, min.z), color);

    // Vertical edges
    lines.add(Vec3::new(min.x, min.y, min.z), Vec3::new(min.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, min.z), Vec3::new(max.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, max.z), Vec3::new(max.x, max.y, max.z), color);
    lines.add(Vec3::new(min.x, min.y, max.z), Vec3::new(min.x, max.y, max.z), color);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wireframe-sphere"><a class="header" href="#wireframe-sphere">Wireframe Sphere</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sphere(lines: &amp;mut Lines, center: Vec3, radius: f32, color: Vec4, segments: u32) {
    let step = std::f32::consts::TAU / segments as f32;

    for index in 0..segments {
        let angle1 = index as f32 * step;
        let angle2 = (index + 1) as f32 * step;

        // XY circle
        let p1 = center + Vec3::new(angle1.cos() * radius, angle1.sin() * radius, 0.0);
        let p2 = center + Vec3::new(angle2.cos() * radius, angle2.sin() * radius, 0.0);
        lines.add(p1, p2, color);

        // XZ circle
        let p1 = center + Vec3::new(angle1.cos() * radius, 0.0, angle1.sin() * radius);
        let p2 = center + Vec3::new(angle2.cos() * radius, 0.0, angle2.sin() * radius);
        lines.add(p1, p2, color);

        // YZ circle
        let p1 = center + Vec3::new(0.0, angle1.cos() * radius, angle1.sin() * radius);
        let p2 = center + Vec3::new(0.0, angle2.cos() * radius, angle2.sin() * radius);
        lines.add(p1, p2, color);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-lines-each-frame"><a class="header" href="#updating-lines-each-frame">Updating Lines Each Frame</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(lines) = world.get_lines_mut(self.debug_lines) {
        lines.clear();

        for entity in world.query_entities(RIGID_BODY | LOCAL_TRANSFORM) {
            if let (Some(body), Some(transform)) = (
                world.get_rigid_body(entity),
                world.get_local_transform(entity),
            ) {
                let start = transform.translation;
                let end = start + body.velocity;
                lines.add(start, end, Vec4::new(1.0, 1.0, 0.0, 1.0));
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-debug-visualization"><a class="header" href="#built-in-debug-visualization">Built-in Debug Visualization</a></h2>
<h3 id="bounding-volumes"><a class="header" href="#bounding-volumes">Bounding Volumes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_bounding_volumes = true;
<span class="boring">}</span></code></pre></pre>
<h3 id="selected-entity-bounds"><a class="header" href="#selected-entity-bounds">Selected Entity Bounds</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_selected_bounding_volume = true;
world.resources.graphics.bounding_volume_selected_entity = Some(entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="surface-normals"><a class="header" href="#surface-normals">Surface Normals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_normals = true;
world.resources.graphics.normal_line_length = 0.2;
world.resources.graphics.normal_line_color = [0.0, 1.0, 0.0, 1.0];
<span class="boring">}</span></code></pre></pre>
<h2 id="gpu-culling"><a class="header" href="#gpu-culling">GPU Culling</a></h2>
<p>Lines are frustum-culled on the GPU via a compute shader. Toggle this with:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.gpu_culling_enabled = true;
<span class="boring">}</span></code></pre></pre>
<p>When enabled, only lines visible to the camera are drawn. The compute shader outputs indirect draw commands, so the CPU never needs to know which lines survived culling.</p>
<h2 id="line-limits"><a class="header" href="#line-limits">Line Limits</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_LINES: u32 = 1_000_000;
<span class="boring">}</span></code></pre></pre>
<p>The buffer starts at 1,024 lines and grows by 2x when capacity is exceeded.</p>
<h2 id="transform-gizmos"><a class="header" href="#transform-gizmos">Transform Gizmos</a></h2>
<p>Built-in gizmos for entity manipulation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::gizmos::*;

create_translation_gizmo(world, entity);
create_rotation_gizmo(world, entity);
create_scale_gizmo(world, entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-pipeline-1"><a class="header" href="#rendering-pipeline-1">Rendering Pipeline</a></h2>
<p>The lines pass fits into the render graph as a geometry pass that writes to <code>scene_color</code> and <code>depth</code>. The execution order each frame is:</p>
<ol>
<li>Generate bounding volume lines (compute shader, 64 threads/workgroup, 12 lines per bounding volume)</li>
<li>Generate normal visualization lines (compute shader, 256 threads/workgroup, 1 line per vertex)</li>
<li>Frustum cull all lines (compute shader, 256 threads/workgroup, outputs indirect draw commands)</li>
<li>Render visible lines (instanced <code>LineList</code> primitive with alpha blending and <code>GreaterEqual</code> depth test for reversed-Z)</li>
</ol>
<p>The render pipeline uses <code>wgpu::PrimitiveTopology::LineList</code>, draws indices 0-1 per instance, and routes each instance to the correct line data via <code>first_instance</code> in the indirect draw command. The fragment shader is a simple color passthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="picking-system"><a class="header" href="#picking-system">Picking System</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/picking">Picking</a></p>
</blockquote>
<p>Picking allows you to select entities in the 3D world using mouse clicks or screen positions. Nightshade provides two picking methods: fast bounding volume ray intersection and precise triangle mesh raycasting via Rapier physics colliders.</p>
<h2 id="how-picking-works"><a class="header" href="#how-picking-works">How Picking Works</a></h2>
<h3 id="screen-to-ray-conversion"><a class="header" href="#screen-to-ray-conversion">Screen-to-Ray Conversion</a></h3>
<p><code>PickingRay::from_screen_position</code> converts a 2D screen coordinate into a 3D ray. It computes NDC coordinates from the screen position, builds the inverse view-projection matrix from the active camera, then unprojects through it:</p>
<ul>
<li><strong>Perspective cameras</strong>: The ray origin is the camera position. A clip-space point at <code>z=1.0</code> (reversed-Z near plane) is unprojected to get the world direction.</li>
<li><strong>Orthographic cameras</strong>: Both near (<code>z=1.0</code>) and far (<code>z=0.0</code>) clip-space points are unprojected. The ray origin is the near point; the direction is the vector from near to far.</li>
</ul>
<p>Viewport rectangles are handled by converting screen coordinates to local viewport space and scaling by the viewport-to-window ratio.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PickingRay {
    pub origin: Vec3,
    pub direction: Vec3,
}

let screen_pos = world.resources.input.mouse.position;
if let Some(ray) = PickingRay::from_screen_position(world, screen_pos) {
    // ray.origin and ray.direction are in world space
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounding-volume-picking-fast"><a class="header" href="#bounding-volume-picking-fast">Bounding Volume Picking (Fast)</a></h3>
<p>The fast picking path tests the ray against every entity's bounding volume. For each entity with a <code>BoundingVolume</code> component:</p>
<ol>
<li>Transform the bounding volume by the entity's global transform</li>
<li>Early reject using a bounding sphere test (project center onto ray, check distance)</li>
<li>Test against the oriented bounding box (OBB) for a precise intersection distance</li>
<li>Optionally skip invisible entities via the <code>Visibility</code> component</li>
</ol>
<p>Results are sorted by distance (closest first).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(hit) = pick_closest_entity(world, screen_pos) {
    let entity = hit.entity;
    let distance = hit.distance;
    let position = hit.world_position;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pick-all-entities"><a class="header" href="#pick-all-entities">Pick All Entities</a></h3>
<p>Return all entities hit by the ray, sorted by distance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hits = pick_entities(world, screen_pos, PickingOptions::default());

for hit in &amp;hits {
    let entity = hit.entity;
    let distance = hit.distance;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="picking-options"><a class="header" href="#picking-options">Picking Options</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PickingOptions {
    pub max_distance: f32,       // Maximum ray distance (default: infinity)
    pub ignore_invisible: bool,  // Skip entities with Visibility { visible: false } (default: true)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="triangle-mesh-picking-precise"><a class="header" href="#triangle-mesh-picking-precise">Triangle Mesh Picking (Precise)</a></h2>
<p>For pixel-precise picking, register entities for trimesh picking. This creates a Rapier physics collider from the entity's mesh geometry in a dedicated <code>PickingWorld</code> collision set.</p>
<h3 id="registering-entities"><a class="header" href="#registering-entities">Registering Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::picking::commands::*;

register_entity_for_trimesh_picking(world, entity);
<span class="boring">}</span></code></pre></pre>
<p>This extracts the mesh vertices and indices from the entity's <code>RenderMesh</code>, applies the global transform's scale, and creates a <code>SharedShape::trimesh</code> collider positioned at the entity's world transform. The collider is stored in the <code>PickingWorld</code> resource (a <code>ColliderSet</code> with entity-to-handle mappings).</p>
<p>For hierarchies (parent with child meshes):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>register_entity_hierarchy_for_trimesh_picking(world, root_entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="trimesh-raycasting"><a class="header" href="#trimesh-raycasting">Trimesh Raycasting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(hit) = pick_closest_entity_trimesh(world, screen_pos) {
    let entity = hit.entity;
    let distance = hit.distance;
    let position = hit.world_position;
}
<span class="boring">}</span></code></pre></pre>
<p>This casts a Rapier ray against all registered trimesh colliders using <code>shape.cast_ray()</code>, returning the time of impact for each intersection.</p>
<h3 id="updating-transforms"><a class="header" href="#updating-transforms">Updating Transforms</a></h3>
<p>When a pickable entity moves, update its collider position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>update_picking_transform(world, entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="unregistering"><a class="header" href="#unregistering">Unregistering</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unregister_entity_from_picking(world, entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="pick-result"><a class="header" href="#pick-result">Pick Result</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PickingResult {
    pub entity: Entity,
    pub distance: f32,
    pub world_position: Vec3,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<h3 id="ground-plane-intersection"><a class="header" href="#ground-plane-intersection">Ground Plane Intersection</a></h3>
<p>Get the world position where a screen ray hits a horizontal plane:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(ground_pos) = get_ground_position_from_screen(world, screen_pos, 0.0) {
    // ground_pos is on the Y=0 plane
}
<span class="boring">}</span></code></pre></pre>
<h3 id="frustum-picking"><a class="header" href="#frustum-picking">Frustum Picking</a></h3>
<p>Test which entities from a list are visible in the camera frustum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let visible = pick_entities_in_frustum(world, &amp;entity_list);
<span class="boring">}</span></code></pre></pre>
<p>This projects each entity's bounding sphere center into clip space and tests against NDC bounds, accounting for the sphere radius in NDC space.</p>
<h3 id="plane-intersection"><a class="header" href="#plane-intersection">Plane Intersection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ray = PickingRay::from_screen_position(world, screen_pos)?;

// Intersect with any plane (normal + distance from origin)
if let Some(point) = ray.intersect_plane(Vec3::y(), 0.0) {
    // point is on the plane
}

// Shorthand for horizontal ground plane
if let Some(point) = ray.intersect_ground_plane(0.0) {
    // point is on Y=0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mouse-click-selection"><a class="header" href="#mouse-click-selection">Mouse Click Selection</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
    if button == MouseButton::Left &amp;&amp; state == ElementState::Pressed {
        let screen_pos = world.resources.input.mouse.position;

        if let Some(hit) = pick_closest_entity(world, screen_pos) {
            self.selected_entity = Some(hit.entity);
        } else {
            self.selected_entity = None;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdf-sculpting"><a class="header" href="#sdf-sculpting">SDF Sculpting</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/voxels">Voxels</a></p>
</blockquote>
<p>Nightshade includes a voxel-based Signed Distance Field (SDF) system for real-time terrain sculpting and procedural geometry. The system stores distance values in a sparse brick map organized as a multi-level clipmap, with edits applied as CSG operations on SDF primitives and re-evaluated on the GPU each frame.</p>
<h2 id="enabling-sdf"><a class="header" href="#enabling-sdf">Enabling SDF</a></h2>
<p>Add the <code>sdf_sculpt</code> feature:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "sdf_sculpt"] }
</code></pre>
<h2 id="how-the-sdf-system-works"><a class="header" href="#how-the-sdf-system-works">How the SDF System Works</a></h2>
<h3 id="sparse-brick-map"><a class="header" href="#sparse-brick-map">Sparse Brick Map</a></h3>
<p>The SDF volume is stored as a sparse grid of bricks. Each brick covers an 8-voxel cube (8x8x8 voxels) with 9x9x9 corner distance samples. The extra corners provide overlap for trilinear interpolation across brick boundaries.</p>
<p>Each <code>BrickData</code> stores:</p>
<ul>
<li><code>distances: [f32; 729]</code> (9^3 corner samples) — signed distance values at each corner</li>
<li><code>material_ids: [u32; 512]</code> (8^3 voxel cells) — material index per voxel</li>
</ul>
<p>A <code>BrickPointerGrid</code> maps 3D brick coordinates to atlas slots using a 128x128x128 virtual grid with toroidal wrapping. Unoccupied bricks store -1 (empty). The brick atlas is a 3D texture: 450x450x450 texels on native (360x360x360 on WASM), subdivided into 50x50x50 brick slots of 9 texels each, for a maximum of 125,000 bricks.</p>
<h3 id="clipmap-lod"><a class="header" href="#clipmap-lod">Clipmap LOD</a></h3>
<p>The SDF uses a clipmap with 10 levels of detail (configurable via <code>SdfWorld::with_config</code>). Each level doubles the voxel size from the previous:</p>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Voxel Size</th><th>Brick Coverage</th><th>Grid Extent</th></tr></thead><tbody>
<tr><td>0</td><td>0.125</td><td>1.0</td><td>128.0</td></tr>
<tr><td>1</td><td>0.25</td><td>2.0</td><td>256.0</td></tr>
<tr><td>2</td><td>0.5</td><td>4.0</td><td>512.0</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
<tr><td>9</td><td>64.0</td><td>512.0</td><td>65,536.0</td></tr>
</tbody></table>
</div>
<p>The clipmap centers on the camera position. When the camera moves, bricks that scroll out of a level's grid are deallocated and returned to the free list. Newly scrolled-in bricks are marked dirty and re-evaluated. A BVH over all edit bounds accelerates this: only bricks whose expanded AABB intersects at least one edit's bounds are marked dirty.</p>
<h3 id="brick-allocation"><a class="header" href="#brick-allocation">Brick Allocation</a></h3>
<p>A <code>BrickAllocator</code> manages atlas slots with a free list. When a dirty brick is evaluated and contains surface data (has both positive and negative distance values), it gets allocated a slot. Bricks with no surface are left empty. When bricks scroll out of the grid, their slots are returned to the free list for reuse.</p>
<h3 id="gpu-dispatch"><a class="header" href="#gpu-dispatch">GPU Dispatch</a></h3>
<p>Each frame, <code>SdfWorld::update()</code> collects dirty bricks across all clipmap levels and creates <code>GpuBrickDispatch</code> records sorted by distance from the camera (closest bricks evaluated first). A per-frame budget (<code>max_updates_per_frame</code>, default 4000) limits how many bricks are re-evaluated.</p>
<h2 id="sdf-world"><a class="header" href="#sdf-world">SDF World</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SdfWorld {
    pub edits: Vec&lt;SdfEdit&gt;,
    pub clipmap: SdfClipmap,
    pub bvh: SdfEditBvh,
    pub dirty: bool,
    pub pending_gpu_dispatches: Vec&lt;GpuBrickDispatch&gt;,
    pub max_updates_per_frame: usize,
    pub terrain: TerrainConfig,
    pub smoothness_scale: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>Create with default settings (10 levels, base voxel size 0.125):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sdf_world = SdfWorld::new();
<span class="boring">}</span></code></pre></pre>
<p>Or with custom LOD configuration:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sdf_world = SdfWorld::with_config(8, 0.25);
<span class="boring">}</span></code></pre></pre>
<h2 id="sdf-primitives"><a class="header" href="#sdf-primitives">SDF Primitives</a></h2>
<p>Six primitive shapes are available, each with an analytic distance function evaluated in local space:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SdfPrimitive {
    Sphere { radius: f32 },
    Box { half_extents: Vec3 },
    Cylinder { radius: f32, half_height: f32 },
    Torus { major_radius: f32, minor_radius: f32 },
    Capsule { radius: f32, half_height: f32 },
    Plane { normal: Vec3, offset: f32 },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sphere"><a class="header" href="#sphere">Sphere</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Sphere { radius: 1.0 }
<span class="boring">}</span></code></pre></pre>
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Box {
    half_extents: Vec3::new(1.0, 2.0, 0.5)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cylinder-1"><a class="header" href="#cylinder-1">Cylinder</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Cylinder {
    radius: 1.0,
    half_height: 1.5
}
<span class="boring">}</span></code></pre></pre>
<h3 id="torus"><a class="header" href="#torus">Torus</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Torus {
    major_radius: 2.0,
    minor_radius: 0.5
}
<span class="boring">}</span></code></pre></pre>
<h3 id="capsule-1"><a class="header" href="#capsule-1">Capsule</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Capsule {
    radius: 0.5,
    half_height: 1.0
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plane"><a class="header" href="#plane">Plane</a></h3>
<p>An infinite half-space defined by a normal direction and offset:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SdfPrimitive::Plane {
    normal: Vec3::new(0.0, 1.0, 0.0),
    offset: 0.0,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="csg-operations"><a class="header" href="#csg-operations">CSG Operations</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CsgOperation {
    Union,
    Subtraction,
    Intersection,
    SmoothUnion { smoothness: f32 },
    SmoothSubtraction { smoothness: f32 },
    SmoothIntersection { smoothness: f32 },
}
<span class="boring">}</span></code></pre></pre>
<p>The hard operations use min/max:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Formula</th></tr></thead><tbody>
<tr><td>Union</td><td><code>min(a, b)</code></td></tr>
<tr><td>Subtraction</td><td><code>max(a, -b)</code></td></tr>
<tr><td>Intersection</td><td><code>max(a, b)</code></td></tr>
</tbody></table>
</div>
<p>The smooth variants use polynomial smooth min (<code>h = clamp(0.5 + 0.5*(b-a)/k, 0, 1)</code>) for organic blending between shapes. The <code>smoothness</code> parameter controls the blend radius — larger values create a wider transition zone.</p>
<p>Material blending during smooth operations uses a dither threshold: when the blend factor exceeds 0.5, the first material is used; otherwise the second.</p>
<h2 id="sdf-edits"><a class="header" href="#sdf-edits">SDF Edits</a></h2>
<p>An <code>SdfEdit</code> combines a primitive, a CSG operation, a 4x4 transform, and a material ID. The transform is stored alongside its precomputed inverse and uniform scale factor for efficient evaluation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let edit = SdfEdit::union(
    SdfPrimitive::Sphere { radius: 2.0 },
    nalgebra_glm::translation(&amp;Vec3::new(0.0, 5.0, 0.0)),
    material_id,
);

let edit = SdfEdit::smooth_subtraction(
    SdfPrimitive::Sphere { radius: 1.5 },
    nalgebra_glm::translation(&amp;position),
    0,
    0.5,
);

let edit = SdfEdit::from_operation(
    SdfPrimitive::Box { half_extents: Vec3::new(1.0, 1.0, 1.0) },
    CsgOperation::SmoothUnion { smoothness: 0.3 },
    transform,
    material_id,
);
<span class="boring">}</span></code></pre></pre>
<p>To evaluate an edit at a world-space point, the point is transformed into local space via the inverse matrix, the primitive's distance function is evaluated, and the result is scaled by the uniform scale factor.</p>
<h2 id="adding-and-modifying-edits"><a class="header" href="#adding-and-modifying-edits">Adding and Modifying Edits</a></h2>
<h3 id="convenience-methods"><a class="header" href="#convenience-methods">Convenience Methods</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.sdf_world.add_sphere(center, 2.0, material_id);
world.resources.sdf_world.add_box(center, half_extents, material_id);
world.resources.sdf_world.add_ground_plane(0.0, material_id);
world.resources.sdf_world.subtract_sphere(center, 1.5, 0.3);
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-edit-api"><a class="header" href="#direct-edit-api">Direct Edit API</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let index = world.resources.sdf_world.add_edit(edit);
<span class="boring">}</span></code></pre></pre>
<p>Each <code>add_edit</code> call pushes an undo action onto the undo stack and clears the redo stack. Use <code>add_edit_no_undo</code> to bypass undo tracking (useful for procedural generation).</p>
<h3 id="modifying-existing-edits"><a class="header" href="#modifying-existing-edits">Modifying Existing Edits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.sdf_world.modify_edit(index, |edit| {
    edit.set_transform(new_transform);
});
<span class="boring">}</span></code></pre></pre>
<p>This marks both the old and new bounds as dirty. Use <code>modify_edit_no_undo</code> for interactive sculpting where intermediate states shouldn't be individually undoable.</p>
<h3 id="removing-edits"><a class="header" href="#removing-edits">Removing Edits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.sdf_world.remove_edit(index);
<span class="boring">}</span></code></pre></pre>
<h2 id="undoredo"><a class="header" href="#undoredo">Undo/Redo</a></h2>
<p>The SDF world maintains undo and redo stacks (default max 100 entries):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.resources.sdf_world.can_undo() {
    world.resources.sdf_world.undo();
}

if world.resources.sdf_world.can_redo() {
    world.resources.sdf_world.redo();
}

world.resources.sdf_world.clear_undo_history();
<span class="boring">}</span></code></pre></pre>
<p>Three action types are tracked: <code>AddEdit</code>, <code>RemoveEdit</code>, and <code>ModifyEdit</code>. Each undo/redo operation re-marks the affected bounds as dirty and triggers re-evaluation.</p>
<h2 id="sdf-materials"><a class="header" href="#sdf-materials">SDF Materials</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SdfMaterial {
    pub base_color: Vec3,
    pub roughness: f32,
    pub metallic: f32,
    pub emissive: Vec3,
}
<span class="boring">}</span></code></pre></pre>
<p>Materials are managed through the <code>SdfMaterialRegistry</code> resource. A default material (gray, roughness 0.5, non-metallic) is always present at index 0:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rock = world.resources.sdf_material_registry.add_material(
    SdfMaterial::new(Vec3::new(0.5, 0.45, 0.4))
        .with_roughness(0.9)
);

let gold = world.resources.sdf_material_registry.add_material(
    SdfMaterial::new(Vec3::new(1.0, 0.84, 0.0))
        .with_roughness(0.3)
        .with_metallic(1.0)
);

let lava = world.resources.sdf_material_registry.add_material(
    SdfMaterial::new(Vec3::new(0.8, 0.2, 0.0))
        .with_roughness(0.7)
        .with_emissive(Vec3::new(5.0, 1.0, 0.0))
);
<span class="boring">}</span></code></pre></pre>
<h2 id="sdf-raycast"><a class="header" href="#sdf-raycast">SDF Raycast</a></h2>
<p>The SDF world provides CPU-side sphere tracing (up to 512 steps) for picking and collision:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let origin = ray.origin;
let direction = ray.direction;
let max_distance = 100.0;

if let Some(hit_point) = world.resources.sdf_world.raycast(origin, direction, max_distance) {
    let normal = world.resources.sdf_world.evaluate_normal_at(hit_point);
}
<span class="boring">}</span></code></pre></pre>
<p>The raycast marches along the ray, stepping by the evaluated distance at each point (with a minimum step of half the base voxel size to avoid getting stuck inside surfaces). A hit is detected when the absolute distance falls below 0.1 times the base voxel size.</p>
<p>Normal estimation uses central differences: the gradient of the distance field is computed by evaluating at six points offset by half the base voxel size along each axis.</p>
<h2 id="terrain-generation"><a class="header" href="#terrain-generation">Terrain Generation</a></h2>
<p>The SDF system includes built-in fBm (fractal Brownian motion) terrain with derivative-based dampening and domain rotation between octaves:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TerrainConfig {
    pub enabled: bool,
    pub base_height: f32,
    pub material_id: u32,
    pub seed: u32,
    pub frequency: f32,
    pub amplitude: f32,
    pub octaves: u32,
    pub lacunarity: f32,
    pub gain: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td><code>false</code></td><td>Whether terrain is active</td></tr>
<tr><td><code>base_height</code></td><td><code>0.0</code></td><td>Vertical offset of the terrain surface</td></tr>
<tr><td><code>material_id</code></td><td><code>0</code></td><td>SDF material index for the terrain</td></tr>
<tr><td><code>seed</code></td><td><code>0</code></td><td>Hash seed for noise generation</td></tr>
<tr><td><code>frequency</code></td><td><code>0.01</code></td><td>Base noise frequency (lower = broader features)</td></tr>
<tr><td><code>amplitude</code></td><td><code>30.0</code></td><td>Maximum height variation</td></tr>
<tr><td><code>octaves</code></td><td><code>11</code></td><td>Number of noise layers</td></tr>
<tr><td><code>lacunarity</code></td><td><code>2.0</code></td><td>Frequency multiplier per octave</td></tr>
<tr><td><code>gain</code></td><td><code>0.5</code></td><td>Amplitude multiplier per octave</td></tr>
</tbody></table>
</div>
<p>Enable terrain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.sdf_world.set_terrain_config(TerrainConfig {
    enabled: true,
    base_height: -5.0,
    frequency: 0.02,
    amplitude: 20.0,
    octaves: 8,
    seed: 42,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<p>The terrain noise uses quintic smoothstep interpolation (<code>6t^5 - 15t^4 + 10t^3</code>) with analytic derivatives for gradient computation. Each octave applies a 2D rotation matrix (<code>[1.6, -1.2; 1.2, 1.6]</code>) to the sample coordinates before the next octave, which reduces directional artifacts. The derivative accumulator dampens amplitude in areas of high gradient, producing naturally eroded ridgelines.</p>
<p>Terrain is evaluated only in the first 4 clipmap levels (highest detail) to avoid excessive computation at coarse LODs.</p>
<p>Query terrain height at a world XZ position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let height = world.resources.sdf_world.terrain.height_at(x, z);
<span class="boring">}</span></code></pre></pre>
<h2 id="sculpting-tool-example"><a class="header" href="#sculpting-tool-example">Sculpting Tool Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SculptTool {
    brush_size: f32,
    material_id: u32,
    operation: CsgOperation,
}

fn run_systems(&amp;mut self, world: &amp;mut World) {
    if world.resources.input.mouse.left_pressed {
        let screen_pos = world.resources.input.mouse.position;
        let ray = PickingRay::from_screen_position(world, screen_pos);

        if let Some(ray) = ray {
            if let Some(hit) = world.resources.sdf_world.raycast(
                ray.origin,
                ray.direction,
                100.0,
            ) {
                let normal = world.resources.sdf_world.evaluate_normal_at(hit);

                let sculpt_pos = match self.tool.operation {
                    CsgOperation::Union | CsgOperation::SmoothUnion { .. } =&gt; {
                        hit + normal * self.tool.brush_size * 0.5
                    }
                    CsgOperation::Subtraction | CsgOperation::SmoothSubtraction { .. } =&gt; {
                        hit - normal * self.tool.brush_size * 0.5
                    }
                    _ =&gt; hit,
                };

                let edit = SdfEdit::from_operation(
                    SdfPrimitive::Sphere { radius: self.tool.brush_size },
                    self.tool.operation,
                    nalgebra_glm::translation(&amp;sculpt_pos),
                    self.tool.material_id,
                );
                world.resources.sdf_world.add_edit(edit);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="evaluating-the-distance-field"><a class="header" href="#evaluating-the-distance-field">Evaluating the Distance Field</a></h2>
<p>Query the combined SDF (terrain + all edits) at any world-space point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let distance = world.resources.sdf_world.evaluate_at(point);

let distance_lod = world.resources.sdf_world.evaluate_at_lod(point, 6);
<span class="boring">}</span></code></pre></pre>
<p>The <code>evaluate_at_lod</code> variant limits the terrain noise octaves for cheaper evaluation at coarse LODs.</p>
<h2 id="updating-the-sdf-world"><a class="header" href="#updating-the-sdf-world">Updating the SDF World</a></h2>
<p>Call <code>update()</code> each frame with the camera position to recenter the clipmap, rebuild the BVH if needed, and generate GPU brick dispatches:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let camera_pos = get_active_camera_position(world);
    world.resources.sdf_world.update(camera_pos);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="querying-sdf-state"><a class="header" href="#querying-sdf-state">Querying SDF State</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let edit_count = world.resources.sdf_world.edit_count();
let allocated_bricks = world.resources.sdf_world.allocated_brick_count();
let max_bricks = world.resources.sdf_world.max_brick_count();
let level_count = world.resources.sdf_world.level_count();
let voxel_sizes = world.resources.sdf_world.voxel_sizes();
let base_voxel_size = world.resources.sdf_world.base_voxel_size();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lattice-deformation"><a class="header" href="#lattice-deformation">Lattice Deformation</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/lattice">Lattice</a></p>
</blockquote>
<p>Lattice deformation (Free-Form Deformation / FFD) deforms meshes by manipulating a grid of control points surrounding the mesh. Vertices are displaced based on trilinear interpolation of the nearest control point displacements, producing smooth spatial warping effects like bending, twisting, tapering, and bulging.</p>
<h2 id="enabling-lattice"><a class="header" href="#enabling-lattice">Enabling Lattice</a></h2>
<p>Add the <code>lattice</code> feature:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "lattice"] }
</code></pre>
<h2 id="how-lattice-deformation-works"><a class="header" href="#how-lattice-deformation-works">How Lattice Deformation Works</a></h2>
<p>The Lattice component defines a 3D grid of control points within an axis-aligned bounding box. Each control point has a base position (computed from the grid dimensions and bounds) and a displacement vector. When a mesh vertex needs to be deformed:</p>
<ol>
<li>The vertex's world-space position is converted to UVW coordinates (0-1 range within the lattice bounds)</li>
<li>The 8 surrounding control points are looked up from the grid indices</li>
<li>The displacement is computed by trilinear interpolation of those 8 control point displacements</li>
<li>Vertices outside the lattice bounds are either unaffected (falloff = 0) or smoothly blended based on the falloff distance</li>
</ol>
<p>The deformation is applied as a morph target on the GPU. The system converts world-space displacements back to local space via the entity's inverse model matrix, creates a <code>MorphTarget</code> with per-vertex position offsets, and updates the mesh cache.</p>
<h2 id="lattice-component"><a class="header" href="#lattice-component">Lattice Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lattice {
    pub base_points: Vec&lt;Vec3&gt;,
    pub displacements: Vec&lt;Vec3&gt;,
    pub dimensions: [usize; 3],
    pub bounds_min: Vec3,
    pub bounds_max: Vec3,
    pub falloff: f32,
    pub version: u32,
}
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>base_points</code></td><td>Undeformed control point positions, computed from bounds and dimensions</td></tr>
<tr><td><code>displacements</code></td><td>Per-control-point displacement vectors (initially zero)</td></tr>
<tr><td><code>dimensions</code></td><td>Grid resolution as <code>[x, y, z]</code></td></tr>
<tr><td><code>bounds_min</code></td><td>Lower corner of the lattice bounding box</td></tr>
<tr><td><code>bounds_max</code></td><td>Upper corner of the lattice bounding box</td></tr>
<tr><td><code>falloff</code></td><td>Distance beyond lattice bounds where deformation fades to zero (0 = hard cutoff)</td></tr>
<tr><td><code>version</code></td><td>Auto-incremented when displacements change, used for dirty detection</td></tr>
</tbody></table>
</div>
<h2 id="creating-a-lattice"><a class="header" href="#creating-a-lattice">Creating a Lattice</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::lattice::systems::create_lattice_entity;

let lattice_entity = create_lattice_entity(
    world,
    Vec3::new(-2.0, -2.0, -2.0),
    Vec3::new(2.0, 2.0, 2.0),
    [4, 4, 4],
);
<span class="boring">}</span></code></pre></pre>
<p>This spawns an entity with the <code>LATTICE</code> component. The constructor computes base point positions by subdividing the bounding box evenly according to the dimensions. For a 4x4x4 lattice, this creates 64 control points.</p>
<p>With falloff for smooth blending beyond the bounds:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lattice = Lattice::new(bounds_min, bounds_max, [4, 4, 4])
    .with_falloff(1.0);
world.set_lattice(lattice_entity, lattice);
<span class="boring">}</span></code></pre></pre>
<h2 id="registering-influenced-meshes"><a class="header" href="#registering-influenced-meshes">Registering Influenced Meshes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::lattice::systems::register_entity_for_lattice_deformation;

register_entity_for_lattice_deformation(world, mesh_entity, lattice_entity);
<span class="boring">}</span></code></pre></pre>
<p>This adds <code>LATTICE_INFLUENCED</code> and <code>MORPH_WEIGHTS</code> components to the mesh entity. The <code>LatticeInfluenced</code> component stores the lattice entity reference, the last known lattice version, and the last entity position — used to skip re-evaluation when nothing has changed.</p>
<h2 id="manipulating-control-points"><a class="header" href="#manipulating-control-points">Manipulating Control Points</a></h2>
<p>Displacements are set per-grid-coordinate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(lattice) = world.get_lattice_mut(lattice_entity) {
    lattice.set_displacement(1, 2, 1, Vec3::new(0.0, 0.5, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>set_displacement</code> method automatically increments the version counter, which triggers re-evaluation on influenced meshes.</p>
<p>To read the current deformed position (base + displacement):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = lattice.get_point(1, 2, 1);
<span class="boring">}</span></code></pre></pre>
<p>To get the displacement alone:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let displacement = lattice.get_displacement(1, 2, 1);
<span class="boring">}</span></code></pre></pre>
<p>Reset all displacements to zero:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lattice.reset_displacements();
<span class="boring">}</span></code></pre></pre>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<p>Control point indices follow x-major ordering: <code>index = z * (nx * ny) + y * nx + x</code>. The <code>get_index</code> method computes this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let index = lattice.get_index(x, y, z);
<span class="boring">}</span></code></pre></pre>
<h2 id="deformation-system"><a class="header" href="#deformation-system">Deformation System</a></h2>
<p>Call the lattice deformation system each frame to apply updated displacements:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    lattice_deformation_system(world);
}
<span class="boring">}</span></code></pre></pre>
<p>The system queries all entities with <code>LATTICE_INFLUENCED | RENDER_MESH | MORPH_WEIGHTS | GLOBAL_TRANSFORM</code>. For each entity, it checks whether the lattice version or entity position has changed since the last update. If so, it:</p>
<ol>
<li>Reads the mesh vertices from the mesh cache</li>
<li>Transforms each vertex position to world space via the entity's global transform</li>
<li>Calls <code>lattice.sample(world_pos)</code> to get the world-space displacement</li>
<li>Converts the displacement back to local space via the inverse model matrix</li>
<li>Creates a <code>MorphTarget</code> with the per-vertex local-space displacements</li>
<li>Updates the mesh cache and marks it dirty for GPU re-upload</li>
</ol>
<h2 id="trilinear-interpolation"><a class="header" href="#trilinear-interpolation">Trilinear Interpolation</a></h2>
<p>The <code>sample()</code> method converts a world position to UVW coordinates within the lattice bounds, finds the 8 surrounding control points, and interpolates their displacements:</p>
<pre><code>uvw = (world_pos - bounds_min) / (bounds_max - bounds_min)

fx = uvw.x * (nx - 1)    // fractional grid coordinate
x0 = floor(fx)           // lower grid index
tx = fx - x0             // interpolation weight

// Interpolate 8 corners along X, then Y, then Z
d00 = lerp(d000, d100, tx)
d10 = lerp(d010, d110, tx)
d01 = lerp(d001, d101, tx)
d11 = lerp(d011, d111, tx)
d0  = lerp(d00, d10, ty)
d1  = lerp(d01, d11, ty)
result = lerp(d0, d1, tz)
</code></pre>
<p>For points outside the lattice bounds, the UVW coordinates are clamped to [0, 1] and the displacement is attenuated by the falloff factor. The falloff is computed as <code>max(0, 1 - normalized_distance / falloff)</code> where <code>normalized_distance</code> is the distance from the point to the clamped position, scaled by the average lattice dimension.</p>
<h2 id="common-deformation-effects"><a class="header" href="#common-deformation-effects">Common Deformation Effects</a></h2>
<h3 id="bend"><a class="header" href="#bend">Bend</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bend_lattice(world: &amp;mut World, lattice_entity: Entity, amount: f32) {
    if let Some(lattice) = world.get_lattice_mut(lattice_entity) {
        let [nx, ny, nz] = lattice.dimensions;

        for z in 0..nz {
            for y in 0..ny {
                for x in 0..nx {
                    let t = x as f32 / (nx - 1) as f32;
                    let bend = (t * std::f32::consts::PI).sin() * amount;
                    lattice.set_displacement(x, y, z, Vec3::new(0.0, bend, 0.0));
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="twist"><a class="header" href="#twist">Twist</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twist_lattice(world: &amp;mut World, lattice_entity: Entity, angle: f32) {
    if let Some(lattice) = world.get_lattice_mut(lattice_entity) {
        let [nx, ny, nz] = lattice.dimensions;
        let bounds_min = lattice.bounds_min;
        let bounds_max = lattice.bounds_max;
        let height = bounds_max.y - bounds_min.y;

        for z in 0..nz {
            for y in 0..ny {
                for x in 0..nx {
                    let base = lattice.base_points[lattice.get_index(x, y, z)];
                    let t = (base.y - bounds_min.y) / height;
                    let twist_angle = t * angle;

                    let new_x = base.x * twist_angle.cos() - base.z * twist_angle.sin();
                    let new_z = base.x * twist_angle.sin() + base.z * twist_angle.cos();

                    lattice.set_displacement(
                        x, y, z,
                        Vec3::new(new_x - base.x, 0.0, new_z - base.z),
                    );
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="taper"><a class="header" href="#taper">Taper</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn taper_lattice(world: &amp;mut World, lattice_entity: Entity, top_scale: f32) {
    if let Some(lattice) = world.get_lattice_mut(lattice_entity) {
        let [nx, ny, nz] = lattice.dimensions;
        let bounds_min = lattice.bounds_min;
        let bounds_max = lattice.bounds_max;
        let center_x = (bounds_min.x + bounds_max.x) * 0.5;
        let center_z = (bounds_min.z + bounds_max.z) * 0.5;
        let height = bounds_max.y - bounds_min.y;

        for z in 0..nz {
            for y in 0..ny {
                for x in 0..nx {
                    let base = lattice.base_points[lattice.get_index(x, y, z)];
                    let t = (base.y - bounds_min.y) / height;
                    let scale = 1.0 + (top_scale - 1.0) * t;

                    let new_x = center_x + (base.x - center_x) * scale;
                    let new_z = center_z + (base.z - center_z) * scale;

                    lattice.set_displacement(
                        x, y, z,
                        Vec3::new(new_x - base.x, 0.0, new_z - base.z),
                    );
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="animated-wave"><a class="header" href="#animated-wave">Animated Wave</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wave_lattice(world: &amp;mut World, lattice_entity: Entity, amplitude: f32, frequency: f32, time: f32) {
    if let Some(lattice) = world.get_lattice_mut(lattice_entity) {
        let [nx, ny, nz] = lattice.dimensions;

        for z in 0..nz {
            for y in 0..ny {
                for x in 0..nx {
                    let base = lattice.base_points[lattice.get_index(x, y, z)];
                    let wave = (base.x * frequency + time).sin() * amplitude;
                    lattice.set_displacement(x, y, z, Vec3::new(0.0, wave, 0.0));
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting"><a class="header" href="#scripting">Scripting</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/block_breaker_scripts">Block Breaker with Scripts</a></p>
</blockquote>
<p>Nightshade supports runtime scripting using <a href="https://rhai.rs/">Rhai</a>, an embedded scripting language for Rust. Scripts run each frame and communicate with the engine through scope variables — reading entity transforms, input state, and time, then writing back updated positions, rotations, and commands.</p>
<h2 id="enabling-scripting"><a class="header" href="#enabling-scripting">Enabling Scripting</a></h2>
<p>Add the <code>scripting</code> feature:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "scripting"] }
</code></pre>
<h2 id="script-component"><a class="header" href="#script-component">Script Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Script {
    pub source: ScriptSource,
    pub enabled: bool,
}

pub enum ScriptSource {
    File { path: String },
    Embedded { source: String },
}
<span class="boring">}</span></code></pre></pre>
<p>Scripts can be loaded from a file path (with hot-reloading on native) or embedded as a string:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let script = Script::from_source(r#"
    pos_x += dt * 5.0;
"#);

let script = Script::from_file("scripts/enemy.rhai");
<span class="boring">}</span></code></pre></pre>
<h2 id="attaching-scripts-to-entities"><a class="header" href="#attaching-scripts-to-entities">Attaching Scripts to Entities</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | SCRIPT,
    1
)[0];

world.set_script(entity, Script::from_source(r#"
    pos_y = (time * 2.0).sin() + 1.0;
"#));
<span class="boring">}</span></code></pre></pre>
<p>Scripts are disabled by default. Enable them to start execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(script) = world.get_script_mut(entity) {
    script.enabled = true;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="scope-variables"><a class="header" href="#scope-variables">Scope Variables</a></h2>
<p>Scripts communicate with the engine entirely through variables injected into the Rhai scope. The system reads these variables after script execution to apply changes.</p>
<h3 id="transform-variables"><a class="header" href="#transform-variables">Transform Variables</a></h3>
<p>Read and write the entity's local transform:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pos_x</code>, <code>pos_y</code>, <code>pos_z</code></td><td><code>f64</code></td><td>Entity position</td></tr>
<tr><td><code>rot_x</code>, <code>rot_y</code>, <code>rot_z</code></td><td><code>f64</code></td><td>Entity rotation (Euler angles in radians)</td></tr>
<tr><td><code>scale_x</code>, <code>scale_y</code>, <code>scale_z</code></td><td><code>f64</code></td><td>Entity scale</td></tr>
</tbody></table>
</div>
<p>Changes are only applied if the values actually differ from the current transform (compared with epsilon tolerance).</p>
<h3 id="time-variables"><a class="header" href="#time-variables">Time Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>dt</code> / <code>delta_time</code></td><td><code>f64</code></td><td>Frame delta time in seconds</td></tr>
<tr><td><code>time</code></td><td><code>f64</code></td><td>Accumulated total time since scripts started</td></tr>
</tbody></table>
</div>
<h3 id="input-variables"><a class="header" href="#input-variables">Input Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mouse_x</code>, <code>mouse_y</code></td><td><code>f64</code></td><td>Current mouse position</td></tr>
<tr><td><code>pressed_keys</code></td><td><code>Array</code></td><td>Currently held key names (e.g., <code>["W", "SPACE"]</code>)</td></tr>
<tr><td><code>just_pressed_keys</code></td><td><code>Array</code></td><td>Keys pressed this frame (not held from previous)</td></tr>
</tbody></table>
</div>
<p>Key names are uppercase strings: <code>A</code>-<code>Z</code>, <code>0</code>-<code>9</code>, <code>SPACE</code>, <code>ENTER</code>, <code>ESCAPE</code>, <code>SHIFT</code>, <code>CTRL</code>, <code>ALT</code>, <code>TAB</code>, <code>BACKSPACE</code>, <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code>.</p>
<h3 id="entity-access"><a class="header" href="#entity-access">Entity Access</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>entity_id</code></td><td><code>i64</code></td><td>This entity's ID (constant)</td></tr>
<tr><td><code>entities</code></td><td><code>Map</code></td><td>Named entities with their positions and scales</td></tr>
<tr><td><code>entity_names</code></td><td><code>Array</code></td><td>List of all named entity names</td></tr>
</tbody></table>
</div>
<p>Access other entities by name:</p>
<pre><code class="language-rhai">let player = entities["Player"];
let player_x = player.x;
let player_y = player.y;
let player_z = player.z;
</code></pre>
<h3 id="game-state"><a class="header" href="#game-state">Game State</a></h3>
<p>A shared <code>state</code> map persists across frames and is accessible to all scripts:</p>
<pre><code class="language-rhai">state["score"] = state["score"] + 1.0;
state["game_over"] = 1.0;
</code></pre>
<p>State values are <code>f64</code>. The state map is shared across all script entities.</p>
<h3 id="spawning-and-despawning"><a class="header" href="#spawning-and-despawning">Spawning and Despawning</a></h3>
<p>Set these variables to spawn or despawn entities:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>do_spawn_cube</code></td><td><code>bool</code></td><td>Spawn a cube at <code>(spawn_cube_x/y/z)</code></td></tr>
<tr><td><code>spawn_cube_x/y/z</code></td><td><code>f64</code></td><td>Spawn position for cube</td></tr>
<tr><td><code>do_spawn_sphere</code></td><td><code>bool</code></td><td>Spawn a sphere at <code>(spawn_sphere_x/y/z)</code></td></tr>
<tr><td><code>spawn_sphere_x/y/z</code></td><td><code>f64</code></td><td>Spawn position for sphere</td></tr>
<tr><td><code>do_despawn</code></td><td><code>bool</code></td><td>Despawn this entity</td></tr>
<tr><td><code>despawn_names</code></td><td><code>Array</code></td><td>Names of other entities to despawn</td></tr>
</tbody></table>
</div>
<h2 id="example-scripts"><a class="header" href="#example-scripts">Example Scripts</a></h2>
<h3 id="moving-object"><a class="header" href="#moving-object">Moving Object</a></h3>
<pre><code class="language-rhai">let speed = 5.0;
pos_x += speed * dt;

if pos_x &gt; 10.0 {
    pos_x = -10.0;
}
</code></pre>
<h3 id="keyboard-control"><a class="header" href="#keyboard-control">Keyboard Control</a></h3>
<pre><code class="language-rhai">let speed = 8.0;

if pressed_keys.contains("W") { pos_z -= speed * dt; }
if pressed_keys.contains("S") { pos_z += speed * dt; }
if pressed_keys.contains("A") { pos_x -= speed * dt; }
if pressed_keys.contains("D") { pos_x += speed * dt; }

if just_pressed_keys.contains("SPACE") {
    do_spawn_sphere = true;
    spawn_sphere_x = pos_x;
    spawn_sphere_y = pos_y + 1.0;
    spawn_sphere_z = pos_z;
}
</code></pre>
<h3 id="follow-player"><a class="header" href="#follow-player">Follow Player</a></h3>
<pre><code class="language-rhai">let speed = 3.0;

if "Player" in entities {
    let player = entities["Player"];
    let dx = player.x - pos_x;
    let dz = player.z - pos_z;
    let dist = (dx * dx + dz * dz).sqrt();

    if dist &gt; 1.0 {
        pos_x += (dx / dist) * speed * dt;
        pos_z += (dz / dist) * speed * dt;
    }
}
</code></pre>
<h3 id="rotating-object"><a class="header" href="#rotating-object">Rotating Object</a></h3>
<pre><code class="language-rhai">let rotation_speed = 1.0;
rot_y += rotation_speed * dt;
</code></pre>
<h3 id="bobbing-animation"><a class="header" href="#bobbing-animation">Bobbing Animation</a></h3>
<pre><code class="language-rhai">let amplitude = 0.5;
let frequency = 2.0;
pos_y = 1.0 + (time * frequency).sin() * amplitude;
</code></pre>
<h3 id="scorekeeping"><a class="header" href="#scorekeeping">Scorekeeping</a></h3>
<pre><code class="language-rhai">if !("score" in state) {
    state["score"] = 0.0;
}

if just_pressed_keys.contains("E") {
    state["score"] = state["score"] + 10.0;
}
</code></pre>
<h3 id="despawning-named-entities"><a class="header" href="#despawning-named-entities">Despawning Named Entities</a></h3>
<pre><code class="language-rhai">if just_pressed_keys.contains("X") {
    despawn_names.push("Enemy_1");
    despawn_names.push("Enemy_2");
}
</code></pre>
<h2 id="script-runtime"><a class="header" href="#script-runtime">Script Runtime</a></h2>
<p>The <code>ScriptRuntime</code> manages compilation, caching, and execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ScriptRuntime {
    pub engine: rhai::Engine,
    pub game_state: HashMap&lt;String, f64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Run the scripting system each frame:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    run_scripts_system(world, &amp;mut self.script_runtime);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="script-compilation"><a class="header" href="#script-compilation">Script Compilation</a></h3>
<p>Scripts are compiled to AST on first execution and cached by a hash of the source code. Recompilation only occurs when the source changes. For file-based scripts, modification times are tracked and the script is automatically recompiled when the file changes (hot-reloading on native only).</p>
<h3 id="custom-functions"><a class="header" href="#custom-functions">Custom Functions</a></h3>
<p>Register additional Rhai functions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>runtime.engine.register_fn("custom_function", |x: i64, y: i64| {
    x + y
});
<span class="boring">}</span></code></pre></pre>
<h3 id="game-state-1"><a class="header" href="#game-state-1">Game State</a></h3>
<p>The runtime's <code>game_state</code> map is injected into every script's scope as the <code>state</code> variable. Values persist across frames:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>runtime.set_state("difficulty".to_string(), 1.0);
let score = runtime.get_state("score");
runtime.reset_game_state();
<span class="boring">}</span></code></pre></pre>
<h2 id="hot-reloading"><a class="header" href="#hot-reloading">Hot Reloading</a></h2>
<p>On native platforms, file-based scripts are automatically hot-reloaded when modified. The runtime tracks file modification times and invalidates the compiled cache when changes are detected. This allows editing scripts in an external editor while the game is running.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects-pass-1"><a class="header" href="#effects-pass-1">Effects Pass</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/psx">PSX Retro Effects</a></p>
</blockquote>
<p>The EffectsPass is a configurable post-processing system with 38 shader parameters for visual effects. It includes distortions, color grading, raymarched overlays, retro effects, and more.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The EffectsPass operates as a render graph node that processes the rendered scene through a fullscreen shader. Effects can be combined and animated for music visualizers, stylized games, or creative applications.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Create and configure the effects state, then add the pass to your render graph:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::wgpu::passes::postprocess::effects::*;

fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    // Create shared state handle
    let effects_state = create_effects_state();
    self.effects_state = Some(effects_state.clone());

    // Create and add the pass
    let effects_pass = EffectsPass::new(device, surface_format, effects_state);
    graph.add_pass(Box::new(effects_pass));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="modifying-effects"><a class="header" href="#modifying-effects">Modifying Effects</a></h2>
<p>Access the state handle to modify effect parameters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(state_handle) = &amp;self.effects_state {
        if let Ok(mut state) = state_handle.write() {
            // Modify uniforms
            state.uniforms.chromatic_aberration = 0.02;
            state.uniforms.vignette = 0.3;

            // Enable/disable the entire pass
            state.enabled = true;

            // Auto-animate hue rotation
            state.animate_hue = false;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="effect-parameters"><a class="header" href="#effect-parameters">Effect Parameters</a></h2>
<h3 id="distortion-effects"><a class="header" href="#distortion-effects">Distortion Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chromatic aberration: RGB channel separation (0.0-0.1 typical)
uniforms.chromatic_aberration = 0.02;

// Wave distortion: sinusoidal screen warping
uniforms.wave_distortion = 0.5;

// Glitch intensity: digital glitch artifacts
uniforms.glitch_intensity = 0.3;

// VHS distortion: analog tape wobble and noise
uniforms.vhs_distortion = 0.4;

// Heat distortion: rising heat shimmer effect
uniforms.heat_distortion = 0.2;

// Screen shake: camera shake offset
uniforms.screen_shake = 0.1;

// Warp speed: hyperspace stretch effect
uniforms.warp_speed = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="color-effects"><a class="header" href="#color-effects">Color Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hue rotation: shift all colors around the wheel (0.0-1.0)
uniforms.hue_rotation = 0.5;

// Saturation: color intensity (0.0=grayscale, 1.0=normal, 2.0=oversaturated)
uniforms.saturation = 1.0;

// Color shift: global color offset
uniforms.color_shift = 0.1;

// Invert: color inversion (0.0=normal, 1.0=inverted)
uniforms.invert = 1.0;

// Color posterize: reduce color depth (0.0=off, higher=fewer colors)
uniforms.color_posterize = 4.0;

// Color cycle speed: rate of automatic color animation
uniforms.color_cycle_speed = 1.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="color-grading-1"><a class="header" href="#color-grading-1">Color Grading</a></h3>
<p>Apply preset color grades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
<span class="boring">}</span></code></pre></pre>
<p>Available modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>None</code></td><td>0</td><td>No color grading</td></tr>
<tr><td><code>Cyberpunk</code></td><td>1</td><td>Teal and magenta, high contrast</td></tr>
<tr><td><code>Sunset</code></td><td>2</td><td>Warm orange and purple tones</td></tr>
<tr><td><code>Grayscale</code></td><td>3</td><td>Black and white</td></tr>
<tr><td><code>Sepia</code></td><td>4</td><td>Vintage brown tones</td></tr>
<tr><td><code>Matrix</code></td><td>5</td><td>Green tinted, digital look</td></tr>
<tr><td><code>HotMetal</code></td><td>6</td><td>Heat map colors</td></tr>
</tbody></table>
</div>
<h3 id="geometric-effects"><a class="header" href="#geometric-effects">Geometric Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Kaleidoscope: mirror segments (0=off, 6-12 typical)
uniforms.kaleidoscope_segments = 6.0;

// Mirror mode: horizontal/vertical mirroring
uniforms.mirror_mode = 1.0;

// Zoom pulse: rhythmic zoom in/out
uniforms.zoom_pulse = 0.5;

// Radial blur: motion blur from center
uniforms.radial_blur = 0.2;

// Pixelate: reduce resolution (0=off, higher=larger pixels)
uniforms.pixelate = 8.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="raymarched-overlays"><a class="header" href="#raymarched-overlays">Raymarched Overlays</a></h3>
<p>Blend raymarched 3D effects over the scene:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
uniforms.raymarch_blend = 0.5; // 0.0-1.0 blend with scene
uniforms.tunnel_speed = 1.0;   // Animation speed
uniforms.fractal_iterations = 4.0;
<span class="boring">}</span></code></pre></pre>
<p>Available raymarch modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Off</code></td><td>0</td><td>No raymarching</td></tr>
<tr><td><code>Tunnel</code></td><td>1</td><td>Infinite tunnel flythrough</td></tr>
<tr><td><code>Fractal</code></td><td>2</td><td>2D fractal pattern</td></tr>
<tr><td><code>Mandelbulb</code></td><td>3</td><td>3D mandelbulb fractal</td></tr>
<tr><td><code>PlasmaVortex</code></td><td>4</td><td>Swirling plasma effect</td></tr>
<tr><td><code>Geometric</code></td><td>5</td><td>Repeating geometric shapes</td></tr>
</tbody></table>
</div>
<h3 id="retro-effects"><a class="header" href="#retro-effects">Retro Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CRT scanlines: horizontal line overlay
uniforms.crt_scanlines = 0.5;

// Film grain: random noise overlay
uniforms.film_grain = 0.1;

// ASCII mode: convert to ASCII art characters
uniforms.ascii_mode = 1.0;

// Digital rain: Matrix-style falling characters
uniforms.digital_rain = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="glow-and-light-effects"><a class="header" href="#glow-and-light-effects">Glow and Light Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vignette: darken screen edges (0.0-1.0)
uniforms.vignette = 0.3;

// Glow intensity: bloom-like glow
uniforms.glow_intensity = 0.5;

// Lens flare: bright light artifacts
uniforms.lens_flare = 0.3;

// Edge glow: outline bright edges
uniforms.edge_glow = 0.2;

// Strobe: flashing white overlay
uniforms.strobe = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="plasma-and-patterns"><a class="header" href="#plasma-and-patterns">Plasma and Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Plasma intensity: colorful plasma overlay
uniforms.plasma_intensity = 0.5;

// Pulse rings: expanding circular rings
uniforms.pulse_rings = 0.3;

// Speed lines: motion/action lines
uniforms.speed_lines = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="image-processing"><a class="header" href="#image-processing">Image Processing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sharpen: edge enhancement (0.0-1.0)
uniforms.sharpen = 0.5;

// Feedback amount: recursive frame blending
uniforms.feedback_amount = 0.3;
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-effects"><a class="header" href="#combining-effects">Combining Effects</a></h2>
<p>Effects can be layered for complex looks:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cyberpunk aesthetic
state.uniforms.chromatic_aberration = 0.015;
state.uniforms.crt_scanlines = 0.2;
state.uniforms.vignette = 0.4;
state.uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
state.uniforms.glow_intensity = 0.3;

// VHS tape look
state.uniforms.vhs_distortion = 0.4;
state.uniforms.crt_scanlines = 0.3;
state.uniforms.film_grain = 0.15;
state.uniforms.chromatic_aberration = 0.01;
state.uniforms.saturation = 0.8;

// Psychedelic visualizer
state.uniforms.kaleidoscope_segments = 8.0;
state.uniforms.plasma_intensity = 0.3;
state.uniforms.hue_rotation = time * 0.1;
state.uniforms.wave_distortion = 0.2;
<span class="boring">}</span></code></pre></pre>
<h2 id="music-reactive-effects"><a class="header" href="#music-reactive-effects">Music-Reactive Effects</a></h2>
<p>Combine with AudioAnalyzer for reactive visuals:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    self.analyzer.analyze_at_time(self.time);

    if let Some(state_handle) = &amp;self.effects_state {
        if let Ok(mut state) = state_handle.write() {
            // Chromatic aberration on bass
            state.uniforms.chromatic_aberration =
                self.analyzer.smoothed_bass * 0.05;

            // Glitch on snare hits
            state.uniforms.glitch_intensity =
                self.analyzer.snare_decay * 0.5;

            // Zoom pulse on kick
            state.uniforms.zoom_pulse =
                self.analyzer.kick_decay * 0.3;

            // Color cycling based on energy
            state.uniforms.hue_rotation =
                self.time * self.analyzer.intensity * 0.2;

            // Screen shake on drops
            if self.analyzer.is_dropping {
                state.uniforms.screen_shake =
                    self.analyzer.drop_intensity * 0.1;
            } else {
                state.uniforms.screen_shake *= 0.9;
            }

            // Switch to tunnel during breakdown
            if self.analyzer.is_breakdown {
                state.uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
                state.uniforms.raymarch_blend =
                    self.analyzer.breakdown_intensity * 0.5;
            } else {
                state.uniforms.raymarch_blend *= 0.95;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-inputoutput-slots"><a class="header" href="#custom-inputoutput-slots">Custom Input/Output Slots</a></h2>
<p>By default, the EffectsPass reads from "input" and writes to "output". Configure custom slots:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let effects_pass = EffectsPass::with_slots(
    device,
    surface_format,
    effects_state,
    "post_bloom",    // Input slot name
    "final_output"   // Output slot name
);
<span class="boring">}</span></code></pre></pre>
<h2 id="disabling-the-pass"><a class="header" href="#disabling-the-pass">Disabling the Pass</a></h2>
<p>Temporarily bypass all effects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(mut state) = state_handle.write() {
    state.enabled = false; // Pass through without processing
}
<span class="boring">}</span></code></pre></pre>
<p>When disabled, the pass performs a simple blit operation with no effects applied.</p>
<h2 id="auto-animate-hue"><a class="header" href="#auto-animate-hue">Auto-Animate Hue</a></h2>
<p>Enable automatic hue rotation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(mut state) = state_handle.write() {
    state.animate_hue = true; // Continuously rotate hue based on time
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;
use nightshade::render::wgpu::passes::postprocess::effects::*;

struct VisualDemo {
    effects_state: Option&lt;EffectsStateHandle&gt;,
    analyzer: AudioAnalyzer,
    time: f32,
}

impl Default for VisualDemo {
    fn default() -&gt; Self {
        Self {
            effects_state: None,
            analyzer: AudioAnalyzer::new(),
            time: 0.0,
        }
    }
}

impl State for VisualDemo {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
        world.resources.active_camera = Some(camera);
        spawn_sun(world);

        // Load some geometry
        load_gltf(world, "assets/models/scene.glb");

        // Load audio for reactive effects
        let (samples, sample_rate) = load_audio_file("assets/audio/music.wav");
        self.analyzer.load_samples(samples, sample_rate);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;
        self.time += dt;

        // Analyze audio
        self.analyzer.analyze_at_time(self.time);

        // Update effects based on audio
        if let Some(state_handle) = &amp;self.effects_state {
            if let Ok(mut state) = state_handle.write() {
                // Base effects
                state.uniforms.vignette = 0.3;
                state.uniforms.crt_scanlines = 0.15;

                // Audio-reactive
                state.uniforms.chromatic_aberration =
                    self.analyzer.smoothed_bass * 0.04;
                state.uniforms.glow_intensity =
                    self.analyzer.intensity * 0.5;
                state.uniforms.zoom_pulse =
                    self.analyzer.kick_decay * 0.2;

                // Structure-based
                if self.analyzer.is_dropping {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::Cyberpunk as f32;
                    state.uniforms.strobe =
                        self.analyzer.drop_intensity * 0.3;
                } else if self.analyzer.is_breakdown {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::Grayscale as f32;
                } else {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::None as f32;
                    state.uniforms.strobe = 0.0;
                }
            }
        }
    }

    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) {
        // Add standard passes first...

        // Create effects pass
        let effects_state = create_effects_state();
        self.effects_state = Some(effects_state.clone());

        let effects_pass = EffectsPass::new(device, surface_format, effects_state);
        graph.add_pass(Box::new(effects_pass));
    }
}

fn main() {
    nightshade::launch(VisualDemo::default());
}</code></pre></pre>
<h2 id="parameter-reference"><a class="header" href="#parameter-reference">Parameter Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Range</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>time</code></td><td>0.0+</td><td>0.0</td><td>Elapsed time (auto-updated)</td></tr>
<tr><td><code>chromatic_aberration</code></td><td>0.0-0.1</td><td>0.0</td><td>RGB channel offset</td></tr>
<tr><td><code>wave_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>Sinusoidal screen warp</td></tr>
<tr><td><code>color_shift</code></td><td>0.0-1.0</td><td>0.0</td><td>Global color offset</td></tr>
<tr><td><code>kaleidoscope_segments</code></td><td>0-16</td><td>0.0</td><td>Mirror segment count</td></tr>
<tr><td><code>crt_scanlines</code></td><td>0.0-1.0</td><td>0.0</td><td>Scanline intensity</td></tr>
<tr><td><code>vignette</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge darkening</td></tr>
<tr><td><code>plasma_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Plasma overlay strength</td></tr>
<tr><td><code>glitch_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Digital glitch amount</td></tr>
<tr><td><code>mirror_mode</code></td><td>0.0-1.0</td><td>0.0</td><td>Screen mirroring</td></tr>
<tr><td><code>invert</code></td><td>0.0-1.0</td><td>0.0</td><td>Color inversion</td></tr>
<tr><td><code>hue_rotation</code></td><td>0.0-1.0</td><td>0.0</td><td>Hue shift amount</td></tr>
<tr><td><code>raymarch_mode</code></td><td>0-5</td><td>0.0</td><td>Raymarch effect type</td></tr>
<tr><td><code>raymarch_blend</code></td><td>0.0-1.0</td><td>0.0</td><td>Raymarch overlay blend</td></tr>
<tr><td><code>film_grain</code></td><td>0.0-1.0</td><td>0.0</td><td>Noise grain intensity</td></tr>
<tr><td><code>sharpen</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge sharpening</td></tr>
<tr><td><code>pixelate</code></td><td>0-64</td><td>0.0</td><td>Pixel size (0=off)</td></tr>
<tr><td><code>color_posterize</code></td><td>0-16</td><td>0.0</td><td>Color quantization</td></tr>
<tr><td><code>radial_blur</code></td><td>0.0-1.0</td><td>0.0</td><td>Center blur amount</td></tr>
<tr><td><code>tunnel_speed</code></td><td>0.0-5.0</td><td>1.0</td><td>Tunnel animation speed</td></tr>
<tr><td><code>fractal_iterations</code></td><td>1-8</td><td>4.0</td><td>Fractal detail level</td></tr>
<tr><td><code>glow_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Bloom-like glow</td></tr>
<tr><td><code>screen_shake</code></td><td>0.0-0.5</td><td>0.0</td><td>Camera shake offset</td></tr>
<tr><td><code>zoom_pulse</code></td><td>0.0-1.0</td><td>0.0</td><td>Rhythmic zoom amount</td></tr>
<tr><td><code>speed_lines</code></td><td>0.0-1.0</td><td>0.0</td><td>Motion line intensity</td></tr>
<tr><td><code>color_grade_mode</code></td><td>0-6</td><td>0.0</td><td>Color grading preset</td></tr>
<tr><td><code>vhs_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>VHS tape wobble</td></tr>
<tr><td><code>lens_flare</code></td><td>0.0-1.0</td><td>0.0</td><td>Light flare intensity</td></tr>
<tr><td><code>edge_glow</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge highlight amount</td></tr>
<tr><td><code>saturation</code></td><td>0.0-2.0</td><td>1.0</td><td>Color saturation</td></tr>
<tr><td><code>warp_speed</code></td><td>0.0-1.0</td><td>0.0</td><td>Hyperspace stretch</td></tr>
<tr><td><code>pulse_rings</code></td><td>0.0-1.0</td><td>0.0</td><td>Expanding ring effect</td></tr>
<tr><td><code>heat_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>Heat shimmer amount</td></tr>
<tr><td><code>digital_rain</code></td><td>0.0-1.0</td><td>0.0</td><td>Matrix rain effect</td></tr>
<tr><td><code>strobe</code></td><td>0.0-1.0</td><td>0.0</td><td>Flash intensity</td></tr>
<tr><td><code>color_cycle_speed</code></td><td>0.0-5.0</td><td>1.0</td><td>Auto color animation rate</td></tr>
<tr><td><code>feedback_amount</code></td><td>0.0-1.0</td><td>0.0</td><td>Frame feedback blend</td></tr>
<tr><td><code>ascii_mode</code></td><td>0.0-1.0</td><td>0.0</td><td>ASCII art conversion</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="openxr-vr"><a class="header" href="#openxr-vr">OpenXR VR</a></h1>
<blockquote>
<p>Requires feature: <code>openxr</code></p>
</blockquote>
<p>Nightshade supports VR headsets through the OpenXR standard using the Vulkan graphics backend.</p>
<h2 id="feature-flag"><a class="header" href="#feature-flag">Feature Flag</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { version = "...", features = ["openxr"] }
</code></pre>
<p>This pulls in <code>openxr</code>, <code>ash</code>, <code>wgpu-hal</code>, and <code>gpu-allocator</code> dependencies and forces the Vulkan backend.</p>
<h2 id="launching-in-vr"><a class="header" href="#launching-in-vr">Launching in VR</a></h2>
<p>Use <code>launch_xr()</code> instead of the normal application entry point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>launch_xr(MyState::default());
<span class="boring">}</span></code></pre></pre>
<p>This initializes the OpenXR runtime, creates a VR session, and begins the render loop with stereo rendering.</p>
<h2 id="xr-resources"><a class="header" href="#xr-resources">XR Resources</a></h2>
<p>Access VR state through <code>world.resources.xr</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xr = &amp;world.resources.xr;
<span class="boring">}</span></code></pre></pre>
<p>The <code>XrResources</code> struct provides:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>locomotion_enabled</code></td><td>Enable/disable thumbstick locomotion</td></tr>
<tr><td><code>locomotion_speed</code></td><td>Movement speed multiplier</td></tr>
</tbody></table>
</div>
<h2 id="controller-input"><a class="header" href="#controller-input">Controller Input</a></h2>
<p>Read controller state through <code>XrInput</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input = &amp;world.resources.xr.input;

if input.a_button_pressed() {
    // A button on right controller
}

if input.left_trigger_pressed() {
    // Left trigger
}

let left_pos = input.left_hand_position();
let left_rot = input.left_hand_rotation();
let head_pos = input.head_position();
<span class="boring">}</span></code></pre></pre>
<h3 id="available-inputs"><a class="header" href="#available-inputs">Available Inputs</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>left_trigger_pressed()</code> / <code>right_trigger_pressed()</code></td><td>Trigger buttons</td></tr>
<tr><td><code>left_grip_pressed()</code> / <code>right_grip_pressed()</code></td><td>Grip buttons</td></tr>
<tr><td><code>a_button_pressed()</code> / <code>b_button_pressed()</code></td><td>Face buttons (right controller)</td></tr>
<tr><td><code>x_button_pressed()</code> / <code>y_button_pressed()</code></td><td>Face buttons (left controller)</td></tr>
<tr><td><code>left_hand_position()</code> / <code>right_hand_position()</code></td><td>Controller positions in world space</td></tr>
<tr><td><code>left_hand_rotation()</code> / <code>right_hand_rotation()</code></td><td>Controller orientations</td></tr>
<tr><td><code>head_position()</code> / <code>head_rotation()</code></td><td>Headset tracking</td></tr>
<tr><td><code>left_thumbstick()</code> / <code>right_thumbstick()</code></td><td>Thumbstick axes</td></tr>
</tbody></table>
</div>
<h2 id="stereo-rendering"><a class="header" href="#stereo-rendering">Stereo Rendering</a></h2>
<p>The <code>XrRenderer</code> renders the scene twice per frame (once per eye) using the same render passes as the desktop renderer. View and projection matrices are provided by the OpenXR runtime through <code>XrFrameContext</code>.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>An OpenXR-compatible runtime must be installed (SteamVR, Oculus, etc.)</li>
<li>A VR headset must be connected</li>
<li>Vulkan GPU support is required</li>
<li>Desktop only (not available on WASM)</li>
</ul>
<p>The engine configures Oculus Touch controller bindings by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="steam-integration"><a class="header" href="#steam-integration">Steam Integration</a></h1>
<blockquote>
<p>Requires feature: <code>steam</code></p>
</blockquote>
<p>Nightshade provides Steam platform integration including achievements, stats, friends, P2P networking, and rich presence.</p>
<h2 id="feature-flag-1"><a class="header" href="#feature-flag-1">Feature Flag</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { version = "...", features = ["steam"] }
</code></pre>
<p>This pulls in the <code>steamworks</code> and <code>steamworks-sys</code> dependencies. Desktop only.</p>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>Access Steam through <code>world.resources.steam</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.steam.initialize();
}
<span class="boring">}</span></code></pre></pre>
<p>Call <code>run_callbacks()</code> each frame to process Steam events:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    world.resources.steam.run_callbacks();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="achievements"><a class="header" href="#achievements">Achievements</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let steam = &amp;mut world.resources.steam;

steam.unlock_achievement("FIRST_BLOOD");
steam.clear_achievement("FIRST_BLOOD");
steam.refresh_achievements();

for achievement in &amp;steam.achievements {
    let name = &amp;achievement.api_name;
    let unlocked = achievement.achieved;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="stats"><a class="header" href="#stats">Stats</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let steam = &amp;mut world.resources.steam;

steam.set_stat_int("kills", 42);
steam.set_stat_float("play_time", 3.5);
steam.store_stats();

steam.refresh_stats();
for stat in &amp;steam.stats {
    match &amp;stat.value {
        StatValue::Int(value) =&gt; { /* ... */ }
        StatValue::Float(value) =&gt; { /* ... */ }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="friends"><a class="header" href="#friends">Friends</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let steam = &amp;mut world.resources.steam;
steam.refresh_friends();

for friend in &amp;steam.friends {
    let name = &amp;friend.name;
    let state = &amp;friend.persona_state; // Online, Offline, Busy, Away, etc.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="p2p-networking"><a class="header" href="#p2p-networking">P2P Networking</a></h2>
<p>Send and receive messages between players:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let steam = &amp;mut world.resources.steam;

steam.setup_networking_callbacks();
steam.send_message(peer_steam_id, data_bytes, channel);

let messages = steam.receive_messages(channel);
for message in messages {
    let sender = message.sender;
    let data = &amp;message.data;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="session-management"><a class="header" href="#session-management">Session Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>steam.close_session(peer_steam_id);
let state = steam.get_session_state(peer_steam_id);
steam.refresh_session_states();
<span class="boring">}</span></code></pre></pre>
<p>Session states: <code>None</code>, <code>Connecting</code>, <code>Connected</code>, <code>ClosedByPeer</code>, <code>ProblemDetected</code>, <code>Failed</code>.</p>
<h2 id="rich-presence"><a class="header" href="#rich-presence">Rich Presence</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>steam.set_rich_presence("status", "In Battle - Level 5");
steam.clear_rich_presence();
<span class="boring">}</span></code></pre></pre>
<h2 id="overlays"><a class="header" href="#overlays">Overlays</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>steam.open_invite_dialog();
steam.open_overlay_to_user(friend_steam_id);
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-notes"><a class="header" href="#platform-notes">Platform Notes</a></h2>
<ul>
<li>Requires Steam client running on the user's machine</li>
<li>Desktop only (not available on WASM)</li>
<li>Graceful handling if Steam is unavailable — check <code>is_initialized()</code> before using</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-integration"><a class="header" href="#ai-integration">AI Integration</a></h1>
<p>Nightshade provides two features for AI integration: <code>mcp</code> for exposing the engine as a Model Context Protocol server, and <code>claude</code> for embedding Claude Code CLI as a subprocess. Both are native-only (not available on WASM).</p>
<h2 id="mcp-server"><a class="header" href="#mcp-server">MCP Server</a></h2>
<p>The <code>mcp</code> feature starts an HTTP-based MCP server on <code>http://127.0.0.1:3333/mcp</code> when the application launches. Any MCP-compatible client can connect and manipulate the running scene through structured tool calls.</p>
<h3 id="setup-2"><a class="header" href="#setup-2">Setup</a></h3>
<p>Enable the feature in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["mcp"] }
</code></pre>
<p>The server starts automatically during engine initialization. No code changes are needed beyond enabling the feature.</p>
<h3 id="connecting-claude-code"><a class="header" href="#connecting-claude-code">Connecting Claude Code</a></h3>
<p>Register the running engine as an MCP server:</p>
<pre><code class="language-bash">claude mcp add --transport http nightshade http://127.0.0.1:3333/mcp
</code></pre>
<p>Claude Code can then call any of the engine's MCP tools directly during a conversation.</p>
<h3 id="available-tools"><a class="header" href="#available-tools">Available Tools</a></h3>
<p>The MCP server exposes 50+ tools organized by category:</p>
<p><strong>Entity Management</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>list_entities</code></td><td>List all named entities in the scene</td></tr>
<tr><td><code>query_entity</code></td><td>Query detailed info about a specific entity (transform, material, components)</td></tr>
<tr><td><code>spawn_entity</code></td><td>Spawn a new entity with mesh, position, scale, color, emissive, parent, and alpha mode</td></tr>
<tr><td><code>despawn_entity</code></td><td>Remove an entity by name</td></tr>
<tr><td><code>clear_scene</code></td><td>Remove all named entities</td></tr>
</tbody></table>
</div>
<p><strong>Transforms</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_position</code></td><td>Set entity position as [x, y, z]</td></tr>
<tr><td><code>set_rotation</code></td><td>Set entity rotation using euler angles in radians</td></tr>
<tr><td><code>set_scale</code></td><td>Set entity scale as [x, y, z]</td></tr>
<tr><td><code>set_parent</code></td><td>Set or clear the parent of an entity</td></tr>
<tr><td><code>set_visibility</code></td><td>Show or hide an entity</td></tr>
</tbody></table>
</div>
<p><strong>Materials</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_material_color</code></td><td>Set the base color of an entity</td></tr>
<tr><td><code>set_emissive</code></td><td>Set emissive color (values &gt; 1.0 create HDR bloom)</td></tr>
<tr><td><code>set_material</code></td><td>Set full material properties (roughness, metallic, colors, alpha mode)</td></tr>
<tr><td><code>set_casts_shadow</code></td><td>Toggle shadow casting</td></tr>
</tbody></table>
</div>
<p><strong>Lighting</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spawn_light</code></td><td>Spawn a point, spot, or directional light</td></tr>
<tr><td><code>set_light</code></td><td>Modify existing light properties (color, intensity, range, cone angles, shadows)</td></tr>
</tbody></table>
</div>
<p><strong>Camera</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_camera</code></td><td>Set main camera position, target, and field of view</td></tr>
</tbody></table>
</div>
<p><strong>Assets</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>load_asset</code></td><td>Load a 3D asset from file (.glb, .gltf, or .fbx)</td></tr>
<tr><td><code>spawn_prefab</code></td><td>Spawn a loaded asset as a named entity</td></tr>
<tr><td><code>list_loaded_assets</code></td><td>List all assets available for spawning</td></tr>
</tbody></table>
</div>
<p><strong>Environment</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_atmosphere</code></td><td>Set skybox type (none, sky, cloudy_sky, space, nebula, sunset, hdr)</td></tr>
<tr><td><code>load_hdr</code></td><td>Load an HDR skybox from file</td></tr>
<tr><td><code>set_graphics</code></td><td>Configure bloom, SSAO, fog, tonemapping, DOF, gamma, saturation, grid, and more</td></tr>
</tbody></table>
</div>
<p><strong>Effects</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spawn_water</code></td><td>Spawn a water plane with wave parameters</td></tr>
<tr><td><code>spawn_particles</code></td><td>Spawn a particle emitter with preset (fire, smoke, sparks, firework variants)</td></tr>
<tr><td><code>set_particles</code></td><td>Modify emitter settings (enabled, spawn rate, emissive strength)</td></tr>
<tr><td><code>spawn_decal</code></td><td>Spawn a projected texture decal</td></tr>
</tbody></table>
</div>
<p><strong>Text</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spawn_hud_text</code></td><td>Spawn a 2D HUD text element with anchor, font size, color, alignment</td></tr>
<tr><td><code>set_hud_text</code></td><td>Modify an existing HUD text element</td></tr>
<tr><td><code>spawn_3d_text</code></td><td>Spawn text in world space (optionally billboard)</td></tr>
</tbody></table>
</div>
<p><strong>Physics</strong> (requires <code>physics</code> feature)</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>add_rigid_body</code></td><td>Add a rigid body (dynamic, kinematic, or static)</td></tr>
<tr><td><code>add_collider</code></td><td>Add a collider shape (ball, cuboid, capsule, cylinder)</td></tr>
<tr><td><code>apply_impulse</code></td><td>Apply an instant impulse or torque impulse</td></tr>
<tr><td><code>apply_force</code></td><td>Apply a continuous force or torque</td></tr>
<tr><td><code>set_velocity</code></td><td>Set linear and/or angular velocity</td></tr>
</tbody></table>
</div>
<p><strong>Animation</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>play_animation</code></td><td>Play an animation clip (by name or index) with looping, speed, and blend duration</td></tr>
<tr><td><code>stop_animation</code></td><td>Stop animation playback</td></tr>
<tr><td><code>list_animations</code></td><td>List available animation clips on an entity</td></tr>
</tbody></table>
</div>
<p><strong>Scripting</strong> (requires <code>scripting</code> feature)</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_script</code></td><td>Add or update a Rhai script on an entity</td></tr>
<tr><td><code>remove_script</code></td><td>Remove a script from an entity</td></tr>
<tr><td><code>set_game_state</code></td><td>Set values in the shared game state</td></tr>
<tr><td><code>get_game_state</code></td><td>Read values from the shared game state</td></tr>
</tbody></table>
</div>
<p><strong>Debug</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>add_line</code></td><td>Draw a debug line</td></tr>
<tr><td><code>add_lines</code></td><td>Draw multiple debug lines</td></tr>
<tr><td><code>clear_lines</code></td><td>Clear all debug lines</td></tr>
<tr><td><code>get_input</code></td><td>Get current input state (pressed keys, mouse position)</td></tr>
<tr><td><code>get_time</code></td><td>Get delta time and elapsed time</td></tr>
</tbody></table>
</div>
<p><strong>Batch Operations</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><code>batch</code></td><td>Execute multiple operations atomically in a single frame</td></tr>
<tr><td><code>run</code></td><td>Execute concise text commands (e.g. <code>spawn sun Sphere 0,0,0 scale:2 emissive:5,4,0</code>)</td></tr>
</tbody></table>
</div>
<h3 id="intercepting-mcp-commands"><a class="header" href="#intercepting-mcp-commands">Intercepting MCP Commands</a></h3>
<p>Applications can intercept MCP commands before the engine processes them by implementing <code>handle_mcp_command</code> on the <code>State</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(all(feature = "mcp", not(target_arch = "wasm32")))]
fn handle_mcp_command(
    &amp;mut self,
    world: &amp;mut World,
    command: &amp;McpCommand,
) -&gt; Option&lt;McpResponse&gt; {
    match command {
        McpCommand::SpawnEntity { name, .. } =&gt; {
            // Update editor scene tree after engine handles the spawn
            self.pending_scene_refresh = true;
            None // let engine handle it
        }
        McpCommand::DespawnEntity { name } =&gt; {
            self.scene_tree.remove(name);
            None // let engine handle it
        }
        McpCommand::ClearScene =&gt; {
            self.scene_tree.clear();
            None
        }
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Return <code>Some(McpResponse)</code> to fully handle a command yourself (the engine skips its default handler), or <code>None</code> to let the engine process it normally. This is useful for:</p>
<ul>
<li>Reacting to MCP-driven changes with application-specific side effects (e.g. updating a scene tree)</li>
<li>Blocking certain commands in specific contexts</li>
<li>Implementing custom commands in the future</li>
</ul>
<h3 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h3>
<p>The MCP server runs on a background thread using tokio and axum. Communication with the main engine thread happens through lock-free queues:</p>
<ol>
<li>MCP client sends a tool call via HTTP</li>
<li>The server deserializes the request into an <code>McpCommand</code> and pushes it to the command queue</li>
<li>On the next frame, the engine drains the queue and processes each command</li>
<li>Responses are written to the response queue</li>
<li>The server reads the response and returns it to the MCP client</li>
</ol>
<p>Commands are processed once per frame, after <code>run_systems()</code> and before <code>run_frame_systems()</code>. This means MCP-driven changes are visible to the same frame's transform, physics, and rendering systems.</p>
<h2 id="claude-code-cli"><a class="header" href="#claude-code-cli">Claude Code CLI</a></h2>
<p>The <code>claude</code> feature provides a background worker for spawning Claude Code as a subprocess and streaming its JSON output. This lets applications embed an AI chat interface.</p>
<h3 id="setup-3"><a class="header" href="#setup-3">Setup</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["claude"] }
</code></pre>
<p>Requires the <code>claude</code> CLI to be installed and available on <code>PATH</code>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Create channels and spawn the worker:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (command_sender, command_receiver, event_sender, event_receiver) =
    nightshade::claude::create_cli_channels();

nightshade::claude::spawn_cli_worker(
    command_receiver,
    event_sender,
    ClaudeConfig {
        system_prompt: Some("You are a scene designer.".to_string()),
        mcp_config: McpConfig::Auto,
        ..Default::default()
    },
);
<span class="boring">}</span></code></pre></pre>
<p>Send a query:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>command_sender.send(CliCommand::StartQuery {
    prompt: "Create a forest scene with 10 trees".to_string(),
    session_id: None,
    model: None,
}).ok();
<span class="boring">}</span></code></pre></pre>
<p>Poll for events each frame:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Ok(event) = event_receiver.try_recv() {
    match event {
        CliEvent::TextDelta { text } =&gt; self.chat_buffer.push_str(&amp;text),
        CliEvent::ThinkingDelta { text } =&gt; self.thinking_buffer.push_str(&amp;text),
        CliEvent::ToolUseStarted { tool_name, .. } =&gt; {
            self.status = format!("Using tool: {}", tool_name);
        }
        CliEvent::Complete { total_cost_usd, num_turns, .. } =&gt; {
            self.status = format!("Done ({} turns)", num_turns);
        }
        CliEvent::Error { message } =&gt; {
            self.status = format!("Error: {}", message);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="claudeconfig"><a class="header" href="#claudeconfig">ClaudeConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>system_prompt</code></td><td><code>Option&lt;String&gt;</code></td><td>Appended to Claude's system prompt via <code>--append-system-prompt</code></td></tr>
<tr><td><code>allowed_tools</code></td><td><code>Option&lt;Vec&lt;String&gt;&gt;</code></td><td>Restrict which tools Claude can use (<code>--allowedTools</code>)</td></tr>
<tr><td><code>disallowed_tools</code></td><td><code>Option&lt;Vec&lt;String&gt;&gt;</code></td><td>Block specific tools (<code>--disallowedTools</code>)</td></tr>
<tr><td><code>mcp_config</code></td><td><code>McpConfig</code></td><td><code>Auto</code> (auto-connect to engine MCP), <code>Custom(json)</code>, or <code>None</code></td></tr>
<tr><td><code>custom_args</code></td><td><code>Vec&lt;String&gt;</code></td><td>Additional CLI arguments passed directly to <code>claude</code></td></tr>
</tbody></table>
</div>
<h3 id="auto-mcp-configuration"><a class="header" href="#auto-mcp-configuration">Auto MCP Configuration</a></h3>
<p>When both <code>claude</code> and <code>mcp</code> features are enabled and <code>mcp_config</code> is set to <code>McpConfig::Auto</code> (the default), the worker automatically passes <code>--mcp-config</code> with a JSON payload pointing at <code>http://127.0.0.1:3333/mcp</code>. This means Claude Code can call engine tools without any manual <code>mcp add</code> step.</p>
<h3 id="clievent-types"><a class="header" href="#clievent-types">CliEvent Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Fields</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SessionStarted</code></td><td><code>session_id</code></td><td>A new Claude session was created</td></tr>
<tr><td><code>TextDelta</code></td><td><code>text</code></td><td>Incremental text output from Claude</td></tr>
<tr><td><code>ThinkingDelta</code></td><td><code>text</code></td><td>Incremental thinking/reasoning output</td></tr>
<tr><td><code>ToolUseStarted</code></td><td><code>tool_name</code>, <code>tool_id</code></td><td>Claude began calling a tool</td></tr>
<tr><td><code>ToolUseInputDelta</code></td><td><code>tool_id</code>, <code>partial_json</code></td><td>Streaming tool input JSON</td></tr>
<tr><td><code>ToolUseFinished</code></td><td><code>tool_id</code></td><td>Tool call completed</td></tr>
<tr><td><code>TurnComplete</code></td><td><code>session_id</code></td><td>Claude finished a turn (may continue)</td></tr>
<tr><td><code>Complete</code></td><td><code>session_id</code>, <code>total_cost_usd</code>, <code>num_turns</code></td><td>Full query completed</td></tr>
<tr><td><code>Error</code></td><td><code>message</code></td><td>An error occurred</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="webview"><a class="header" href="#webview">Webview</a></h1>
<blockquote>
<p>Requires feature: <code>webview</code></p>
</blockquote>
<p>Nightshade can embed web views inside the application window, enabling hybrid native/web UIs. The system provides bidirectional communication between the engine (host) and web content (client) using typed commands and events.</p>
<h2 id="feature-flag-2"><a class="header" href="#feature-flag-2">Feature Flag</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { version = "...", features = ["webview"] }
</code></pre>
<p>This pulls in <code>wry</code> (Tauri's webview library) and <code>tiny_http</code> on desktop, and <code>wasm-bindgen</code>/<code>web-sys</code> on WASM.</p>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<p>The webview system uses a generic <code>WebviewContext&lt;Cmd, Evt&gt;</code> where:</p>
<ul>
<li><code>Cmd</code> — command type sent from the web client to the engine</li>
<li><code>Evt</code> — event type sent from the engine to the web client</li>
</ul>
<p>Both types must implement <code>serde::Serialize</code> and <code>serde::Deserialize</code>. Messages are serialized with <code>postcard</code> (compact binary format) and encoded as base64 for transport.</p>
<h2 id="host-side-desktop"><a class="header" href="#host-side-desktop">Host Side (Desktop)</a></h2>
<h3 id="serving-web-content"><a class="header" href="#serving-web-content">Serving Web Content</a></h3>
<p>Embed static web assets and serve them via a local HTTP server:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>serve_embedded_dir(embedded_assets, port);
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-the-webview"><a class="header" href="#creating-the-webview">Creating the Webview</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let webview_context: WebviewContext&lt;MyCommand, MyEvent&gt; = WebviewContext::new();
webview_context.ensure_webview(bounds, window_handle);
<span class="boring">}</span></code></pre></pre>
<p>The webview is positioned within the application window at the specified bounds.</p>
<h3 id="sending-events-to-the-client"><a class="header" href="#sending-events-to-the-client">Sending Events to the Client</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>webview_context.send_event(MyEvent::ScoreUpdated(42));
<span class="boring">}</span></code></pre></pre>
<h3 id="receiving-commands-from-the-client"><a class="header" href="#receiving-commands-from-the-client">Receiving Commands from the Client</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for command in webview_context.drain_commands() {
    match command {
        MyCommand::StartGame =&gt; { /* ... */ }
        MyCommand::SetOption(key, value) =&gt; { /* ... */ }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="client-side-wasm"><a class="header" href="#client-side-wasm">Client Side (WASM)</a></h2>
<p>The web content runs as a standard web page that communicates with the engine through IPC.</p>
<h3 id="connecting"><a class="header" href="#connecting">Connecting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>connect::&lt;MyCommand, MyEvent&gt;(|event| {
    match event {
        MyEvent::ScoreUpdated(score) =&gt; { /* update UI */ }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="sending-commands"><a class="header" href="#sending-commands">Sending Commands</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>send(MyCommand::StartGame);
<span class="boring">}</span></code></pre></pre>
<h2 id="transport"><a class="header" href="#transport">Transport</a></h2>
<p>Communication uses the <code>__nwv__</code> IPC handler:</p>
<div class="table-wrapper"><table><thead><tr><th>Direction</th><th>Desktop</th><th>WASM</th></tr></thead><tbody>
<tr><td>Host → Client</td><td><code>webview.evaluate_script()</code></td><td>N/A</td></tr>
<tr><td>Client → Host</td><td><code>ipc.postMessage()</code></td><td><code>window.__nwv__</code></td></tr>
</tbody></table>
</div>
<p>Messages are serialized as: <code>postcard binary → base64 string</code>.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backend</th></tr></thead><tbody>
<tr><td>Windows</td><td>WebView2 (Edge/Chromium)</td></tr>
<tr><td>macOS</td><td>WKWebView</td></tr>
<tr><td>Linux</td><td>WebKitGTK</td></tr>
<tr><td>WASM</td><td>Browser-native (client only)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-plugins"><a class="header" href="#wasm-plugins">WASM Plugins</a></h1>
<blockquote>
<p>Requires feature: <code>plugin_runtime</code></p>
</blockquote>
<p>Nightshade includes a WASM-based plugin system that allows loading and executing WebAssembly modules at runtime. Plugins can spawn entities, manipulate transforms, load assets, and respond to input events.</p>
<h2 id="feature-flags-2"><a class="header" href="#feature-flags-2">Feature Flags</a></h2>
<pre><code class="language-toml">[dependencies]
nightshade = { version = "...", features = ["plugin_runtime"] }
</code></pre>
<p>The <code>plugin_runtime</code> feature enables the Wasmtime-based runtime and WASI support. The base <code>plugins</code> feature provides the shared command/event types for writing plugin guest code. Desktop only.</p>
<h2 id="plugin-runtime"><a class="header" href="#plugin-runtime">Plugin Runtime</a></h2>
<h3 id="loading-plugins"><a class="header" href="#loading-plugins">Loading Plugins</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut runtime = PluginRuntime::new(PluginRuntimeConfig {
    plugins_path: "plugins/".to_string(),
    ..Default::default()
});

runtime.load_plugin("plugins/my_plugin.wasm");
runtime.load_plugins_from_directory("plugins/");
<span class="boring">}</span></code></pre></pre>
<h3 id="running-plugins-each-frame"><a class="header" href="#running-plugins-each-frame">Running Plugins Each Frame</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    runtime.run_plugins_frame(world);
    runtime.process_pending_commands(world);
}
<span class="boring">}</span></code></pre></pre>
<p><code>run_plugins_frame()</code> calls each plugin's <code>on_frame()</code> export. <code>process_pending_commands()</code> executes any engine commands the plugins have queued.</p>
<h2 id="plugin-lifecycle"><a class="header" href="#plugin-lifecycle">Plugin Lifecycle</a></h2>
<p>Plugins are compiled WASM modules that export specific functions:</p>
<div class="table-wrapper"><table><thead><tr><th>Export</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>on_init()</code></td><td>No</td><td>Called once when the plugin is loaded</td></tr>
<tr><td><code>on_frame()</code></td><td>No</td><td>Called every frame</td></tr>
<tr><td><code>plugin_alloc(size) -&gt; *mut u8</code></td><td>Yes</td><td>Memory allocation for receiving events</td></tr>
<tr><td><code>plugin_receive_event(ptr, len)</code></td><td>Yes</td><td>Receives serialized events from the engine</td></tr>
</tbody></table>
</div>
<h2 id="engine-commands"><a class="header" href="#engine-commands">Engine Commands</a></h2>
<p>Plugins send commands to the engine through a host-provided API:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SpawnPrimitive</code></td><td>Create a cube, sphere, cylinder, plane, or cone</td></tr>
<tr><td><code>DespawnEntity</code></td><td>Remove an entity</td></tr>
<tr><td><code>SetEntityPosition</code></td><td>Set entity world position</td></tr>
<tr><td><code>SetEntityScale</code></td><td>Set entity scale</td></tr>
<tr><td><code>SetEntityRotation</code></td><td>Set entity rotation</td></tr>
<tr><td><code>GetEntityPosition</code></td><td>Request entity position (async)</td></tr>
<tr><td><code>GetEntityScale</code></td><td>Request entity scale (async)</td></tr>
<tr><td><code>GetEntityRotation</code></td><td>Request entity rotation (async)</td></tr>
<tr><td><code>SetEntityMaterial</code></td><td>Set material properties</td></tr>
<tr><td><code>SetEntityColor</code></td><td>Set entity color</td></tr>
<tr><td><code>LoadTexture</code></td><td>Load a texture by path</td></tr>
<tr><td><code>LoadPrefab</code></td><td>Load a glTF prefab</td></tr>
<tr><td><code>ReadFile</code></td><td>Read a file from disk</td></tr>
<tr><td><code>Log</code></td><td>Print a message to the host console</td></tr>
</tbody></table>
</div>
<h3 id="guest-api"><a class="header" href="#guest-api">Guest API</a></h3>
<p>From within a plugin:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::plugin::*;

fn on_init() {
    let entity_id = spawn_primitive(Primitive::Cube, 0.0, 1.0, 0.0);
    set_entity_position(entity_id, 5.0, 2.0, 0.0);
    log("Plugin initialized!");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="engine-events"><a class="header" href="#engine-events">Engine Events</a></h2>
<p>Events sent from the engine to plugins:</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FrameStart</code></td><td>New frame beginning</td></tr>
<tr><td><code>KeyPressed</code> / <code>KeyReleased</code></td><td>Keyboard input</td></tr>
<tr><td><code>MouseMoved</code></td><td>Mouse position change</td></tr>
<tr><td><code>MouseButtonPressed</code> / <code>MouseButtonReleased</code></td><td>Mouse button input</td></tr>
<tr><td><code>EntitySpawned</code></td><td>Entity creation confirmed with host entity ID</td></tr>
<tr><td><code>FileLoaded</code> / <code>TextureLoaded</code> / <code>PrefabLoaded</code></td><td>Async asset load results</td></tr>
<tr><td><code>Error</code></td><td>Error notification</td></tr>
</tbody></table>
</div>
<h2 id="entity-id-mapping"><a class="header" href="#entity-id-mapping">Entity ID Mapping</a></h2>
<p>Plugins use their own entity ID space. The runtime maintains a bidirectional mapping between plugin entity IDs and host entity IDs. When a plugin spawns an entity, it receives a local ID immediately and gets the real host ID through an <code>EntitySpawned</code> event.</p>
<h2 id="custom-linker-functions"><a class="header" href="#custom-linker-functions">Custom Linker Functions</a></h2>
<p>Extend the plugin API with custom host functions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>runtime.with_custom_linker(|linker| {
    linker.func_wrap("env", "my_custom_function", |param: i32| -&gt; i32 {
        param * 2
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-notes-1"><a class="header" href="#platform-notes-1">Platform Notes</a></h2>
<ul>
<li>Desktop only (uses Wasmtime, not available on WASM targets)</li>
<li>Full WASI P1 support for file I/O within plugins</li>
<li>Memory-safe communication via postcard serialization</li>
<li>Automatic cleanup of plugin resources on configurable intervals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-building-a-3d-game"><a class="header" href="#tutorial-building-a-3d-game">Tutorial: Building a 3D Game</a></h1>
<p>This tutorial walks through building a complete 3D Pong game from scratch. By the end, you'll have two paddles, a bouncing ball, AI opponent, scoring, pause/unpause, and a game-over screen — all rendered in 3D with PBR materials and egui overlays.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>Create a new project:</p>
<pre><code class="language-bash">cargo init pong-game
</code></pre>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "pong-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/user/nightshade", features = ["engine", "wgpu"] }
rand = "0.9"
</code></pre>
<h2 id="step-1-the-empty-window"><a class="header" href="#step-1-the-empty-window">Step 1: The Empty Window</a></h2>
<p>Every Nightshade application starts with a struct that implements the <code>State</code> trait and a call to <code>launch</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct PongGame;

impl State for PongGame {
    fn title(&amp;self) -&gt; &amp;str {
        "Pong"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        let camera = spawn_camera(world, Vec3::new(0.0, 0.0, 15.0), "Camera".to_string());
        world.resources.active_camera = Some(camera);
        spawn_sun(world);
    }
}

fn main() {
    launch(PongGame);
}</code></pre></pre>
<p><code>launch</code> creates the window, initializes the wgpu renderer, calls <code>initialize</code> once, then runs the game loop calling <code>run_systems</code> every frame. The camera is positioned at <code>(0, 0, 15)</code> looking toward the origin, and we add a directional light so objects are visible.</p>
<p>Run it and you'll see an empty scene with a grid floor.</p>
<h2 id="step-2-game-constants-and-state"><a class="header" href="#step-2-game-constants-and-state">Step 2: Game Constants and State</a></h2>
<p>Define the arena dimensions and game state. All game data lives in your state struct — the engine doesn't own any of it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::material::resources::material_registry_insert;
use nightshade::prelude::*;

const PADDLE_WIDTH: f32 = 0.3;
const PADDLE_HEIGHT: f32 = 2.0;
const PADDLE_DEPTH: f32 = 0.3;
const PADDLE_SPEED: f32 = 8.0;
const BALL_SIZE: f32 = 0.3;
const BALL_SPEED: f32 = 6.0;
const ARENA_WIDTH: f32 = 12.0;
const ARENA_HEIGHT: f32 = 8.0;
const WINNING_SCORE: u32 = 5;

#[derive(Default)]
struct PongGame {
    left_paddle_y: f32,
    right_paddle_y: f32,
    ball_x: f32,
    ball_y: f32,
    ball_vel_x: f32,
    ball_vel_y: f32,
    left_score: u32,
    right_score: u32,
    left_paddle_entity: Option&lt;Entity&gt;,
    right_paddle_entity: Option&lt;Entity&gt;,
    ball_entity: Option&lt;Entity&gt;,
    paused: bool,
    game_over: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>The game state is separate from the ECS world. The ECS holds the visual entities (meshes, transforms, materials). Your struct holds game logic data (positions, velocities, scores). Each frame, you update game logic first, then sync the ECS transforms to match.</p>
<h2 id="step-3-spawning-game-objects"><a class="header" href="#step-3-spawning-game-objects">Step 3: Spawning Game Objects</a></h2>
<p>Create the paddles, ball, and walls. Each is a mesh entity with a material:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn create_game_objects(&amp;mut self, world: &amp;mut World) {
        self.left_paddle_entity = Some(self.spawn_colored_mesh(
            world,
            "Cube",
            Vec3::new(-ARENA_WIDTH / 2.0 + 0.5, 0.0, 0.0),
            Vec3::new(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH),
            [0.2, 0.6, 1.0, 1.0],
        ));

        self.right_paddle_entity = Some(self.spawn_colored_mesh(
            world,
            "Cube",
            Vec3::new(ARENA_WIDTH / 2.0 - 0.5, 0.0, 0.0),
            Vec3::new(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH),
            [1.0, 0.4, 0.2, 1.0],
        ));

        self.ball_entity = Some(self.spawn_colored_mesh(
            world,
            "Sphere",
            Vec3::zeros(),
            Vec3::new(BALL_SIZE, BALL_SIZE, BALL_SIZE),
            [1.0, 1.0, 1.0, 1.0],
        ));

        self.spawn_colored_mesh(
            world,
            "Cube",
            Vec3::new(0.0, ARENA_HEIGHT / 2.0 + 0.25, 0.0),
            Vec3::new(ARENA_WIDTH + 1.0, 0.5, 0.5),
            [0.5, 0.5, 0.5, 1.0],
        );

        self.spawn_colored_mesh(
            world,
            "Cube",
            Vec3::new(0.0, -ARENA_HEIGHT / 2.0 - 0.25, 0.0),
            Vec3::new(ARENA_WIDTH + 1.0, 0.5, 0.5),
            [0.5, 0.5, 0.5, 1.0],
        );
    }

    fn spawn_colored_mesh(
        &amp;self,
        world: &amp;mut World,
        mesh_name: &amp;str,
        position: Vec3,
        scale: Vec3,
        color: [f32; 4],
    ) -&gt; Entity {
        let entity = spawn_mesh(world, mesh_name, position, scale);

        let material_name = format!("mat_{}", entity.id);
        material_registry_insert(
            &amp;mut world.resources.material_registry,
            material_name.clone(),
            Material {
                base_color: color,
                ..Default::default()
            },
        );

        if let Some(&amp;index) = world
            .resources
            .material_registry
            .registry
            .name_to_index
            .get(&amp;material_name)
        {
            world.resources.material_registry.registry.add_reference(index);
        }

        world.set_material_ref(entity, MaterialRef::new(material_name));
        entity
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>spawn_mesh</code> creates an entity with <code>LOCAL_TRANSFORM</code>, <code>GLOBAL_TRANSFORM</code>, and <code>RENDER_MESH</code> components. The material is registered in the global <code>MaterialRegistry</code> by name, then assigned to the entity via <code>MaterialRef</code>. Each material needs a unique name — using the entity ID ensures no collisions.</p>
<h2 id="step-4-ball-movement-and-reset"><a class="header" href="#step-4-ball-movement-and-reset">Step 4: Ball Movement and Reset</a></h2>
<p>The ball moves in a straight line, bouncing off walls and paddles:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn reset_ball(&amp;mut self) {
        self.ball_x = 0.0;
        self.ball_y = 0.0;
        let angle = (rand::random::&lt;f32&gt;() - 0.5) * std::f32::consts::PI * 0.5;
        self.ball_vel_x = BALL_SPEED * angle.cos();
        self.ball_vel_y = BALL_SPEED * angle.sin();
    }

    fn ball_movement_system(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;
        self.ball_x += self.ball_vel_x * dt;
        self.ball_y += self.ball_vel_y * dt;
    }

    fn normalize_ball_speed(&amp;mut self) {
        let speed = (self.ball_vel_x * self.ball_vel_x + self.ball_vel_y * self.ball_vel_y).sqrt();
        self.ball_vel_x *= BALL_SPEED / speed;
        self.ball_vel_y *= BALL_SPEED / speed;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Time comes from <code>world.resources.window.timing.delta_time</code>, which gives the frame duration in seconds. Multiplying velocity by delta time makes movement frame-rate independent.</p>
<h2 id="step-5-input-and-ai"><a class="header" href="#step-5-input-and-ai">Step 5: Input and AI</a></h2>
<p>The player controls the left paddle with W/S or arrow keys. The AI tracks the ball's Y position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn input_system(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;
        let keyboard = &amp;world.resources.input.keyboard;

        if keyboard.is_key_pressed(KeyCode::KeyW) || keyboard.is_key_pressed(KeyCode::ArrowUp) {
            self.left_paddle_y += PADDLE_SPEED * dt;
        }
        if keyboard.is_key_pressed(KeyCode::KeyS) || keyboard.is_key_pressed(KeyCode::ArrowDown) {
            self.left_paddle_y -= PADDLE_SPEED * dt;
        }

        let max_y = ARENA_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        self.left_paddle_y = self.left_paddle_y.clamp(-max_y, max_y);
    }

    fn ai_system(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;
        let distance = self.ball_y - self.right_paddle_y;

        if distance.abs() &gt; 0.2 {
            self.right_paddle_y += distance.signum() * PADDLE_SPEED * 0.75 * dt;
        }

        let max_y = ARENA_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        self.right_paddle_y = self.right_paddle_y.clamp(-max_y, max_y);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Input is polled via <code>world.resources.input.keyboard.is_key_pressed()</code>. This checks whether a key is currently held down (not just pressed this frame).</p>
<h2 id="step-6-collision-detection"><a class="header" href="#step-6-collision-detection">Step 6: Collision Detection</a></h2>
<p>Check ball against walls and paddles. When the ball passes a paddle's edge, score a point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn collision_system(&amp;mut self) {
        let ball_max_y = ARENA_HEIGHT / 2.0 - BALL_SIZE;
        if self.ball_y &gt; ball_max_y {
            self.ball_y = ball_max_y;
            self.ball_vel_y = -self.ball_vel_y.abs();
        } else if self.ball_y &lt; -ball_max_y {
            self.ball_y = -ball_max_y;
            self.ball_vel_y = self.ball_vel_y.abs();
        }

        let left_x = -ARENA_WIDTH / 2.0 + 0.5;
        if self.ball_x &lt; left_x + PADDLE_WIDTH / 2.0 + BALL_SIZE
            &amp;&amp; self.ball_x &gt; left_x - PADDLE_WIDTH / 2.0
            &amp;&amp; (self.ball_y - self.left_paddle_y).abs() &lt; PADDLE_HEIGHT / 2.0 + BALL_SIZE
        {
            self.ball_x = left_x + PADDLE_WIDTH / 2.0 + BALL_SIZE;
            self.ball_vel_x = self.ball_vel_x.abs();
            let hit_offset = (self.ball_y - self.left_paddle_y) / (PADDLE_HEIGHT / 2.0);
            self.ball_vel_y += hit_offset * 2.0;
            self.normalize_ball_speed();
        }

        let right_x = ARENA_WIDTH / 2.0 - 0.5;
        if self.ball_x &gt; right_x - PADDLE_WIDTH / 2.0 - BALL_SIZE
            &amp;&amp; self.ball_x &lt; right_x + PADDLE_WIDTH / 2.0
            &amp;&amp; (self.ball_y - self.right_paddle_y).abs() &lt; PADDLE_HEIGHT / 2.0 + BALL_SIZE
        {
            self.ball_x = right_x - PADDLE_WIDTH / 2.0 - BALL_SIZE;
            self.ball_vel_x = -self.ball_vel_x.abs();
            let hit_offset = (self.ball_y - self.right_paddle_y) / (PADDLE_HEIGHT / 2.0);
            self.ball_vel_y += hit_offset * 2.0;
            self.normalize_ball_speed();
        }

        if self.ball_x &lt; -ARENA_WIDTH / 2.0 - 1.0 {
            self.right_score += 1;
            self.reset_ball();
            if self.right_score &gt;= WINNING_SCORE {
                self.game_over = true;
            }
        } else if self.ball_x &gt; ARENA_WIDTH / 2.0 + 1.0 {
            self.left_score += 1;
            self.reset_ball();
            if self.left_score &gt;= WINNING_SCORE {
                self.game_over = true;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Where the ball hits the paddle affects the bounce angle — hitting the edge sends the ball at a steeper angle, hitting the center keeps it flat. After adjusting the velocity, <code>normalize_ball_speed()</code> ensures the ball always moves at <code>BALL_SPEED</code>.</p>
<h2 id="step-7-syncing-visuals"><a class="header" href="#step-7-syncing-visuals">Step 7: Syncing Visuals</a></h2>
<p>After updating game logic, write the positions back to the ECS transforms. This is where game state becomes visible:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn update_visuals(&amp;mut self, world: &amp;mut World) {
        if let Some(entity) = self.left_paddle_entity {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.translation.y = self.left_paddle_y;
            }
            mark_local_transform_dirty(world, entity);
        }

        if let Some(entity) = self.right_paddle_entity {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.translation.y = self.right_paddle_y;
            }
            mark_local_transform_dirty(world, entity);
        }

        if let Some(entity) = self.ball_entity {
            if let Some(transform) = world.get_local_transform_mut(entity) {
                transform.translation.x = self.ball_x;
                transform.translation.y = self.ball_y;
            }
            mark_local_transform_dirty(world, entity);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>mark_local_transform_dirty</code> tells the engine that this entity's transform changed and the global transform hierarchy needs to be recalculated. Without it, the entity won't visually move.</p>
<h2 id="step-8-the-game-loop"><a class="header" href="#step-8-the-game-loop">Step 8: The Game Loop</a></h2>
<p>Wire everything together in the <code>State</code> trait implementation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for PongGame {
    fn title(&amp;self) -&gt; &amp;str {
        "Pong"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.graphics.atmosphere = Atmosphere::Space;
        world.resources.graphics.show_grid = false;
        world.resources.user_interface.enabled = true;

        spawn_sun_without_shadows(world);

        let camera = spawn_camera(world, Vec3::new(0.0, 0.0, 15.0), "Camera".to_string());
        if let Some(camera_component) = world.get_camera_mut(camera) {
            camera_component.projection = Projection::Perspective(PerspectiveCamera {
                aspect_ratio: None,
                y_fov_rad: 60.0_f32.to_radians(),
                z_far: Some(1000.0),
                z_near: 0.1,
            });
        }
        world.resources.active_camera = Some(camera);

        self.create_game_objects(world);
        self.reset_ball();
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        escape_key_exit_system(world);

        if !self.paused &amp;&amp; !self.game_over {
            self.input_system(world);
            self.ai_system(world);
            self.ball_movement_system(world);
            self.collision_system();
        }

        self.update_visuals(world);
    }

    fn on_keyboard_input(&amp;mut self, _world: &amp;mut World, key: KeyCode, state: KeyState) {
        if state == KeyState::Pressed {
            match key {
                KeyCode::Space =&gt; self.paused = !self.paused,
                KeyCode::KeyR =&gt; self.reset_game(),
                _ =&gt; {}
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>run_systems</code> is called every frame. The pattern is: check input → update game logic → detect collisions → sync visuals. <code>on_keyboard_input</code> handles one-shot key events (pressed/released) rather than held keys.</p>
<h2 id="step-9-ui-overlay-with-egui"><a class="header" href="#step-9-ui-overlay-with-egui">Step 9: UI Overlay with egui</a></h2>
<p>Add score display and pause/game-over screens. The <code>ui</code> method receives an egui context for immediate-mode UI:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for PongGame {
    fn ui(&amp;mut self, _world: &amp;mut World, ctx: &amp;egui::Context) {
        egui::Window::new("Score")
            .anchor(egui::Align2::CENTER_TOP, [0.0, 10.0])
            .resizable(false)
            .collapsible(false)
            .title_bar(false)
            .show(ctx, |ui| {
                ui.heading(format!("{} - {}", self.left_score, self.right_score));
            });

        if self.paused {
            egui::CentralPanel::default()
                .frame(egui::Frame::new().fill(egui::Color32::from_black_alpha(180)))
                .show(ctx, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(100.0);
                        ui.heading("PAUSED");
                        ui.add_space(20.0);
                        ui.label("Press SPACE to resume");
                        ui.label("Press R to restart");
                    });
                });
        }

        if self.game_over {
            egui::CentralPanel::default()
                .frame(egui::Frame::new().fill(egui::Color32::from_black_alpha(180)))
                .show(ctx, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(100.0);
                        let winner = if self.left_score &gt;= WINNING_SCORE {
                            "You Win!"
                        } else {
                            "AI Wins!"
                        };
                        ui.heading(winner);
                        ui.add_space(10.0);
                        ui.label(format!("Final Score: {} - {}", self.left_score, self.right_score));
                        ui.add_space(20.0);
                        ui.label("Press R to play again");
                    });
                });
        }

        egui::Window::new("Controls")
            .anchor(egui::Align2::LEFT_BOTTOM, [10.0, -10.0])
            .resizable(false)
            .collapsible(false)
            .show(ctx, |ui| {
                ui.label("W/S or Up/Down - Move paddle");
                ui.label("SPACE - Pause");
                ui.label("R - Restart");
                ui.label("ESC - Exit");
            });
    }
}
<span class="boring">}</span></code></pre></pre>
<p>egui runs at the end of each frame, after rendering. The <code>anchor</code> method positions windows relative to screen edges. <code>CentralPanel</code> covers the entire screen — useful for overlay menus.</p>
<h2 id="step-10-game-reset"><a class="header" href="#step-10-game-reset">Step 10: Game Reset</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PongGame {
    fn reset_game(&amp;mut self) {
        self.left_paddle_y = 0.0;
        self.right_paddle_y = 0.0;
        self.left_score = 0;
        self.right_score = 0;
        self.paused = false;
        self.game_over = false;
        self.reset_ball();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Since game state lives in your struct (not the ECS), resetting is just zeroing your fields. The ECS entities remain — they just get new transform values next frame.</p>
<h2 id="key-patterns-demonstrated"><a class="header" href="#key-patterns-demonstrated">Key Patterns Demonstrated</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Where Used</th></tr></thead><tbody>
<tr><td>State trait lifecycle</td><td><code>initialize</code>, <code>run_systems</code>, <code>on_keyboard_input</code>, <code>ui</code></td></tr>
<tr><td>Entity spawning</td><td><code>spawn_mesh</code> + material registration</td></tr>
<tr><td>Frame-rate independent movement</td><td><code>velocity * delta_time</code></td></tr>
<tr><td>Input polling</td><td><code>keyboard.is_key_pressed()</code> for held keys</td></tr>
<tr><td>One-shot input events</td><td><code>on_keyboard_input</code> for press/release</td></tr>
<tr><td>Transform updates</td><td><code>get_local_transform_mut</code> + <code>mark_local_transform_dirty</code></td></tr>
<tr><td>Game state separation</td><td>Logic in struct fields, visuals in ECS</td></tr>
<tr><td>egui overlays</td><td>Score display, pause menu, game over screen</td></tr>
</tbody></table>
</div>
<h2 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to Go Next</a></h2>
<p>From this foundation you can add:</p>
<ul>
<li><strong>Physics</strong>: Replace manual collision with Rapier rigid bodies and colliders. See <a href="physics-overview.html">Physics Overview</a>.</li>
<li><strong>Audio</strong>: Add sound effects with <code>load_sound</code> and <code>play_sound</code>. See <a href="audio-system.html">Audio System</a>.</li>
<li><strong>3D Models</strong>: Replace cubes with loaded glTF models via <code>load_gltf</code>. See <a href="meshes-models.html">Meshes &amp; Models</a>.</li>
<li><strong>Particles</strong>: Add spark effects on ball collision. See <a href="particles.html">Particle Systems</a>.</li>
<li><strong>Materials</strong>: Make the ball emissive so it glows. See <a href="materials.html">Materials</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-building-a-terminal-game"><a class="header" href="#tutorial-building-a-terminal-game">Tutorial: Building a Terminal Game</a></h1>
<p>This tutorial walks through building a Snake game that runs entirely in the terminal. Nightshade's TUI framework provides an ECS, double-buffered rendering, input handling, and collision detection — the same architecture as the 3D engine, but rendering characters instead of meshes.</p>
<h2 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h2>
<pre><code class="language-bash">cargo init terminal-snake
</code></pre>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "terminal-snake"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/user/nightshade", features = ["terminal"] }
rand = "0.9"
</code></pre>
<p>The <code>terminal</code> feature enables the crossterm-based terminal renderer. No GPU, no window — just your terminal emulator.</p>
<h2 id="step-1-the-empty-terminal-app"><a class="header" href="#step-1-the-empty-terminal-app">Step 1: The Empty Terminal App</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::tui::prelude::*;

struct SnakeGame;

impl State for SnakeGame {
    fn title(&amp;self) -&gt; &amp;str {
        "Snake"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.timing.target_fps = 60;
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(Box::new(SnakeGame))
}</code></pre></pre>
<p>The TUI <code>State</code> trait mirrors the 3D engine's trait:</p>
<ul>
<li><code>initialize</code> — called once at startup</li>
<li><code>run_systems</code> — called every frame</li>
<li><code>on_keyboard_input</code> — key press/release events</li>
<li><code>next_state</code> — state transitions (title screen → gameplay → game over)</li>
</ul>
<p><code>launch</code> takes a <code>Box&lt;dyn State&gt;</code>, enters raw terminal mode, hides the cursor, enables mouse capture, and runs the game loop. On exit (or panic), it restores the terminal.</p>
<h2 id="step-2-the-tui-ecs"><a class="header" href="#step-2-the-tui-ecs">Step 2: The TUI ECS</a></h2>
<p>The TUI has its own ECS with components designed for character-cell rendering:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Position</code></td><td><code>POSITION</code></td><td>Column/row coordinates (f64 for sub-cell movement)</td></tr>
<tr><td><code>Velocity</code></td><td><code>VELOCITY</code></td><td>Column/row per tick (used by <code>movement_system</code>)</td></tr>
<tr><td><code>Sprite</code></td><td><code>SPRITE</code></td><td>Single character with foreground/background color</td></tr>
<tr><td><code>Label</code></td><td><code>LABEL</code></td><td>Multi-character text string</td></tr>
<tr><td><code>Tilemap</code></td><td><code>TILEMAP</code></td><td>Grid of characters for larger structures</td></tr>
<tr><td><code>Collider</code></td><td><code>COLLIDER</code></td><td>AABB collision box (width, height, layer, mask)</td></tr>
<tr><td><code>ZIndex</code></td><td><code>Z_INDEX</code></td><td>Render ordering (higher = on top)</td></tr>
<tr><td><code>Visibility</code></td><td><code>VISIBILITY</code></td><td>Show/hide toggle</td></tr>
<tr><td><code>Parent</code></td><td><code>PARENT</code></td><td>Parent entity reference</td></tr>
<tr><td><code>LocalOffset</code></td><td><code>LOCAL_OFFSET</code></td><td>Offset from parent position</td></tr>
<tr><td><code>Name</code></td><td><code>NAME</code></td><td>Entity name string</td></tr>
<tr><td><code>SpriteAnimation</code></td><td><code>SPRITE_ANIMATION</code></td><td>Frame-based character animation</td></tr>
</tbody></table>
</div>
<p>Resources are accessed through <code>world.resources</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td><code>terminal_size</code></td><td>Current terminal dimensions (columns, rows)</td></tr>
<tr><td><code>timing</code></td><td><code>delta_seconds</code>, <code>elapsed</code>, <code>frame_count</code>, <code>target_fps</code></td></tr>
<tr><td><code>keyboard</code></td><td><code>is_pressed()</code>, <code>is_just_pressed()</code>, <code>is_just_released()</code></td></tr>
<tr><td><code>mouse</code></td><td>Position, button states, scroll delta</td></tr>
<tr><td><code>camera</code></td><td>Viewport offset (offset_column, offset_row)</td></tr>
<tr><td><code>should_exit</code></td><td>Set to <code>true</code> to quit</td></tr>
</tbody></table>
</div>
<h2 id="step-3-game-state"><a class="header" href="#step-3-game-state">Step 3: Game State</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::tui::prelude::*;
use rand::Rng;

const BOARD_WIDTH: i32 = 40;
const BOARD_HEIGHT: i32 = 20;
const TICK_INTERVAL: f64 = 0.12;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

struct SnakeGame {
    segments: Vec&lt;(i32, i32)&gt;,
    direction: Direction,
    next_direction: Direction,
    food_position: (i32, i32),
    score: u32,
    game_over: bool,
    tick_timer: f64,
    board_offset_x: i32,
    board_offset_y: i32,
    segment_entities: Vec&lt;Entity&gt;,
    food_entity: Option&lt;Entity&gt;,
    wall_entities: Vec&lt;Entity&gt;,
    score_entities: Vec&lt;Entity&gt;,
}

impl SnakeGame {
    fn new() -&gt; Self {
        Self {
            segments: vec![(BOARD_WIDTH / 2, BOARD_HEIGHT / 2)],
            direction: Direction::Right,
            next_direction: Direction::Right,
            food_position: (0, 0),
            score: 0,
            game_over: false,
            tick_timer: 0.0,
            board_offset_x: 0,
            board_offset_y: 0,
            segment_entities: Vec::new(),
            food_entity: None,
            wall_entities: Vec::new(),
            score_entities: Vec::new(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The snake is a <code>Vec&lt;(i32, i32)&gt;</code> of grid positions. The head is <code>segments[0]</code>. Each frame the game logic ticks on a fixed interval — the tick timer accumulates <code>delta_seconds</code> and advances the snake when it exceeds <code>TICK_INTERVAL</code>.</p>
<h2 id="step-4-drawing-the-board"><a class="header" href="#step-4-drawing-the-board">Step 4: Drawing the Board</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SnakeGame {
    fn spawn_walls(&amp;mut self, world: &amp;mut World) {
        for column in 0..BOARD_WIDTH {
            self.spawn_wall_cell(world, column, 0, '=');
            self.spawn_wall_cell(world, column, BOARD_HEIGHT - 1, '=');
        }

        for row in 1..(BOARD_HEIGHT - 1) {
            self.spawn_wall_cell(world, 0, row, '|');
            self.spawn_wall_cell(world, BOARD_WIDTH - 1, row, '|');
        }
    }

    fn spawn_wall_cell(&amp;mut self, world: &amp;mut World, column: i32, row: i32, character: char) {
        let entity = world.spawn_entities(POSITION | SPRITE | Z_INDEX, 1)[0];
        world.set_position(entity, Position {
            column: (self.board_offset_x + column) as f64,
            row: (self.board_offset_y + row) as f64,
        });
        world.set_sprite(entity, Sprite {
            character,
            foreground: TermColor::Grey,
            background: TermColor::Black,
        });
        world.set_z_index(entity, ZIndex(1));
        self.wall_entities.push(entity);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Each wall cell is its own entity with a <code>Position</code>, <code>Sprite</code>, and <code>ZIndex</code>. The <code>Position</code> uses f64 coordinates — for grid-based games, cast to integer. The <code>ZIndex</code> determines draw order when entities overlap.</p>
<h2 id="step-5-spawning-the-snake-and-food"><a class="header" href="#step-5-spawning-the-snake-and-food">Step 5: Spawning the Snake and Food</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SnakeGame {
    fn spawn_food(&amp;mut self, world: &amp;mut World) {
        let mut rng = rand::rng();
        loop {
            let column = rng.random_range(1..(BOARD_WIDTH - 1));
            let row = rng.random_range(1..(BOARD_HEIGHT - 1));

            if !self.segments.contains(&amp;(column, row)) {
                self.food_position = (column, row);
                break;
            }
        }

        if let Some(entity) = self.food_entity {
            if let Some(position) = world.get_position_mut(entity) {
                position.column = (self.board_offset_x + self.food_position.0) as f64;
                position.row = (self.board_offset_y + self.food_position.1) as f64;
            }
        } else {
            let entity = world.spawn_entities(POSITION | SPRITE | Z_INDEX, 1)[0];
            world.set_position(entity, Position {
                column: (self.board_offset_x + self.food_position.0) as f64,
                row: (self.board_offset_y + self.food_position.1) as f64,
            });
            world.set_sprite(entity, Sprite {
                character: '*',
                foreground: TermColor::Red,
                background: TermColor::Black,
            });
            world.set_z_index(entity, ZIndex(2));
            self.food_entity = Some(entity);
        }
    }

    fn sync_snake_entities(&amp;mut self, world: &amp;mut World) {
        while self.segment_entities.len() &gt; self.segments.len() {
            let entity = self.segment_entities.pop().unwrap();
            world.despawn_entities(&amp;[entity]);
        }

        while self.segment_entities.len() &lt; self.segments.len() {
            let entity = world.spawn_entities(POSITION | SPRITE | Z_INDEX, 1)[0];
            world.set_z_index(entity, ZIndex(3));
            self.segment_entities.push(entity);
        }

        for (index, &amp;(column, row)) in self.segments.iter().enumerate() {
            let entity = self.segment_entities[index];
            world.set_position(entity, Position {
                column: (self.board_offset_x + column) as f64,
                row: (self.board_offset_y + row) as f64,
            });

            let (character, color) = if index == 0 {
                ('@', TermColor::Green)
            } else {
                ('o', TermColor::DarkGreen)
            };

            world.set_sprite(entity, Sprite {
                character,
                foreground: color,
                background: TermColor::Black,
            });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The snake head renders as <code>@</code> in bright green, body segments as <code>o</code> in dark green, and food as <code>*</code> in red. The entity list grows and shrinks to match the snake length — entities are spawned or despawned as needed.</p>
<h2 id="step-6-game-logic"><a class="header" href="#step-6-game-logic">Step 6: Game Logic</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SnakeGame {
    fn tick(&amp;mut self, world: &amp;mut World) {
        self.direction = self.next_direction;

        let (head_column, head_row) = self.segments[0];
        let (new_column, new_row) = match self.direction {
            Direction::Up =&gt; (head_column, head_row - 1),
            Direction::Down =&gt; (head_column, head_row + 1),
            Direction::Left =&gt; (head_column - 1, head_row),
            Direction::Right =&gt; (head_column + 1, head_row),
        };

        if new_column &lt;= 0
            || new_column &gt;= BOARD_WIDTH - 1
            || new_row &lt;= 0
            || new_row &gt;= BOARD_HEIGHT - 1
        {
            self.game_over = true;
            return;
        }

        if self.segments.contains(&amp;(new_column, new_row)) {
            self.game_over = true;
            return;
        }

        self.segments.insert(0, (new_column, new_row));

        if (new_column, new_row) == self.food_position {
            self.score += 1;
            self.spawn_food(world);
        } else {
            self.segments.pop();
        }

        self.sync_snake_entities(world);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Each tick: move the head one cell in the current direction, check for wall/self collision, and either grow (if eating food) or remove the tail. The <code>next_direction</code> buffer prevents reversing into yourself — it's set by input but only applied at tick time.</p>
<h2 id="step-7-input-handling"><a class="header" href="#step-7-input-handling">Step 7: Input Handling</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for SnakeGame {
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, pressed: bool) {
        if !pressed {
            return;
        }

        match key {
            KeyCode::Up | KeyCode::Char('w') =&gt; {
                if self.direction != Direction::Down {
                    self.next_direction = Direction::Up;
                }
            }
            KeyCode::Down | KeyCode::Char('s') =&gt; {
                if self.direction != Direction::Up {
                    self.next_direction = Direction::Down;
                }
            }
            KeyCode::Left | KeyCode::Char('a') =&gt; {
                if self.direction != Direction::Right {
                    self.next_direction = Direction::Left;
                }
            }
            KeyCode::Right | KeyCode::Char('d') =&gt; {
                if self.direction != Direction::Left {
                    self.next_direction = Direction::Right;
                }
            }
            KeyCode::Escape | KeyCode::Char('q') =&gt; {
                world.resources.should_exit = true;
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>TUI key events use <code>KeyCode::Char('w')</code> for letter keys and <code>KeyCode::Up</code> for arrow keys. The <code>pressed</code> parameter distinguishes press from release. Setting <code>world.resources.should_exit = true</code> cleanly exits the game loop and restores the terminal.</p>
<h2 id="step-8-score-display"><a class="header" href="#step-8-score-display">Step 8: Score Display</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SnakeGame {
    fn update_score_display(&amp;mut self, world: &amp;mut World) {
        for &amp;entity in &amp;self.score_entities {
            world.despawn_entities(&amp;[entity]);
        }
        self.score_entities.clear();

        let text = format!("Score: {}", self.score);
        let start_column = self.board_offset_x;
        let row = self.board_offset_y - 1;

        for (index, character) in text.chars().enumerate() {
            let entity = world.spawn_entities(POSITION | SPRITE | Z_INDEX, 1)[0];
            world.set_position(entity, Position {
                column: (start_column + index as i32) as f64,
                row: row as f64,
            });
            world.set_sprite(entity, Sprite {
                character,
                foreground: TermColor::White,
                background: TermColor::Black,
            });
            world.set_z_index(entity, ZIndex(10));
            self.score_entities.push(entity);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There's no built-in text rendering for the terminal — text is rendered character by character as individual <code>Sprite</code> entities. For text that changes every frame, despawn the old entities and spawn new ones. For static text, spawn once in <code>initialize</code>.</p>
<h2 id="step-9-putting-it-all-together"><a class="header" href="#step-9-putting-it-all-together">Step 9: Putting It All Together</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for SnakeGame {
    fn title(&amp;self) -&gt; &amp;str {
        "Snake"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.timing.target_fps = 60;

        let terminal = world.resources.terminal_size;
        self.board_offset_x = (terminal.columns as i32 - BOARD_WIDTH) / 2;
        self.board_offset_y = (terminal.rows as i32 - BOARD_HEIGHT) / 2;
        if self.board_offset_x &lt; 0 { self.board_offset_x = 0; }
        if self.board_offset_y &lt; 1 { self.board_offset_y = 1; }

        self.spawn_walls(world);
        self.spawn_food(world);
        self.sync_snake_entities(world);
        self.update_score_display(world);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        if self.game_over {
            return;
        }

        let delta = world.resources.timing.delta_seconds;
        self.tick_timer += delta;

        if self.tick_timer &gt;= TICK_INTERVAL {
            self.tick_timer -= TICK_INTERVAL;
            self.tick(world);
            self.update_score_display(world);
        }
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, pressed: bool) {
        // ... (from Step 7)
    }

    fn next_state(&amp;mut self, world: &amp;mut World) -&gt; Option&lt;Box&lt;dyn State&gt;&gt; {
        if self.game_over {
            let score = self.score;
            let all_entities: Vec&lt;Entity&gt; = world.query_entities(POSITION | SPRITE).collect();
            world.despawn_entities(&amp;all_entities);
            return Some(Box::new(GameOverState { score, restart: false }));
        }
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The board is centered in the terminal using <code>world.resources.terminal_size</code>. The game ticks on a fixed interval (<code>TICK_INTERVAL = 0.12</code> seconds, about 8 moves per second), while the render loop runs at 60 FPS for smooth input response.</p>
<h2 id="step-10-state-transitions"><a class="header" href="#step-10-state-transitions">Step 10: State Transitions</a></h2>
<p>The <code>next_state</code> method enables screen transitions. Return <code>Some(Box::new(...))</code> to switch states:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct GameOverState {
    score: u32,
    restart: bool,
}

impl State for GameOverState {
    fn title(&amp;self) -&gt; &amp;str {
        "Snake - Game Over"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.timing.target_fps = 30;

        let terminal = world.resources.terminal_size;
        let center_column = terminal.columns as i32 / 2;
        let center_row = terminal.rows as i32 / 2;

        let lines = [
            ("GAME OVER", TermColor::Red),
            ("", TermColor::Black),
            (&amp;format!("Score: {}", self.score), TermColor::White),
            ("", TermColor::Black),
            ("Press R to restart", TermColor::White),
            ("Press ESC to quit", TermColor::Grey),
        ];

        for (line_index, (text, color)) in lines.iter().enumerate() {
            if text.is_empty() { continue; }
            let start_col = center_column - text.len() as i32 / 2;
            for (char_index, character) in text.chars().enumerate() {
                let entity = world.spawn_entities(POSITION | SPRITE | Z_INDEX, 1)[0];
                world.set_position(entity, Position {
                    column: (start_col + char_index as i32) as f64,
                    row: (center_row - 3 + line_index as i32) as f64,
                });
                world.set_sprite(entity, Sprite {
                    character,
                    foreground: *color,
                    background: TermColor::Black,
                });
                world.set_z_index(entity, ZIndex(10));
            }
        }
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, pressed: bool) {
        if !pressed { return; }
        match key {
            KeyCode::Char('r') =&gt; self.restart = true,
            KeyCode::Escape | KeyCode::Char('q') =&gt; world.resources.should_exit = true,
            _ =&gt; {}
        }
    }

    fn next_state(&amp;mut self, world: &amp;mut World) -&gt; Option&lt;Box&lt;dyn State&gt;&gt; {
        if self.restart {
            let all_entities: Vec&lt;Entity&gt; = world.query_entities(POSITION | SPRITE).collect();
            world.despawn_entities(&amp;all_entities);
            return Some(Box::new(SnakeGame::new()));
        }
        None
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(Box::new(SnakeGame::new()))
}</code></pre></pre>
<p>When transitioning, despawn all entities from the current state before returning the new state. The engine calls <code>initialize</code> on the new state with a fresh world (but the same world instance — entities persist unless you remove them).</p>
<h2 id="available-colors"><a class="header" href="#available-colors">Available Colors</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TermColor {
    Black, DarkGrey, Red, DarkRed, Green, DarkGreen,
    Yellow, DarkYellow, Blue, DarkBlue, Magenta, DarkMagenta,
    Cyan, DarkCyan, White, Grey,
    Rgb { r: u8, g: u8, b: u8 },
}
<span class="boring">}</span></code></pre></pre>
<p>The 16 named colors work in all terminals. <code>Rgb</code> requires true-color terminal support (most modern terminals).</p>
<h2 id="built-in-systems-1"><a class="header" href="#built-in-systems-1">Built-In Systems</a></h2>
<p>The TUI framework provides these systems you can call in <code>run_systems</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Description</th></tr></thead><tbody>
<tr><td><code>movement_system(world)</code></td><td>Applies <code>Velocity</code> to <code>Position</code> each frame</td></tr>
<tr><td><code>collision_pairs(world)</code></td><td>Returns <code>Vec&lt;Contact&gt;</code> for all overlapping <code>Collider</code> pairs</td></tr>
<tr><td><code>resolve_collision(world, &amp;contact)</code></td><td>Pushes both entities apart equally</td></tr>
<tr><td><code>resolve_collision_static(world, &amp;contact, static_entity)</code></td><td>Pushes only the non-static entity</td></tr>
<tr><td><code>parent_transform_system(world)</code></td><td>Updates child positions from <code>Parent</code> + <code>LocalOffset</code></td></tr>
<tr><td><code>cascade_despawn(world, entity)</code></td><td>Despawns entity and all its children</td></tr>
</tbody></table>
</div>
<h2 id="key-differences-from-3d-engine"><a class="header" href="#key-differences-from-3d-engine">Key Differences from 3D Engine</a></h2>
<div class="table-wrapper"><table><thead><tr><th>3D Engine</th><th>TUI Framework</th></tr></thead><tbody>
<tr><td><code>nightshade::prelude::*</code></td><td><code>nightshade::tui::prelude::*</code></td></tr>
<tr><td><code>launch(state)</code></td><td><code>launch(Box::new(state))</code></td></tr>
<tr><td><code>world.resources.window.timing.delta_time</code></td><td><code>world.resources.timing.delta_seconds</code></td></tr>
<tr><td><code>KeyCode::KeyW</code></td><td><code>KeyCode::Char('w')</code></td></tr>
<tr><td><code>KeyState</code> (Pressed/Released)</td><td><code>bool</code> (pressed)</td></tr>
<tr><td><code>LocalTransform</code> (Vec3 position)</td><td><code>Position</code> (column/row f64)</td></tr>
<tr><td>3D meshes + materials</td><td><code>Sprite</code> (char + colors)</td></tr>
<tr><td><code>mark_local_transform_dirty()</code></td><td>Not needed — positions take effect immediately</td></tr>
</tbody></table>
</div>
<h2 id="where-to-go-next-1"><a class="header" href="#where-to-go-next-1">Where to Go Next</a></h2>
<p>The TUI framework supports much more than Snake:</p>
<ul>
<li><strong>Tilemaps</strong>: Use <code>Tilemap</code> for efficient grid rendering (roguelikes, RPGs)</li>
<li><strong>Sprite Animation</strong>: Use <code>SpriteAnimation</code> with a list of frame characters</li>
<li><strong>Collision Detection</strong>: Use <code>Collider</code> with layers and masks for selective collision</li>
<li><strong>Mouse Input</strong>: Handle clicks and movement with <code>on_mouse_input</code> and <code>on_mouse_move</code></li>
<li><strong>Camera Scrolling</strong>: Set <code>world.resources.camera.offset_column/row</code> for viewport scrolling</li>
</ul>
<p>See the 40+ terminal examples in the <code>nightshade-examples</code> repository for complete implementations of roguelikes, platformers, puzzle games, strategy games, and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h1>
<p>The simplest possible Nightshade application.</p>
<h2 id="complete-code"><a class="header" href="#complete-code">Complete Code</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct MinimalGame;

impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
        world.resources.active_camera = Some(camera);

        spawn_cube_at(world, Vec3::new(0.0, 0.0, -5.0));

        spawn_sun(world);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        fly_camera_system(world);
    }
}

fn main() {
    nightshade::launch(MinimalGame);
}</code></pre></pre>
<h2 id="step-by-step-breakdown"><a class="header" href="#step-by-step-breakdown">Step-by-Step Breakdown</a></h2>
<h3 id="1-import-the-prelude"><a class="header" href="#1-import-the-prelude">1. Import the Prelude</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>The prelude exports all commonly used types:</p>
<ul>
<li><code>State</code> trait</li>
<li><code>World</code> struct</li>
<li><code>Entity</code> type</li>
<li>Math types (<code>Vec3</code>, <code>Vec4</code>, <code>Mat4</code>, etc.)</li>
<li>Component flags (<code>LOCAL_TRANSFORM</code>, <code>RENDER_MESH</code>, etc.)</li>
<li>Common functions (<code>spawn_cube_at</code>, <code>spawn_camera</code>, etc.)</li>
</ul>
<h3 id="2-define-your-game-state"><a class="header" href="#2-define-your-game-state">2. Define Your Game State</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame;
<span class="boring">}</span></code></pre></pre>
<p>Your game state struct holds all game-specific data. It can be empty for simple demos or contain complex game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame {
    score: u32,
    player: Option&lt;Entity&gt;,
    enemies: Vec&lt;Entity&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-implement-the-state-trait"><a class="header" href="#3-implement-the-state-trait">3. Implement the State Trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Called once at startup
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>State</code> trait has many optional methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>initialize</code></td><td>Setup at startup</td></tr>
<tr><td><code>run_systems</code></td><td>Game logic each frame</td></tr>
<tr><td><code>ui</code></td><td>egui-based UI</td></tr>
<tr><td><code>immediate_ui</code></td><td>Built-in immediate mode UI</td></tr>
<tr><td><code>on_keyboard_input</code></td><td>Key press/release</td></tr>
<tr><td><code>on_mouse_input</code></td><td>Mouse button events</td></tr>
<tr><td><code>on_gamepad_event</code></td><td>Gamepad input</td></tr>
<tr><td><code>configure_render_graph</code></td><td>Custom rendering</td></tr>
<tr><td><code>next_state</code></td><td>State transitions</td></tr>
</tbody></table>
</div>
<h3 id="4-set-up-the-scene"><a class="header" href="#4-set-up-the-scene">4. Set Up the Scene</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    spawn_cube_at(world, Vec3::new(0.0, 0.0, -5.0));

    spawn_sun(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-run-the-application"><a class="header" href="#5-run-the-application">5. Run the Application</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    nightshade::launch(MinimalGame);
}</code></pre></pre>
<p>The <code>launch</code> function:</p>
<ol>
<li>Creates the window</li>
<li>Initializes the renderer</li>
<li>Calls <code>initialize</code> on your state</li>
<li>Runs the game loop</li>
<li>Handles input events</li>
<li>Calls <code>run_systems</code> each frame</li>
</ol>
<h2 id="adding-cargotoml"><a class="header" href="#adding-cargotoml">Adding Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "minimal-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/user/nightshade", features = ["engine", "wgpu"] }
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>Release mode is recommended for better performance.</p>
<h2 id="controls-2"><a class="header" href="#controls-2">Controls</a></h2>
<p>The fly camera uses standard controls:</p>
<ul>
<li><strong>WASD</strong> - Move horizontally</li>
<li><strong>Space/Shift</strong> - Move up/down</li>
<li><strong>Mouse</strong> - Look around</li>
<li><strong>Escape</strong> - Release cursor</li>
</ul>
<h2 id="extending-the-example"><a class="header" href="#extending-the-example">Extending the Example</a></h2>
<h3 id="add-more-objects"><a class="header" href="#add-more-objects">Add More Objects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    spawn_plane_at(world, Vec3::zeros());

    for index in 0..5 {
        spawn_cube_at(world, Vec3::new(index as f32 * 2.0 - 4.0, 0.5, -5.0));
    }

    spawn_sun(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-animation"><a class="header" href="#add-animation">Add Animation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame {
    cube: Option&lt;Entity&gt;,
    time: f32,
}

impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
        world.resources.active_camera = Some(camera);

        self.cube = Some(spawn_cube_at(world, Vec3::new(0.0, 0.0, -5.0)));

        spawn_sun(world);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;
        self.time += dt;

        if let Some(cube) = self.cube {
            if let Some(transform) = world.get_local_transform_mut(cube) {
                transform.rotation = nalgebra_glm::quat_angle_axis(
                    self.time,
                    &amp;Vec3::y(),
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-input-handling"><a class="header" href="#add-input-handling">Add Input Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MinimalGame {
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: ElementState) {
        if state == ElementState::Pressed {
            match key {
                KeyCode::Escape =&gt; std::process::exit(0),
                KeyCode::Space =&gt; self.spawn_cube(world),
                _ =&gt; {}
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>From this foundation, you can:</p>
<ul>
<li>Add physics with rigid bodies and colliders</li>
<li>Load 3D models with <code>load_gltf</code></li>
<li>Add skeletal animation</li>
<li>Implement game logic in <code>run_systems</code></li>
<li>Create UI with egui</li>
<li>Add audio with Kira</li>
</ul>
<p>See the other examples for complete implementations of these features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-game"><a class="header" href="#first-person-game">First Person Game</a></h1>
<p>A complete first-person shooter/exploration template with physics, audio, and weapons.</p>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct FirstPersonGame {
    player: Option&lt;Entity&gt;,
    weapon: Option&lt;Entity&gt;,
    health: f32,
    ammo: u32,
    score: u32,
    footstep_timer: f32,
}

impl Default for FirstPersonGame {
    fn default() -&gt; Self {
        Self {
            player: None,
            weapon: None,
            health: 100.0,
            ammo: 30,
            score: 0,
            footstep_timer: 0.0,
        }
    }
}

impl State for FirstPersonGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.setup_player(world);
        self.setup_level(world);
        self.setup_lighting(world);
        self.setup_ui(world);
        self.setup_audio(world);

        world.resources.graphics.show_cursor = false;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;

        self.update_player_movement(world, dt);
        self.update_weapon_sway(world, dt);
        self.update_footsteps(world, dt);
        self.update_ui(world);

        run_physics_systems(world);
        sync_transforms_from_physics_system(world);
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: ElementState) {
        if state == ElementState::Pressed {
            match key {
                KeyCode::Escape =&gt; self.toggle_pause(world),
                KeyCode::KeyR =&gt; self.reload_weapon(),
                _ =&gt; {}
            }
        }
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
        if button == MouseButton::Left &amp;&amp; state == ElementState::Pressed {
            self.fire_weapon(world);
        }
    }
}

impl FirstPersonGame {
    fn setup_player(&amp;mut self, world: &amp;mut World) {
        let player = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM |
            CHARACTER_CONTROLLER | COLLIDER |
            AUDIO_LISTENER,
            1
        )[0];

        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, 1.8, 0.0),
            ..Default::default()
        });

        world.set_character_controller(player, CharacterControllerComponent {
            max_speed: 5.0,
            acceleration: 20.0,
            jump_impulse: 7.0,
            can_jump: true,
            is_crouching: false,
            is_sprinting: false,
            grounded: false,
            velocity: Vec3::zeros(),
            ..Default::default()
        });

        world.set_collider(player, ColliderComponent::capsule(0.3, 1.2));

        let camera = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PARENT,
            1
        )[0];

        world.set_local_transform(camera, LocalTransform {
            translation: Vec3::new(0.0, 0.7, 0.0),
            ..Default::default()
        });

        world.set_camera(camera, Camera {
            projection: Projection::Perspective(PerspectiveCamera {
                y_fov_rad: 75.0_f32.to_radians(),
                z_near: 0.1,
                z_far: Some(1000.0),
                aspect_ratio: None,
            }),
            smoothing: None,
        });

        world.set_parent(camera, Parent(Some(player)));
        world.resources.active_camera = Some(camera);

        self.setup_weapon(world, camera);
        self.player = Some(player);
    }

    fn setup_weapon(&amp;mut self, world: &amp;mut World, camera: Entity) {
        let weapon = load_gltf(world, "assets/models/pistol.glb")[0];

        world.set_local_transform(weapon, LocalTransform {
            translation: Vec3::new(0.3, -0.2, -0.5),
            rotation: nalgebra_glm::quat_angle_axis(
                std::f32::consts::PI,
                &amp;Vec3::y(),
            ),
            scale: Vec3::new(0.1, 0.1, 0.1),
        });

        world.set_parent(weapon, Parent(Some(camera)));
        self.weapon = Some(weapon);
    }

    fn setup_level(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_plane_at(world, Vec3::zeros());
        set_material_with_textures(world, floor, Material {
            base_color: [0.3, 0.3, 0.3, 1.0],
            roughness: 0.9,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Cuboid {
            half_extents: Vec3::new(50.0, 0.1, 50.0),
        });

        for index in 0..10 {
            let wall = spawn_cube_at(world, Vec3::zeros());
            let angle = index as f32 * std::f32::consts::TAU / 10.0;
            let distance = 20.0;

            world.set_local_transform(wall, LocalTransform {
                translation: Vec3::new(
                    angle.cos() * distance,
                    2.0,
                    angle.sin() * distance,
                ),
                scale: Vec3::new(5.0, 4.0, 0.5),
                rotation: nalgebra_glm::quat_angle_axis(angle, &amp;Vec3::y()),
            });

            add_collider(world, wall, ColliderShape::Cuboid {
                half_extents: Vec3::new(5.0, 4.0, 0.5),
            });
        }

        for index in 0..5 {
            let crate_entity = spawn_cube_at(world, Vec3::zeros());
            world.set_local_transform(crate_entity, LocalTransform {
                translation: Vec3::new(
                    (index as f32 - 2.0) * 3.0,
                    0.5,
                    -10.0,
                ),
                ..Default::default()
            });
            set_material_with_textures(world, crate_entity, Material {
                base_color: [0.6, 0.4, 0.2, 1.0],
                roughness: 0.8,
                ..Default::default()
            });

            add_rigid_body(world, crate_entity, RigidBodyType::Dynamic, 10.0);
            add_collider(world, crate_entity, ColliderShape::Cuboid {
                half_extents: Vec3::new(0.5, 0.5, 0.5),
            });
        }
    }

    fn setup_lighting(&amp;mut self, world: &amp;mut World) {
        spawn_sun(world);

        world.resources.graphics.ambient_light = [0.1, 0.1, 0.1, 1.0];
    }

    fn setup_ui(&amp;mut self, world: &amp;mut World) {
        spawn_hud_text(
            world,
            &amp;format!("Health: {}", self.health as u32),
            HudAnchor::BottomLeft,
            Vec2::new(20.0, -30.0),
        );

        spawn_hud_text(
            world,
            &amp;format!("Ammo: {}", self.ammo),
            HudAnchor::BottomRight,
            Vec2::new(-20.0, -30.0),
        );

        let crosshair = spawn_hud_text(
            world,
            "+",
            HudAnchor::Center,
            Vec2::zeros(),
        );

        if let Some(hud_text) = world.get_hud_text_mut(crosshair) {
            hud_text.properties.font_size = 24.0;
            hud_text.properties.color = [1.0, 1.0, 1.0, 0.8];
        }
    }

    fn setup_audio(&amp;mut self, world: &amp;mut World) {
        load_sound(world, "footstep", "assets/audio/footstep.wav");
        load_sound(world, "gunshot", "assets/audio/gunshot.wav");
        load_sound(world, "reload", "assets/audio/reload.wav");
    }

    fn update_player_movement(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;
        let position_delta = world.resources.input.mouse.position_delta;

        let mut move_input = Vec3::zeros();
        if keyboard.is_key_pressed(KeyCode::KeyW) { move_input.z -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyS) { move_input.z += 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyA) { move_input.x -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyD) { move_input.x += 1.0; }

        if move_input.magnitude() &gt; 0.0 {
            move_input = move_input.normalize();
        }

        let sprint = keyboard.is_key_pressed(KeyCode::ShiftLeft);
        let speed = if sprint { 8.0 } else { 5.0 };

        if let Some(controller) = world.get_character_controller_mut(player) {
            if let Some(transform) = world.get_local_transform(player) {
                let forward = transform.rotation * Vec3::new(0.0, 0.0, -1.0);
                let right = transform.rotation * Vec3::new(1.0, 0.0, 0.0);

                let forward_flat = Vec3::new(forward.x, 0.0, forward.z).normalize();
                let right_flat = Vec3::new(right.x, 0.0, right.z).normalize();

                let world_move = forward_flat * -move_input.z + right_flat * move_input.x;
                controller.velocity.x = world_move.x * speed;
                controller.velocity.z = world_move.z * speed;

                if keyboard.is_key_pressed(KeyCode::Space) &amp;&amp; controller.grounded {
                    controller.velocity.y = controller.jump_impulse;
                }
            }
        }

        if let Some(transform) = world.get_local_transform_mut(player) {
            let sensitivity = 0.002;
            let yaw = nalgebra_glm::quat_angle_axis(
                -position_delta.x * sensitivity,
                &amp;Vec3::y(),
            );
            transform.rotation = yaw * transform.rotation;
        }

        if let Some(camera) = world.resources.active_camera {
            if let Some(transform) = world.get_local_transform_mut(camera) {
                let sensitivity = 0.002;
                let pitch = nalgebra_glm::quat_angle_axis(
                    -position_delta.y * sensitivity,
                    &amp;Vec3::x(),
                );
                transform.rotation = transform.rotation * pitch;
            }
        }
    }

    fn update_weapon_sway(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(weapon) = self.weapon else { return };

        let position_delta = world.resources.input.mouse.position_delta;

        if let Some(transform) = world.get_local_transform_mut(weapon) {
            let target_x = 0.3 - position_delta.x * 0.001;
            let target_y = -0.2 - position_delta.y * 0.001;

            transform.translation.x += (target_x - transform.translation.x) * dt * 10.0;
            transform.translation.y += (target_y - transform.translation.y) * dt * 10.0;
        }
    }

    fn update_footsteps(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;
        let moving = keyboard.is_key_pressed(KeyCode::KeyW) ||
                     keyboard.is_key_pressed(KeyCode::KeyS) ||
                     keyboard.is_key_pressed(KeyCode::KeyA) ||
                     keyboard.is_key_pressed(KeyCode::KeyD);

        if let Some(controller) = world.get_character_controller(player) {
            if moving &amp;&amp; controller.grounded {
                self.footstep_timer -= dt;
                if self.footstep_timer &lt;= 0.0 {
                    play_sound(world, "footstep");
                    self.footstep_timer = 0.4;
                }
            }
        }
    }

    fn update_ui(&amp;mut self, world: &amp;mut World) {
    }

    fn fire_weapon(&amp;mut self, world: &amp;mut World) {
        if self.ammo == 0 {
            return;
        }

        self.ammo -= 1;
        play_sound(world, "gunshot");

        if let Some(camera) = world.resources.active_camera {
            if let Some(transform) = world.get_global_transform(camera) {
                let origin = transform.translation();
                let direction = transform.forward_vector();

                if let Some(hit) = raycast(world, origin, direction, 100.0) {
                    if let Some(body) = world.get_rigid_body_mut(hit.entity) {
                        if body.body_type == RigidBodyType::Dynamic {
                            body.linvel = [
                                body.linvel[0] + direction.x * 10.0,
                                body.linvel[1] + direction.y * 10.0,
                                body.linvel[2] + direction.z * 10.0,
                            ];
                        }
                    }

                    self.spawn_impact_effect(world, hit.position, hit.normal);
                }
            }
        }
    }

    fn spawn_impact_effect(&amp;self, world: &amp;mut World, position: Vec3, normal: Vec3) {
        let sparks = world.spawn_entities(PARTICLE_EMITTER, 1)[0];

        world.set_particle_emitter(sparks, ParticleEmitter {
            emitter_type: EmitterType::Sparks,
            shape: EmitterShape::Point,
            position,
            direction: normal,
            spawn_rate: 0.0,
            burst_count: 20,
            particle_lifetime_min: 0.1,
            particle_lifetime_max: 0.3,
            initial_velocity_min: 3.0,
            initial_velocity_max: 8.0,
            velocity_spread: 0.5,
            gravity: Vec3::new(0.0, -10.0, 0.0),
            size_start: 0.02,
            size_end: 0.01,
            emissive_strength: 10.0,
            enabled: true,
            ..Default::default()
        });
    }

    fn reload_weapon(&amp;mut self) {
        self.ammo = 30;
    }

    fn toggle_pause(&amp;mut self, world: &amp;mut World) {
        world.resources.graphics.show_cursor = !world.resources.graphics.show_cursor;
    }
}

fn main() {
    nightshade::launch(FirstPersonGame::default());
}</code></pre></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="character-controller"><a class="header" href="#character-controller">Character Controller</a></h3>
<p>The character controller handles physics-based movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CharacterControllerComponent {
    max_speed: 5.0,
    acceleration: 20.0,
    jump_impulse: 7.0,
    can_jump: true,
    is_crouching: false,
    is_sprinting: false,
    grounded: false,
    velocity: Vec3::zeros(),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="camera-setup"><a class="header" href="#camera-setup">Camera Setup</a></h3>
<p>First-person camera is parented to the player:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(camera, Parent(Some(player)));
<span class="boring">}</span></code></pre></pre>
<p>This makes the camera follow the player automatically.</p>
<h3 id="weapon-attachment"><a class="header" href="#weapon-attachment">Weapon Attachment</a></h3>
<p>The weapon is parented to the camera so it stays in view:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(weapon, Parent(Some(camera)));
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-look"><a class="header" href="#mouse-look">Mouse Look</a></h3>
<p>Horizontal rotation (yaw) goes on the player body, vertical rotation (pitch) goes on the camera:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Yaw on player
transform.rotation = yaw * transform.rotation;

// Pitch on camera
transform.rotation = transform.rotation * pitch;
<span class="boring">}</span></code></pre></pre>
<p>This prevents gimbal lock and feels natural.</p>
<h2 id="cargotoml-2"><a class="header" href="#cargotoml-2">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "fps-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "wgpu", "physics", "audio"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-person-game"><a class="header" href="#third-person-game">Third Person Game</a></h1>
<p>A complete third-person action game template with character animation, combat, and camera control.</p>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct ThirdPersonGame {
    player: Option&lt;Entity&gt;,
    camera: Option&lt;Entity&gt;,
    camera_target: Vec3,
    camera_distance: f32,
    camera_pitch: f32,
    camera_yaw: f32,

    player_state: PlayerState,
    attack_timer: f32,
    dodge_timer: f32,
    health: f32,
}

#[derive(Default, PartialEq)]
enum PlayerState {
    #[default]
    Idle,
    Walking,
    Running,
    Attacking,
    Dodging,
}

impl Default for ThirdPersonGame {
    fn default() -&gt; Self {
        Self {
            player: None,
            camera: None,
            camera_target: Vec3::zeros(),
            camera_distance: 5.0,
            camera_pitch: 0.3,
            camera_yaw: 0.0,
            player_state: PlayerState::Idle,
            attack_timer: 0.0,
            dodge_timer: 0.0,
            health: 100.0,
        }
    }
}

impl State for ThirdPersonGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.setup_player(world);
        self.setup_camera(world);
        self.setup_level(world);
        self.setup_lighting(world);
        self.setup_enemies(world);

        world.resources.graphics.show_cursor = false;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;

        self.update_camera_input(world);
        self.update_player_movement(world, dt);
        self.update_player_state(world, dt);
        self.update_camera_position(world, dt);
        self.update_animations(world);

        run_physics_systems(world);
        sync_transforms_from_physics_system(world);
        update_animation_players(world, dt);
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
        if state == ElementState::Pressed {
            match button {
                MouseButton::Left =&gt; self.attack(world),
                MouseButton::Right =&gt; self.dodge(world),
                _ =&gt; {}
            }
        }
    }
}

impl ThirdPersonGame {
    fn setup_player(&amp;mut self, world: &amp;mut World) {
        let entities = load_gltf(world, "assets/models/character.glb");
        let player = entities[0];

        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, 0.0, 0.0),
            scale: Vec3::new(1.0, 1.0, 1.0),
            ..Default::default()
        });

        let controller_entity = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CHARACTER_CONTROLLER | COLLIDER,
            1
        )[0];

        world.set_character_controller(controller_entity, CharacterControllerComponent {
            max_speed: 4.0,
            acceleration: 20.0,
            jump_impulse: 8.0,
            can_jump: true,
            is_crouching: false,
            is_sprinting: false,
            grounded: false,
            velocity: Vec3::zeros(),
            ..Default::default()
        });

        world.set_collider(controller_entity, ColliderComponent::capsule(0.4, 1.2));

        world.set_parent(player, Parent(Some(controller_entity)));
        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, -0.9, 0.0),
            ..Default::default()
        });

        if let Some(animation_player) = world.get_animation_player_mut(player) {
            animation_player.play("idle");
            animation_player.set_looping(true);
        }

        self.player = Some(controller_entity);
    }

    fn setup_camera(&amp;mut self, world: &amp;mut World) {
        let camera = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA,
            1
        )[0];

        world.set_camera(camera, Camera {
            projection: Projection::Perspective(PerspectiveCamera {
                y_fov_rad: 60.0_f32.to_radians(),
                z_near: 0.1,
                z_far: Some(1000.0),
                aspect_ratio: None,
            }),
            smoothing: None,
        });

        world.resources.active_camera = Some(camera);
        self.camera = Some(camera);
    }

    fn setup_level(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_plane_at(world, Vec3::zeros());
        set_material_with_textures(world, floor, Material {
            base_color: [0.2, 0.5, 0.2, 1.0],
            roughness: 0.9,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Cuboid {
            half_extents: Vec3::new(100.0, 0.1, 100.0),
        });

        for index in 0..20 {
            let rock = spawn_sphere_at(world, Vec3::zeros());
            let x = (index % 5) as f32 * 15.0 - 30.0 + rand_range(-2.0, 2.0);
            let z = (index / 5) as f32 * 15.0 - 30.0 + rand_range(-2.0, 2.0);
            let scale = rand_range(0.5, 2.0);

            world.set_local_transform(rock, LocalTransform {
                translation: Vec3::new(x, scale * 0.5, z),
                scale: Vec3::new(scale, scale, scale),
                ..Default::default()
            });

            set_material_with_textures(world, rock, Material {
                base_color: [0.4, 0.4, 0.4, 1.0],
                roughness: 0.95,
                ..Default::default()
            });

            add_collider(world, rock, ColliderShape::Ball { radius: scale });
        }
    }

    fn setup_lighting(&amp;mut self, world: &amp;mut World) {
        spawn_sun(world);

        world.resources.graphics.ambient_light = [0.2, 0.2, 0.2, 1.0];
    }

    fn setup_enemies(&amp;mut self, world: &amp;mut World) {
        for index in 0..5 {
            let angle = index as f32 * std::f32::consts::TAU / 5.0;
            let distance = 15.0;

            let enemy = load_gltf(world, "assets/models/enemy.glb")[0];
            world.set_local_transform(enemy, LocalTransform {
                translation: Vec3::new(
                    angle.cos() * distance,
                    0.0,
                    angle.sin() * distance,
                ),
                ..Default::default()
            });
        }
    }

    fn update_camera_input(&amp;mut self, world: &amp;mut World) {
        let position_delta = world.resources.input.mouse.position_delta;
        let scroll = world.resources.input.mouse.wheel_delta;

        let sensitivity = 0.003;
        self.camera_yaw -= position_delta.x * sensitivity;
        self.camera_pitch -= position_delta.y * sensitivity;

        self.camera_pitch = self.camera_pitch.clamp(-1.2, 1.2);

        self.camera_distance -= scroll.y * 0.5;
        self.camera_distance = self.camera_distance.clamp(2.0, 15.0);
    }

    fn update_player_movement(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;

        let mut move_input = Vec2::zeros();
        if keyboard.is_key_pressed(KeyCode::KeyW) { move_input.y -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyS) { move_input.y += 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyA) { move_input.x -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyD) { move_input.x += 1.0; }

        let running = keyboard.is_key_pressed(KeyCode::ShiftLeft);

        if move_input.magnitude() &gt; 0.0 {
            move_input = move_input.normalize();

            let camera_forward = Vec3::new(
                self.camera_yaw.sin(),
                0.0,
                self.camera_yaw.cos(),
            );
            let camera_right = Vec3::new(
                self.camera_yaw.cos(),
                0.0,
                -self.camera_yaw.sin(),
            );

            let world_direction = camera_forward * -move_input.y + camera_right * move_input.x;

            if let Some(transform) = world.get_local_transform_mut(player) {
                let target_rotation = nalgebra_glm::quat_angle_axis(
                    world_direction.x.atan2(world_direction.z),
                    &amp;Vec3::y(),
                );
                transform.rotation = nalgebra_glm::quat_slerp(
                    &amp;transform.rotation,
                    &amp;target_rotation,
                    dt * 10.0,
                );
            }

            let speed = if running { 8.0 } else { 4.0 };
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = world_direction.x * speed;
                controller.velocity.z = world_direction.z * speed;
            }

            self.player_state = if running { PlayerState::Running } else { PlayerState::Walking };
        } else {
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = 0.0;
                controller.velocity.z = 0.0;
            }
            self.player_state = PlayerState::Idle;
        }

        if keyboard.is_key_pressed(KeyCode::Space) {
            if let Some(controller) = world.get_character_controller_mut(player) {
                if controller.grounded {
                    controller.velocity.y = controller.jump_impulse;
                }
            }
        }
    }

    fn update_player_state(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.attack_timer &gt; 0.0 {
            self.attack_timer -= dt;
            if self.attack_timer &lt;= 0.0 {
                self.player_state = PlayerState::Idle;
            }
        }

        if self.dodge_timer &gt; 0.0 {
            self.dodge_timer -= dt;
            if self.dodge_timer &lt;= 0.0 {
                self.player_state = PlayerState::Idle;
            }
        }
    }

    fn update_camera_position(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };
        let Some(camera) = self.camera else { return };

        if let Some(player_transform) = world.get_global_transform(player) {
            let target = player_transform.translation() + Vec3::new(0.0, 1.5, 0.0);
            self.camera_target = nalgebra_glm::lerp(
                &amp;self.camera_target,
                &amp;target,
                dt * 8.0,
            );
        }

        let offset = Vec3::new(
            self.camera_yaw.sin() * self.camera_pitch.cos(),
            self.camera_pitch.sin(),
            self.camera_yaw.cos() * self.camera_pitch.cos(),
        ) * self.camera_distance;

        let camera_position = self.camera_target + offset;

        if let Some(transform) = world.get_local_transform_mut(camera) {
            transform.translation = camera_position;

            let direction = (self.camera_target - camera_position).normalize();
            let pitch = (-direction.y).asin();
            let yaw = direction.x.atan2(direction.z);

            transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
                * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
        }
    }

    fn update_animations(&amp;mut self, world: &amp;mut World) {
        let Some(player) = self.player else { return };

        let children = world.resources.children_cache.get(&amp;player).cloned().unwrap_or_default();
        for child in children {
            if let Some(animation_player) = world.get_animation_player_mut(child) {
                let animation_name = match self.player_state {
                    PlayerState::Idle =&gt; "idle",
                    PlayerState::Walking =&gt; "walk",
                    PlayerState::Running =&gt; "run",
                    PlayerState::Attacking =&gt; "attack",
                    PlayerState::Dodging =&gt; "dodge",
                };

                if animation_player.current_animation() != Some(animation_name) {
                    animation_player.blend_to(animation_name, 0.2);
                }
            }
        }
    }

    fn attack(&amp;mut self, world: &amp;mut World) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        self.player_state = PlayerState::Attacking;
        self.attack_timer = 0.6;

        self.check_attack_hits(world);
    }

    fn check_attack_hits(&amp;self, world: &amp;mut World) {
        let Some(player) = self.player else { return };

        if let Some(transform) = world.get_global_transform(player) {
            let attack_origin = transform.translation() + Vec3::new(0.0, 1.0, 0.0);
            let forward = transform.forward_vector();
            let attack_range = 2.0;

            for entity in world.query_entities(GLOBAL_TRANSFORM) {
                if entity == player { continue; }

                if let Some(target_transform) = world.get_global_transform(entity) {
                    let to_target = target_transform.translation() - attack_origin;
                    let distance = to_target.magnitude();
                    let dot = forward.dot(&amp;to_target.normalize());

                    if distance &lt; attack_range &amp;&amp; dot &gt; 0.5 {
                        self.apply_damage(world, entity, 25.0);
                    }
                }
            }
        }
    }

    fn apply_damage(&amp;self, world: &amp;mut World, entity: Entity, damage: f32) {
    }

    fn dodge(&amp;mut self, world: &amp;mut World) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        let Some(player) = self.player else { return };

        self.player_state = PlayerState::Dodging;
        self.dodge_timer = 0.5;

        if let Some(transform) = world.get_local_transform(player) {
            let forward = transform.rotation * Vec3::new(0.0, 0.0, -1.0);
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = forward.x * 12.0;
                controller.velocity.z = forward.z * 12.0;
            }
        }
    }
}

fn rand_range(min: f32, max: f32) -&gt; f32 {
    min + (max - min) * 0.5
}

fn main() {
    nightshade::launch(ThirdPersonGame::default());
}</code></pre></pre>
<h2 id="key-systems"><a class="header" href="#key-systems">Key Systems</a></h2>
<h3 id="orbit-camera"><a class="header" href="#orbit-camera">Orbit Camera</a></h3>
<p>The camera orbits around the player using spherical coordinates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let offset = Vec3::new(
    self.camera_yaw.sin() * self.camera_pitch.cos(),
    self.camera_pitch.sin(),
    self.camera_yaw.cos() * self.camera_pitch.cos(),
) * self.camera_distance;
<span class="boring">}</span></code></pre></pre>
<p>Mouse X controls yaw, mouse Y controls pitch, scroll controls distance.</p>
<h3 id="camera-relative-movement"><a class="header" href="#camera-relative-movement">Camera-Relative Movement</a></h3>
<p>Player moves relative to where the camera is looking:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera_forward = Vec3::new(
    self.camera_yaw.sin(),
    0.0,
    self.camera_yaw.cos(),
);

let world_direction = camera_forward * -move_input.y + camera_right * move_input.x;
<span class="boring">}</span></code></pre></pre>
<h3 id="character-rotation"><a class="header" href="#character-rotation">Character Rotation</a></h3>
<p>The character smoothly rotates to face movement direction:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>transform.rotation = nalgebra_glm::quat_slerp(
    &amp;transform.rotation,
    &amp;target_rotation,
    dt * 10.0,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-blending"><a class="header" href="#animation-blending">Animation Blending</a></h3>
<p>Animations blend smoothly when state changes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>animation_player.blend_to(animation_name, 0.2);  // 0.2 second blend
<span class="boring">}</span></code></pre></pre>
<h3 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h3>
<p>Simple state machine prevents conflicting actions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.player_state == PlayerState::Attacking ||
   self.player_state == PlayerState::Dodging {
    return;  // Can't move while attacking/dodging
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cargotoml-3"><a class="header" href="#cargotoml-3">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "third-person-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "wgpu", "physics"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-playground"><a class="header" href="#physics-playground">Physics Playground</a></h1>
<blockquote>
<p><strong>Live Demo:</strong> <a href="https://matthewberger.dev/nightshade/physics">Physics</a></p>
</blockquote>
<p>An interactive physics sandbox demonstrating rigid bodies, colliders, joints, and forces.</p>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct PhysicsPlayground {
    spawn_mode: SpawnMode,
    selected_entity: Option&lt;Entity&gt;,
    holding_entity: Option&lt;Entity&gt;,
    grab_distance: f32,
}

#[derive(Default, Clone, Copy)]
enum SpawnMode {
    #[default]
    Cube,
    Sphere,
    Cylinder,
    Chain,
    Ragdoll,
}

impl Default for PhysicsPlayground {
    fn default() -&gt; Self {
        Self {
            spawn_mode: SpawnMode::Cube,
            selected_entity: None,
            holding_entity: None,
            grab_distance: 5.0,
        }
    }
}

impl State for PhysicsPlayground {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
        world.resources.active_camera = Some(camera);
        self.setup_environment(world);
        self.setup_ui(world);

        world.resources.graphics.show_cursor = false;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.window.timing.delta_time;

        fly_camera_system(world);
        self.update_held_object(world);
        self.update_ui(world);

        run_physics_systems(world);
        sync_transforms_from_physics_system(world);
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: ElementState) {
        if state == ElementState::Pressed {
            match key {
                KeyCode::Digit1 =&gt; self.spawn_mode = SpawnMode::Cube,
                KeyCode::Digit2 =&gt; self.spawn_mode = SpawnMode::Sphere,
                KeyCode::Digit3 =&gt; self.spawn_mode = SpawnMode::Cylinder,
                KeyCode::Digit4 =&gt; self.spawn_mode = SpawnMode::Chain,
                KeyCode::Digit5 =&gt; self.spawn_mode = SpawnMode::Ragdoll,
                KeyCode::KeyR =&gt; self.reset_scene(world),
                KeyCode::KeyF =&gt; self.apply_explosion(world),
                KeyCode::KeyG =&gt; self.toggle_gravity(world),
                _ =&gt; {}
            }
        }
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {
        match (button, state) {
            (MouseButton::Left, ElementState::Pressed) =&gt; {
                self.spawn_object(world);
            }
            (MouseButton::Right, ElementState::Pressed) =&gt; {
                self.grab_object(world);
            }
            (MouseButton::Right, ElementState::Released) =&gt; {
                self.release_object(world);
            }
            (MouseButton::Middle, ElementState::Pressed) =&gt; {
                self.delete_at_cursor(world);
            }
            _ =&gt; {}
        }
    }
}

impl PhysicsPlayground {
    fn setup_environment(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_plane_at(world, Vec3::zeros());
        set_material_with_textures(world,floor, Material {
            base_color: [0.3, 0.3, 0.35, 1.0],
            roughness: 0.8,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Cuboid {
            half_extents: Vec3::new(50.0, 0.1, 50.0),
        });

        self.spawn_walls(world);

        spawn_sun(world);
        world.resources.graphics.ambient_light = [0.2, 0.2, 0.2, 1.0];
    }

    fn spawn_walls(&amp;mut self, world: &amp;mut World) {
        let wall_positions = [
            (Vec3::new(25.0, 2.5, 0.0), Vec3::new(0.5, 5.0, 50.0)),
            (Vec3::new(-25.0, 2.5, 0.0), Vec3::new(0.5, 5.0, 50.0)),
            (Vec3::new(0.0, 2.5, 25.0), Vec3::new(50.0, 5.0, 0.5)),
            (Vec3::new(0.0, 2.5, -25.0), Vec3::new(50.0, 5.0, 0.5)),
        ];

        for (position, half_extents) in wall_positions {
            let wall = spawn_cube_at(world, position);
            set_material_with_textures(world,wall, Material {
                base_color: [0.4, 0.4, 0.45, 1.0],
                roughness: 0.9,
                ..Default::default()
            });
            add_collider(world, wall, ColliderShape::Cuboid { half_extents });
        }
    }

    fn setup_ui(&amp;mut self, world: &amp;mut World) {
        let help_text = "Controls:\n\
            1-5: Select spawn mode\n\
            Left Click: Spawn object\n\
            Right Click: Grab/throw\n\
            Middle Click: Delete\n\
            R: Reset scene\n\
            F: Explosion\n\
            G: Toggle gravity";

        spawn_hud_text(world, help_text, HudAnchor::TopLeft, Vec2::new(20.0, 20.0));

        spawn_hud_text(world, "Mode: Cube", HudAnchor::TopRight, Vec2::new(-20.0, 20.0));
    }

    fn update_ui(&amp;mut self, world: &amp;mut World) {
    }

    fn spawn_object(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let spawn_position = transform.translation() +
            transform.forward_vector() * 5.0;

        match self.spawn_mode {
            SpawnMode::Cube =&gt; self.spawn_cube(world, spawn_position),
            SpawnMode::Sphere =&gt; self.spawn_sphere(world, spawn_position),
            SpawnMode::Cylinder =&gt; self.spawn_cylinder(world, spawn_position),
            SpawnMode::Chain =&gt; self.spawn_chain(world, spawn_position),
            SpawnMode::Ragdoll =&gt; self.spawn_ragdoll(world, spawn_position),
        }
    }

    fn spawn_cube(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let cube = spawn_cube_at(world, position);

        if let Some(transform) = world.get_local_transform_mut(cube) {
            transform.rotation = random_rotation();
        }

        set_material_with_textures(world,cube, Material {
            base_color: random_color(),
            roughness: 0.7,
            metallic: 0.1,
            ..Default::default()
        });

        add_rigid_body(world, cube, RigidBodyType::Dynamic, 1.0);
        add_collider(world, cube, ColliderShape::Cuboid {
            half_extents: Vec3::new(0.5, 0.5, 0.5),
        });

        cube
    }

    fn spawn_sphere(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let sphere = spawn_sphere_at(world, position);

        set_material_with_textures(world,sphere, Material {
            base_color: random_color(),
            roughness: 0.3,
            metallic: 0.8,
            ..Default::default()
        });

        add_rigid_body(world, sphere, RigidBodyType::Dynamic, 1.0);
        add_collider(world, sphere, ColliderShape::Ball { radius: 0.5 });

        sphere
    }

    fn spawn_cylinder(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let capsule = spawn_cylinder_at(world, position);

        if let Some(transform) = world.get_local_transform_mut(capsule) {
            transform.rotation = random_rotation();
        }

        set_material_with_textures(world,capsule, Material {
            base_color: random_color(),
            roughness: 0.5,
            metallic: 0.3,
            ..Default::default()
        });

        add_rigid_body(world, capsule, RigidBodyType::Dynamic, 1.0);
        add_collider(world, capsule, ColliderShape::Capsule {
            half_height: 0.5,
            radius: 0.3,
        });

        capsule
    }

    fn spawn_chain(&amp;self, world: &amp;mut World, start_position: Vec3) {
        let link_count = 10;
        let link_spacing = 0.8;
        let mut previous_link: Option&lt;Entity&gt; = None;

        for index in 0..link_count {
            let position = start_position + Vec3::new(0.0, -(index as f32 * link_spacing), 0.0);

            let link = spawn_cylinder_at(world, position);
            if let Some(transform) = world.get_local_transform_mut(link) {
                transform.scale = Vec3::new(0.2, 0.3, 0.2);
            }

            set_material_with_textures(world,link, Material {
                base_color: [0.7, 0.7, 0.75, 1.0],
                roughness: 0.3,
                metallic: 0.9,
                ..Default::default()
            });

            if index == 0 {
                add_rigid_body(world, link, RigidBodyType::Fixed, 0.0);
            } else {
                add_rigid_body(world, link, RigidBodyType::Dynamic, 0.5);
            }

            add_collider(world, link, ColliderShape::Capsule {
                half_height: 0.15,
                radius: 0.1,
            });

            if let Some(prev) = previous_link {
                create_spherical_joint(
                    world,
                    prev,
                    Vec3::new(0.0, -link_spacing / 2.0, 0.0),
                    link,
                    Vec3::new(0.0, link_spacing / 2.0, 0.0),
                );
            }

            previous_link = Some(link);
        }
    }

    fn spawn_ragdoll(&amp;self, world: &amp;mut World, position: Vec3) {
        let torso = self.spawn_body_part(world, position, Vec3::new(0.3, 0.4, 0.2), [0.8, 0.6, 0.5, 1.0]);

        let head = self.spawn_body_part(
            world,
            position + Vec3::new(0.0, 0.6, 0.0),
            Vec3::new(0.15, 0.15, 0.15),
            [0.9, 0.7, 0.6, 1.0],
        );

        let left_arm = self.spawn_body_part(
            world,
            position + Vec3::new(-0.5, 0.2, 0.0),
            Vec3::new(0.25, 0.08, 0.08),
            [0.8, 0.6, 0.5, 1.0],
        );

        let right_arm = self.spawn_body_part(
            world,
            position + Vec3::new(0.5, 0.2, 0.0),
            Vec3::new(0.25, 0.08, 0.08),
            [0.8, 0.6, 0.5, 1.0],
        );

        let left_leg = self.spawn_body_part(
            world,
            position + Vec3::new(-0.15, -0.6, 0.0),
            Vec3::new(0.1, 0.3, 0.1),
            [0.3, 0.3, 0.5, 1.0],
        );

        let right_leg = self.spawn_body_part(
            world,
            position + Vec3::new(0.15, -0.6, 0.0),
            Vec3::new(0.1, 0.3, 0.1),
            [0.3, 0.3, 0.5, 1.0],
        );

        create_spherical_joint(world, torso, Vec3::new(0.0, 0.4, 0.0), head, Vec3::new(0.0, -0.15, 0.0));
        create_spherical_joint(world, torso, Vec3::new(-0.3, 0.2, 0.0), left_arm, Vec3::new(0.25, 0.0, 0.0));
        create_spherical_joint(world, torso, Vec3::new(0.3, 0.2, 0.0), right_arm, Vec3::new(-0.25, 0.0, 0.0));
        create_spherical_joint(world, torso, Vec3::new(-0.15, -0.4, 0.0), left_leg, Vec3::new(0.0, 0.3, 0.0));
        create_spherical_joint(world, torso, Vec3::new(0.15, -0.4, 0.0), right_leg, Vec3::new(0.0, 0.3, 0.0));
    }

    fn spawn_body_part(&amp;self, world: &amp;mut World, position: Vec3, half_extents: Vec3, color: [f32; 4]) -&gt; Entity {
        let part = spawn_cube_at(world, position);

        if let Some(transform) = world.get_local_transform_mut(part) {
            transform.scale = half_extents * 2.0;
        }

        set_material_with_textures(world,part, Material {
            base_color: color,
            roughness: 0.8,
            ..Default::default()
        });

        add_rigid_body(world, part, RigidBodyType::Dynamic, half_extents.x * half_extents.y * half_extents.z * 8.0);
        add_collider(world, part, ColliderShape::Cuboid { half_extents });

        part
    }

    fn grab_object(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let origin = transform.translation();
        let direction = transform.forward_vector();

        if let Some(hit) = raycast(world, origin, direction, 20.0) {
            if world.get_rigid_body(hit.entity).is_some() {
                self.holding_entity = Some(hit.entity);
                self.grab_distance = hit.distance;

                if let Some(body) = world.get_rigid_body_mut(hit.entity) {
                    body.linear_damping = 10.0;
                    body.angular_damping = 10.0;
                }
            }
        }
    }

    fn release_object(&amp;mut self, world: &amp;mut World) {
        if let Some(entity) = self.holding_entity.take() {
            if let Some(body) = world.get_rigid_body_mut(entity) {
                body.linear_damping = 0.0;
                body.angular_damping = 0.0;

                let Some(camera) = world.resources.active_camera else { return };
                let Some(transform) = world.get_global_transform(camera) else { return };

                let throw_direction = transform.forward_vector();
                body.linvel = [throw_direction.x * 20.0, throw_direction.y * 20.0, throw_direction.z * 20.0];
            }
        }
    }

    fn update_held_object(&amp;mut self, world: &amp;mut World) {
        let Some(entity) = self.holding_entity else { return };
        let Some(camera) = world.resources.active_camera else { return };
        let Some(camera_transform) = world.get_global_transform(camera) else { return };

        let target = camera_transform.translation() +
            camera_transform.forward_vector() * self.grab_distance;

        if let Some(transform) = world.get_local_transform(entity) {
            let to_target = target - transform.translation;
            if let Some(body) = world.get_rigid_body_mut(entity) {
                body.linvel = [to_target.x * 20.0, to_target.y * 20.0, to_target.z * 20.0];
            }
        }
    }

    fn delete_at_cursor(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let origin = transform.translation();
        let direction = transform.forward_vector();

        if let Some(hit) = raycast(world, origin, direction, 50.0) {
            world.despawn_entities(&amp;[hit.entity]);
        }
    }

    fn apply_explosion(&amp;self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let explosion_center = transform.translation() +
            transform.forward_vector() * 5.0;
        let explosion_radius = 10.0;
        let explosion_force = 50.0;

        for entity in world.query_entities(RIGID_BODY | GLOBAL_TRANSFORM) {
            if let (Some(body), Some(entity_transform)) = (
                world.get_rigid_body_mut(entity),
                world.get_global_transform(entity),
            ) {
                let to_entity = entity_transform.translation() - explosion_center;
                let distance = to_entity.magnitude();

                if distance &lt; explosion_radius &amp;&amp; distance &gt; 0.1 {
                    let falloff = 1.0 - (distance / explosion_radius);
                    let force = to_entity.normalize() * explosion_force * falloff;
                    body.linvel = [
                        body.linvel[0] + force.x,
                        body.linvel[1] + force.y,
                        body.linvel[2] + force.z,
                    ];
                }
            }
        }
    }

    fn toggle_gravity(&amp;self, world: &amp;mut World) {
        let gravity = &amp;mut world.resources.physics.gravity;
        if gravity.y &lt; 0.0 {
            *gravity = Vec3::zeros();
        } else {
            *gravity = Vec3::new(0.0, -9.81, 0.0);
        }
    }

    fn reset_scene(&amp;mut self, world: &amp;mut World) {
        let entities_to_remove: Vec&lt;Entity&gt; = world
            .query_entities(RIGID_BODY)
            .filter(|e| {
                world.get_rigid_body(*e)
                    .map(|b| b.body_type == RigidBodyType::Dynamic)
                    .unwrap_or(false)
            })
            .collect();

        world.despawn_entities(&amp;entities_to_remove);

        self.holding_entity = None;
        self.selected_entity = None;
    }
}

fn random_color() -&gt; [f32; 4] {
    [
        0.3 + 0.7 * pseudo_random(),
        0.3 + 0.7 * pseudo_random(),
        0.3 + 0.7 * pseudo_random(),
        1.0,
    ]
}

fn random_rotation() -&gt; nalgebra_glm::Quat {
    nalgebra_glm::quat_angle_axis(
        pseudo_random() * std::f32::consts::TAU,
        &amp;Vec3::new(
            pseudo_random() - 0.5,
            pseudo_random() - 0.5,
            pseudo_random() - 0.5,
        ).normalize(),
    )
}

fn pseudo_random() -&gt; f32 {
    static mut SEED: u32 = 12345;
    unsafe {
        SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
        (SEED as f32 / u32::MAX as f32)
    }
}

fn main() {
    nightshade::launch(PhysicsPlayground::default());
}</code></pre></pre>
<h2 id="features-demonstrated"><a class="header" href="#features-demonstrated">Features Demonstrated</a></h2>
<h3 id="object-spawning"><a class="header" href="#object-spawning">Object Spawning</a></h3>
<p>Spawn various physics primitives with random colors:</p>
<ul>
<li>Cubes</li>
<li>Spheres</li>
<li>Cylinders</li>
</ul>
<h3 id="joint-systems"><a class="header" href="#joint-systems">Joint Systems</a></h3>
<p><strong>Chain</strong>: A series of capsules connected by spherical joints, anchored at the top.</p>
<p><strong>Ragdoll</strong>: A humanoid figure made of box body parts connected by joints:</p>
<ul>
<li>Head connected to torso</li>
<li>Arms connected to torso</li>
<li>Legs connected to torso</li>
</ul>
<h3 id="object-manipulation"><a class="header" href="#object-manipulation">Object Manipulation</a></h3>
<p><strong>Grab</strong>: Right-click to grab objects and move them with the camera.</p>
<p><strong>Throw</strong>: Release right-click to throw grabbed objects.</p>
<p><strong>Delete</strong>: Middle-click to delete objects.</p>
<h3 id="physics-effects"><a class="header" href="#physics-effects">Physics Effects</a></h3>
<p><strong>Explosion</strong>: Press F to apply radial force to nearby objects.</p>
<p><strong>Gravity Toggle</strong>: Press G to toggle between normal gravity and zero gravity.</p>
<h3 id="raycasting-1"><a class="header" href="#raycasting-1">Raycasting</a></h3>
<p>Used for:</p>
<ul>
<li>Selecting objects to grab</li>
<li>Deleting objects</li>
<li>Hit detection</li>
</ul>
<h2 id="cargotoml-4"><a class="header" href="#cargotoml-4">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "physics-playground"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "wgpu", "physics"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags-3"><a class="header" href="#feature-flags-3">Feature Flags</a></h1>
<p>Nightshade uses Cargo feature flags to enable optional functionality. This allows you to include only the features you need, reducing compile times and binary size.</p>
<h2 id="default-features"><a class="header" href="#default-features">Default Features</a></h2>
<p>Nightshade defaults to <code>["engine", "wgpu"]</code>:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade.git" }
</code></pre>
<p>This gives you the full engine with the wgpu rendering backend. You only need to specify features explicitly if you want additional optional features or a minimal configuration.</p>
<h2 id="aggregate-features"><a class="header" href="#aggregate-features">Aggregate Features</a></h2>
<h3 id="engine-default"><a class="header" href="#engine-default"><code>engine</code> (default)</a></h3>
<p>The main engine feature. Includes everything needed for building games.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine"] }
</code></pre>
<p><strong>Includes:</strong> <code>runtime</code>, <code>assets</code>, <code>scene_graph</code>, <code>picking</code>, <code>file_dialog</code>, <code>async_runtime</code>, <code>terrain</code>, <code>screenshot</code>, plus rand, rayon, ehttp, futures, and WASM support libraries (js-sys, wasm-bindgen, wasm-bindgen-futures, web-sys).</p>
<p><strong>Provides:</strong></p>
<ul>
<li>Window creation and event loop</li>
<li>wgpu rendering backend</li>
<li>ECS (freecs)</li>
<li>Transform hierarchy</li>
<li>Camera systems</li>
<li>Mesh rendering and GPU instancing</li>
<li>PBR material system</li>
<li>Lighting (directional, point, spot) with shadows</li>
<li>Post-processing (bloom, SSAO, depth of field, tonemapping)</li>
<li>Procedural atmospheres (sky, clouds, space, nebula)</li>
<li>glTF/GLB model loading</li>
<li>Scene save/load</li>
<li>Input handling (keyboard, mouse, touch)</li>
<li>Procedural terrain</li>
<li>Picking (bounding box ray casting)</li>
<li>File dialogs</li>
<li>Screenshot capture</li>
</ul>
<h3 id="runtime"><a class="header" href="#runtime"><code>runtime</code></a></h3>
<p>Minimal rendering without asset loading. Use for lightweight apps that don't need glTF/image loading.</p>
<pre><code class="language-toml">nightshade = { default-features = false, features = ["runtime", "wgpu", "egui"] }
</code></pre>
<p><strong>Includes:</strong> <code>core</code>, <code>text</code>, <code>behaviors</code>.</p>
<h3 id="full"><a class="header" href="#full"><code>full</code></a></h3>
<p>Everything in <code>engine</code> plus all major optional features.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["full"] }
</code></pre>
<p><strong>Includes:</strong> <code>engine</code>, <code>wgpu</code>, <code>egui</code>, <code>shell</code>, <code>audio</code>, <code>physics</code>, <code>gamepad</code>, <code>navmesh</code>, <code>scripting</code>, <code>fbx</code>, <code>lattice</code>, <code>sdf_sculpt</code>, <code>mosaic</code>, <code>editor</code>, <code>plugins</code>.</p>
<h2 id="granular-features"><a class="header" href="#granular-features">Granular Features</a></h2>
<p>These provide fine-grained control over dependencies:</p>
<h3 id="core"><a class="header" href="#core"><code>core</code></a></h3>
<p>Foundation: ECS (freecs), math (nalgebra, nalgebra-glm), windowing (winit), time (web-time), graph (petgraph), tracing, UUIDs, JSON serialization.</p>
<h3 id="text"><a class="header" href="#text"><code>text</code></a></h3>
<p>3D text rendering using fontdue. Requires <code>core</code>.</p>
<h3 id="assets"><a class="header" href="#assets"><code>assets</code></a></h3>
<p>Asset loading: gltf, image, half, bincode, serde_json, lz4 compression. Requires <code>core</code>.</p>
<h3 id="scene_graph"><a class="header" href="#scene_graph"><code>scene_graph</code></a></h3>
<p>Scene hierarchy system with save/load. Requires <code>assets</code>.</p>
<h3 id="terrain-1"><a class="header" href="#terrain-1"><code>terrain</code></a></h3>
<p>Procedural terrain generation using noise and rand. Requires <code>core</code>.</p>
<h3 id="file_dialog"><a class="header" href="#file_dialog"><code>file_dialog</code></a></h3>
<p>Native file dialogs using rfd and dirs. Enables the native-only functions in <code>nightshade::filesystem</code> (<code>pick_file</code>, <code>pick_folder</code>, <code>save_file_dialog</code>, <code>read_file</code>, <code>write_file</code>). The cross-platform functions (<code>save_file</code>, <code>request_file_load</code>) are always available on WASM and require this feature on native. See the <a href="filesystem.html">File System</a> chapter. Requires <code>core</code>.</p>
<h3 id="async_runtime"><a class="header" href="#async_runtime"><code>async_runtime</code></a></h3>
<p>Tokio async runtime for non-blocking operations. Requires <code>core</code>.</p>
<h3 id="screenshot"><a class="header" href="#screenshot"><code>screenshot</code></a></h3>
<p>PNG screenshot saving using image.</p>
<h3 id="picking"><a class="header" href="#picking"><code>picking</code></a></h3>
<p>Ray-based entity picking with bounding box intersection. Trimesh picking requires <code>physics</code>.</p>
<h3 id="behaviors"><a class="header" href="#behaviors"><code>behaviors</code></a></h3>
<p>Built-in behavior components and systems.</p>
<h2 id="rendering-4"><a class="header" href="#rendering-4">Rendering</a></h2>
<h3 id="wgpu-default"><a class="header" href="#wgpu-default"><code>wgpu</code> (default)</a></h3>
<p>WebGPU-based rendering backend supporting DirectX 12, Metal, Vulkan, and WebGPU.</p>
<h2 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h2>
<h3 id="egui"><a class="header" href="#egui"><code>egui</code></a></h3>
<p>Immediate mode GUI framework. Enables <code>fn ui()</code> on the State trait.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["egui"] }
</code></pre>
<p><strong>Additional Dependencies:</strong> egui, egui_extras, egui-winit, egui-wgpu, egui_tiles</p>
<h3 id="shell"><a class="header" href="#shell"><code>shell</code></a></h3>
<p>Developer console with command registration. Press backtick to open. Requires <code>egui</code>.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["shell"] }
</code></pre>
<h3 id="audio-1"><a class="header" href="#audio-1"><code>audio</code></a></h3>
<p>Audio playback using Kira.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["audio"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Sound loading (WAV, OGG, MP3, FLAC)</li>
<li>Sound playback with volume, pitch, panning</li>
<li>Spatial/3D audio with distance attenuation</li>
<li>Audio listener and source components</li>
<li>Looping and one-shot sounds</li>
</ul>
<h3 id="fft"><a class="header" href="#fft"><code>fft</code></a></h3>
<p>FFT-based audio analysis for music-reactive applications.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["fft"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Real-time FFT spectral analysis</li>
<li>Six-band frequency decomposition (sub-bass to highs)</li>
<li>Beat detection (kick, snare, hi-hat)</li>
<li>BPM estimation and beat phase tracking</li>
<li>Spectral features (centroid, flatness, rolloff, flux)</li>
<li>Onset detection with adaptive thresholding</li>
</ul>
<p><strong>Additional Dependencies:</strong> rustfft</p>
<h3 id="physics-1"><a class="header" href="#physics-1"><code>physics</code></a></h3>
<p>Rapier3D physics integration.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["physics"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Rigid body simulation (dynamic, kinematic, static)</li>
<li>Collider shapes (box, sphere, capsule, cylinder, cone, convex hull, trimesh, heightfield)</li>
<li>Collision detection</li>
<li>Character controllers</li>
<li>Physics interpolation for smooth rendering</li>
<li>Trimesh picking (when combined with <code>picking</code>)</li>
</ul>
<p><strong>Additional Dependencies:</strong> rapier3d</p>
<h3 id="gamepad"><a class="header" href="#gamepad"><code>gamepad</code></a></h3>
<p>Gamepad/controller support via gilrs.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["gamepad"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Gamepad detection and hot-plugging</li>
<li>Button input (face buttons, triggers, bumpers, D-pad)</li>
<li>Analog stick input with deadzone handling</li>
<li>Trigger pressure (0.0 - 1.0)</li>
<li>Rumble/vibration</li>
<li>Multiple gamepad support</li>
</ul>
<h3 id="navmesh"><a class="header" href="#navmesh"><code>navmesh</code></a></h3>
<p>AI navigation mesh generation via Recast.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["navmesh"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Navigation mesh generation from world geometry</li>
<li>A* and Dijkstra pathfinding</li>
<li>NavMesh agent component with autonomous movement</li>
<li>Height sampling on navigation mesh</li>
<li>Debug visualization</li>
</ul>
<p><strong>Additional Dependencies:</strong> rerecast, glam</p>
<h3 id="scripting-1"><a class="header" href="#scripting-1"><code>scripting</code></a></h3>
<p>Rhai scripting runtime for dynamic behavior.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["scripting"] }
</code></pre>
<h3 id="fbx"><a class="header" href="#fbx"><code>fbx</code></a></h3>
<p>FBX model loading using ufbx. Requires <code>assets</code>.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["fbx"] }
</code></pre>
<h3 id="lattice"><a class="header" href="#lattice"><code>lattice</code></a></h3>
<p>Lattice deformation system for free-form mesh deformation.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["lattice"] }
</code></pre>
<h3 id="sdf_sculpt"><a class="header" href="#sdf_sculpt"><code>sdf_sculpt</code></a></h3>
<p>Signed Distance Field sculpting system.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["sdf_sculpt"] }
</code></pre>
<h2 id="platform-features"><a class="header" href="#platform-features">Platform Features</a></h2>
<h3 id="openxr"><a class="header" href="#openxr"><code>openxr</code></a></h3>
<p>OpenXR VR support. Uses Vulkan backend. Provides <code>launch_xr()</code> entry point, VR input (head/hand tracking, controllers), and locomotion.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["openxr"] }
</code></pre>
<p><strong>Additional Dependencies:</strong> openxr, ash, wgpu-hal, gpu-allocator</p>
<h3 id="steam"><a class="header" href="#steam"><code>steam</code></a></h3>
<p>Steamworks integration for achievements, stats, multiplayer, and friends.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["steam"] }
</code></pre>
<p><strong>Additional Dependencies:</strong> steamworks, steamworks-sys</p>
<h3 id="webview-1"><a class="header" href="#webview-1"><code>webview</code></a></h3>
<p>Bidirectional IPC for hosting web frontends (Leptos, Yew, etc.) inside a nightshade window.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["webview"] }
</code></pre>
<p><strong>Additional Dependencies:</strong> wry, tiny_http, include_dir, wasm-bindgen, js-sys, web-sys</p>
<h3 id="mosaic"><a class="header" href="#mosaic"><code>mosaic</code></a></h3>
<p>Multi-pane desktop application framework built on <code>egui_tiles</code>. Provides dockable tile-based layouts, a <code>Widget</code> trait for serializable panes, theming with 11 presets, modal dialogs, toast notifications, command palettes, keyboard shortcuts, file dialogs, project save/load, status bars, FPS counters, undo/redo history, clipboard helpers, drag-and-drop support, and a built-in <code>ViewportWidget</code> for rendering camera outputs.</p>
<p>Requires <code>egui</code>.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["mosaic"] }
</code></pre>
<p><strong>Key types:</strong> <code>Mosaic</code>, <code>Widget</code>, <code>Pane</code>, <code>WidgetContext</code>, <code>ViewportWidget</code>, <code>ThemeState</code>, <code>Modals</code>, <code>Toasts</code>, <code>StatusBar</code>, <code>CommandPalette</code>, <code>ShortcutManager</code>, <code>Settings</code>, <code>EventLog</code>, <code>FpsCounter</code>, <code>MosaicConfig</code>, <code>ProjectSaveFile</code>, <code>LayoutEvent</code></p>
<h3 id="editor"><a class="header" href="#editor"><code>editor</code></a></h3>
<p>Scene editor infrastructure for building custom editors. Provides gizmo manipulation, undo/redo, component inspectors, entity picking, selection management, clipboard operations, keyboard shortcuts, scene tree UI, context menus, camera controls, and asset loading utilities.</p>
<p>Requires <code>mosaic</code> and <code>picking</code>.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["editor"] }
</code></pre>
<p><strong>Provides:</strong></p>
<ul>
<li>Transform gizmos (translate, rotate, scale) with local/global coordinate spaces</li>
<li>Modal transform operations (Blender-style G/R/S keys with axis constraints)</li>
<li>Undo/redo history with entity snapshots</li>
<li>Component inspector UI for all built-in components</li>
<li>GPU-based entity picking and marquee selection</li>
<li>Entity selection with multi-select, copy/paste, duplicate</li>
<li>Scene tree with drag-and-drop reparenting</li>
<li>Context menus and add-node modal</li>
<li>Camera view presets and ortho toggle</li>
<li>Keyboard shortcut handler (Blender-style)</li>
<li>Code editor with syntax highlighting (syntect, native only)</li>
<li>Clipboard integration (arboard, native only)</li>
</ul>
<p><strong>Additional Dependencies:</strong> syntect (native only), arboard (native only)</p>
<p><strong>Key types:</strong> <code>EditorContext</code>, <code>UndoHistory</code>, <code>ComponentInspectorUi</code>, <code>InspectorContext</code>, <code>WorldTreeUi</code>, <code>EntitySelection</code>, <code>TreeCache</code>, <code>GizmoInteraction</code>, <code>InputSignal</code></p>
<h3 id="windows-app-icon"><a class="header" href="#windows-app-icon"><code>windows-app-icon</code></a></h3>
<p>Embed a custom icon into Windows executables at build time.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["windows-app-icon"] }
</code></pre>
<p><strong>Additional Dependencies:</strong> winresource, ico, image</p>
<h2 id="profiling-features"><a class="header" href="#profiling-features">Profiling Features</a></h2>
<h3 id="tracing"><a class="header" href="#tracing"><code>tracing</code></a></h3>
<p>Rolling log files and <code>RUST_LOG</code> support via tracing-appender.</p>
<h3 id="tracy"><a class="header" href="#tracy"><code>tracy</code></a></h3>
<p>Real-time profiling with Tracy. Implies <code>tracing</code>.</p>
<h3 id="chrome"><a class="header" href="#chrome"><code>chrome</code></a></h3>
<p>Chrome tracing output for <code>chrome://tracing</code>. Implies <code>tracing</code>.</p>
<h2 id="plugin-features"><a class="header" href="#plugin-features">Plugin Features</a></h2>
<h3 id="plugins"><a class="header" href="#plugins"><code>plugins</code></a></h3>
<p>Guest-side WASM plugin API for creating plugins.</p>
<h3 id="plugin_runtime"><a class="header" href="#plugin_runtime"><code>plugin_runtime</code></a></h3>
<p>WASM plugin hosting via Wasmtime. Requires <code>assets</code>.</p>
<p><strong>Additional Dependencies:</strong> wasmtime, wasmtime-wasi, anyhow</p>
<h2 id="terminal-features"><a class="header" href="#terminal-features">Terminal Features</a></h2>
<h3 id="tui"><a class="header" href="#tui"><code>tui</code></a></h3>
<p>Terminal UI framework built on the engine's rendering. Includes <code>runtime</code> and <code>text</code>.</p>
<p><strong>Additional Dependencies:</strong> rand</p>
<h3 id="terminal"><a class="header" href="#terminal"><code>terminal</code></a></h3>
<p>Crossterm-based terminal applications without the full rendering pipeline.</p>
<p><strong>Additional Dependencies:</strong> crossterm, rand, freecs</p>
<h2 id="other-features"><a class="header" href="#other-features">Other Features</a></h2>
<h3 id="mcp"><a class="header" href="#mcp"><code>mcp</code></a></h3>
<p>Starts an HTTP-based <a href="https://modelcontextprotocol.io">Model Context Protocol</a> server on <code>http://127.0.0.1:3333/mcp</code> when the application launches. Any MCP client (Claude Code, Claude Desktop, or custom tooling) can connect and manipulate the running scene in real time through 50+ tools covering entities, transforms, materials, lighting, physics, animation, scripting, and more.</p>
<p>Requires <code>async_runtime</code> and <code>behaviors</code>. Native only (not available on WASM).</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["mcp"] }
</code></pre>
<p>Connect Claude Code to the running engine:</p>
<pre><code class="language-bash">claude mcp add --transport http nightshade http://127.0.0.1:3333/mcp
</code></pre>
<p>Applications can intercept MCP commands before the engine processes them by implementing <code>handle_mcp_command</code> on the <code>State</code> trait. See the <a href="ai-integration.html">AI Integration</a> chapter for details.</p>
<p><strong>Additional Dependencies:</strong> axum, rmcp, schemars</p>
<h3 id="claude"><a class="header" href="#claude"><code>claude</code></a></h3>
<p>Provides types and a background worker thread for spawning Claude Code CLI as a subprocess and streaming its JSON output. This lets applications embed an AI assistant that can send queries, receive streamed responses (text, thinking, tool use events), and manage sessions.</p>
<p>Native only (not available on WASM).</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["claude"] }
</code></pre>
<p>Key types:</p>
<ul>
<li><code>ClaudeConfig</code> — system prompt, allowed/disallowed tools, MCP config, custom CLI args</li>
<li><code>CliCommand</code> — <code>StartQuery</code> (with prompt, optional session ID and model) and <code>Cancel</code></li>
<li><code>CliEvent</code> — <code>SessionStarted</code>, <code>TextDelta</code>, <code>ThinkingDelta</code>, <code>ToolUseStarted</code>, <code>ToolUseInputDelta</code>, <code>ToolUseFinished</code>, <code>TurnComplete</code>, <code>Complete</code>, <code>Error</code></li>
</ul>
<p>When both <code>claude</code> and <code>mcp</code> are enabled, <code>McpConfig::Auto</code> automatically generates the MCP config JSON pointing at <code>http://127.0.0.1:3333/mcp</code>, so Claude Code connects to the engine without manual setup.</p>
<p><strong>Additional Dependencies:</strong> serde_json</p>
<h2 id="feature-combinations"><a class="header" href="#feature-combinations">Feature Combinations</a></h2>
<h3 id="minimal-rendering-app"><a class="header" href="#minimal-rendering-app">Minimal Rendering App</a></h3>
<pre><code class="language-toml">nightshade = { default-features = false, features = ["runtime", "wgpu", "egui"] }
</code></pre>
<p>Lightweight egui app without asset loading.</p>
<h3 id="standard-game"><a class="header" href="#standard-game">Standard Game</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["egui", "physics", "audio", "gamepad"] }
</code></pre>
<p>Full game features with UI, physics, audio, and gamepad.</p>
<h3 id="open-world-game"><a class="header" href="#open-world-game">Open World Game</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = [
    "egui",
    "physics",
    "audio",
    "gamepad",
    "navmesh",
] }
</code></pre>
<p>Everything for large outdoor environments with AI pathfinding.</p>
<h3 id="vr-game"><a class="header" href="#vr-game">VR Game</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["openxr", "physics", "audio"] }
</code></pre>
<p>Virtual reality with physics and audio.</p>
<h3 id="music-visualizer"><a class="header" href="#music-visualizer">Music Visualizer</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["audio", "fft"] }
</code></pre>
<p>Audio-reactive visualizations with FFT analysis.</p>
<h3 id="desktop-tool"><a class="header" href="#desktop-tool">Desktop Tool</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["mosaic", "egui"] }
</code></pre>
<p>Multi-pane desktop application with dockable widgets.</p>
<h3 id="custom-scene-editor"><a class="header" href="#custom-scene-editor">Custom Scene Editor</a></h3>
<pre><code class="language-toml">nightshade = { git = "...", features = ["editor", "fbx", "physics", "navmesh"] }
</code></pre>
<p>Full scene editor with gizmos, inspectors, undo/redo, FBX import, physics colliders, and navmesh editing.</p>
<h2 id="feature-dependencies"><a class="header" href="#feature-dependencies">Feature Dependencies</a></h2>
<p>Some features have implicit dependencies:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Depends On</th></tr></thead><tbody>
<tr><td><code>engine</code></td><td><code>runtime</code>, <code>assets</code>, <code>scene_graph</code>, <code>picking</code>, <code>terrain</code>, <code>file_dialog</code>, <code>async_runtime</code>, <code>screenshot</code></td></tr>
<tr><td><code>runtime</code></td><td><code>core</code>, <code>text</code>, <code>behaviors</code></td></tr>
<tr><td><code>full</code></td><td><code>engine</code>, <code>wgpu</code>, <code>egui</code>, <code>shell</code>, <code>audio</code>, <code>physics</code>, <code>gamepad</code>, <code>navmesh</code>, <code>scripting</code>, <code>fbx</code>, <code>lattice</code>, <code>sdf_sculpt</code>, <code>mosaic</code>, <code>editor</code>, <code>plugins</code></td></tr>
<tr><td><code>mosaic</code></td><td><code>egui</code></td></tr>
<tr><td><code>editor</code></td><td><code>mosaic</code>, <code>picking</code></td></tr>
<tr><td><code>shell</code></td><td><code>egui</code></td></tr>
<tr><td><code>fbx</code></td><td><code>assets</code></td></tr>
<tr><td><code>scene_graph</code></td><td><code>assets</code></td></tr>
<tr><td><code>assets</code></td><td><code>core</code></td></tr>
<tr><td><code>text</code></td><td><code>core</code></td></tr>
<tr><td><code>terrain</code></td><td><code>core</code></td></tr>
<tr><td><code>tui</code></td><td><code>runtime</code>, <code>text</code></td></tr>
<tr><td><code>plugin_runtime</code></td><td><code>assets</code></td></tr>
<tr><td><code>mcp</code></td><td><code>async_runtime</code>, <code>behaviors</code></td></tr>
<tr><td><code>claude</code></td><td>(none)</td></tr>
<tr><td><code>tracy</code></td><td><code>tracing</code></td></tr>
<tr><td><code>chrome</code></td><td><code>tracing</code></td></tr>
<tr><td><code>openxr</code></td><td><code>wgpu</code> (Vulkan backend)</td></tr>
</tbody></table>
</div>
<h2 id="checking-enabled-features"><a class="header" href="#checking-enabled-features">Checking Enabled Features</a></h2>
<p>Use <code>cfg</code> attributes for conditional compilation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(world, Vec3::new(5.0, 3.0, 5.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);
    spawn_sun(world);

    #[cfg(feature = "physics")]
    {
        let entity = world.spawn_entities(
            RIGID_BODY | COLLIDER | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | RENDER_MESH,
            1,
        )[0];
        world.set_rigid_body(entity, RigidBodyComponent::new_dynamic());
        world.set_collider(entity, ColliderComponent::cuboid(0.5, 0.5, 0.5));
    }

    #[cfg(feature = "audio")]
    {
        let source = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];
        world.set_audio_source(source, AudioSource::new("music").with_looping(true).playing());
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support-1"><a class="header" href="#platform-support-1">Platform Support</a></h1>
<p>Nightshade supports multiple platforms through wgpu's cross-platform abstractions.</p>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Status</th><th>Backend</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows 10/11</td><td>Full Support</td><td>Vulkan, DX12</td><td>Primary development platform</td></tr>
<tr><td>Linux</td><td>Full Support</td><td>Vulkan</td><td>X11 and Wayland</td></tr>
<tr><td>macOS</td><td>Full Support</td><td>Metal</td><td>Requires macOS 10.13+</td></tr>
<tr><td>Web (WASM)</td><td>Experimental</td><td>WebGPU</td><td>Modern browsers only</td></tr>
</tbody></table>
</div>
<h2 id="windows-2"><a class="header" href="#windows-2">Windows</a></h2>
<h3 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h3>
<ul>
<li>Windows 10 version 1903 or later (for DX12)</li>
<li>Windows 10 version 1607 or later (for Vulkan)</li>
<li>GPU with Vulkan 1.1 or DirectX 12 support</li>
</ul>
<h3 id="graphics-backends"><a class="header" href="#graphics-backends">Graphics Backends</a></h3>
<p>Windows supports multiple backends in order of preference:</p>
<ol>
<li><strong>Vulkan</strong> - Best performance and feature support</li>
<li><strong>DirectX 12</strong> - Native Windows API, good compatibility</li>
<li><strong>DirectX 11</strong> - Fallback for older hardware</li>
</ol>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="distribution"><a class="header" href="#distribution">Distribution</a></h3>
<p>The executable is self-contained. Include your <code>assets</code> folder alongside the executable.</p>
<pre><code>game/
├── game.exe
└── assets/
    ├── models/
    ├── textures/
    └── audio/
</code></pre>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<h3 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h3>
<ul>
<li>X11 or Wayland display server</li>
<li>Vulkan 1.1 compatible GPU and drivers</li>
<li>Common distributions: Ubuntu 20.04+, Fedora 33+, Arch Linux</li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Install Vulkan development packages:</p>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt install libvulkan1 vulkan-tools libvulkan-dev
sudo apt install libasound2-dev  # For audio feature
</code></pre>
<p><strong>Fedora:</strong></p>
<pre><code class="language-bash">sudo dnf install vulkan-loader vulkan-tools vulkan-headers
sudo dnf install alsa-lib-devel  # For audio feature
</code></pre>
<p><strong>Arch Linux:</strong></p>
<pre><code class="language-bash">sudo pacman -S vulkan-icd-loader vulkan-tools vulkan-headers
sudo pacman -S alsa-lib  # For audio feature
</code></pre>
<h3 id="building-1"><a class="header" href="#building-1">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="wayland-support"><a class="header" href="#wayland-support">Wayland Support</a></h3>
<p>Nightshade uses winit which supports both X11 and Wayland. The backend is selected automatically based on environment:</p>
<pre><code class="language-bash"># Force X11
WINIT_UNIX_BACKEND=x11 ./game

# Force Wayland
WINIT_UNIX_BACKEND=wayland ./game
</code></pre>
<h3 id="distribution-1"><a class="header" href="#distribution-1">Distribution</a></h3>
<p>Create an AppImage or distribute with a shell script:</p>
<pre><code class="language-bash">#!/bin/bash
cd "$(dirname "$0")"
./game
</code></pre>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<h3 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h3>
<ul>
<li>macOS 10.13 (High Sierra) or later</li>
<li>Metal-capable GPU (most Macs from 2012+)</li>
</ul>
<h3 id="building-2"><a class="header" href="#building-2">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="code-signing"><a class="header" href="#code-signing">Code Signing</a></h3>
<p>For distribution, sign your application:</p>
<pre><code class="language-bash">codesign --deep --force --sign "Developer ID Application: Your Name" target/release/game
</code></pre>
<h3 id="app-bundle"><a class="header" href="#app-bundle">App Bundle</a></h3>
<p>Create a macOS app bundle:</p>
<pre><code>Game.app/
└── Contents/
    ├── Info.plist
    ├── MacOS/
    │   └── game
    └── Resources/
        └── assets/
</code></pre>
<p><strong>Info.plist:</strong></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;CFBundleExecutable&lt;/key&gt;
    &lt;string&gt;game&lt;/string&gt;
    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
    &lt;string&gt;com.yourcompany.game&lt;/string&gt;
    &lt;key&gt;CFBundleName&lt;/key&gt;
    &lt;string&gt;Game&lt;/string&gt;
    &lt;key&gt;CFBundleVersion&lt;/key&gt;
    &lt;string&gt;1.0&lt;/string&gt;
    &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
    &lt;string&gt;1.0&lt;/string&gt;
    &lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;
    &lt;string&gt;10.13&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<h2 id="web-webassembly"><a class="header" href="#web-webassembly">Web (WebAssembly)</a></h2>
<h3 id="requirements-5"><a class="header" href="#requirements-5">Requirements</a></h3>
<ul>
<li>Modern browser with WebGPU support</li>
<li>Chrome 113+, Edge 113+, Firefox 141+</li>
</ul>
<h3 id="building-3"><a class="header" href="#building-3">Building</a></h3>
<p>Install wasm-pack:</p>
<pre><code class="language-bash">cargo install wasm-pack
</code></pre>
<p>Build for web:</p>
<pre><code class="language-bash">wasm-pack build --target web
</code></pre>
<h3 id="html-template"><a class="header" href="#html-template">HTML Template</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Game&lt;/title&gt;
    &lt;style&gt;
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
    &lt;script type="module"&gt;
        import init from './pkg/game.js';
        init();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Web builds have some limitations:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th></tr></thead><tbody>
<tr><td>Rendering</td><td>Supported</td></tr>
<tr><td>Input</td><td>Supported</td></tr>
<tr><td>Audio</td><td>Supported (Web Audio)</td></tr>
<tr><td>Gamepad</td><td>Supported (Gamepad API)</td></tr>
<tr><td>Physics</td><td>Supported</td></tr>
<tr><td>File System</td><td>Limited (no direct access)</td></tr>
<tr><td>Threads</td><td>Limited (requires SharedArrayBuffer)</td></tr>
</tbody></table>
</div>
<h3 id="asset-loading"><a class="header" href="#asset-loading">Asset Loading</a></h3>
<p>Assets must be served over HTTP. Use fetch API for loading:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
async fn load_assets() {
    // Assets loaded via HTTP fetch
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h2>
<h3 id="windows-from-linux"><a class="header" href="#windows-from-linux">Windows from Linux</a></h3>
<p>Install the MinGW toolchain:</p>
<pre><code class="language-bash">sudo apt install mingw-w64
rustup target add x86_64-pc-windows-gnu
cargo build --release --target x86_64-pc-windows-gnu
</code></pre>
<h3 id="linux-from-windows"><a class="header" href="#linux-from-windows">Linux from Windows</a></h3>
<p>Use WSL2 or Docker:</p>
<pre><code class="language-bash"># In WSL2
cargo build --release --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="macos-cross-compilation"><a class="header" href="#macos-cross-compilation">macOS Cross-Compilation</a></h3>
<p>Cross-compiling to macOS is complex due to SDK requirements. Consider using CI/CD services like GitHub Actions with macOS runners.</p>
<h2 id="gpu-requirements"><a class="header" href="#gpu-requirements">GPU Requirements</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Requirement</th></tr></thead><tbody>
<tr><td>API</td><td>Vulkan 1.1 / DX12 / Metal</td></tr>
<tr><td>VRAM</td><td>2 GB</td></tr>
<tr><td>Shader Model</td><td>5.0</td></tr>
</tbody></table>
</div>
<h3 id="recommended-requirements"><a class="header" href="#recommended-requirements">Recommended Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Requirement</th></tr></thead><tbody>
<tr><td>API</td><td>Vulkan 1.2+</td></tr>
<tr><td>VRAM</td><td>4+ GB</td></tr>
<tr><td>Shader Model</td><td>6.0</td></tr>
</tbody></table>
</div>
<h3 id="feature-support-by-gpu-generation"><a class="header" href="#feature-support-by-gpu-generation">Feature Support by GPU Generation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>GPU</th><th>Basic Rendering</th><th>Tessellation</th><th>Compute Culling</th></tr></thead><tbody>
<tr><td>Intel HD 4000+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>NVIDIA GTX 600+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>AMD GCN 1.0+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Apple M1+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h2 id="performance-by-platform"><a class="header" href="#performance-by-platform">Performance by Platform</a></h2>
<p>Relative performance (higher is better):</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Performance</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows (Vulkan)</td><td>100%</td><td>Best overall</td></tr>
<tr><td>Windows (DX12)</td><td>95%</td><td>Slightly more overhead</td></tr>
<tr><td>Linux (Vulkan)</td><td>98%</td><td>Excellent with proper drivers</td></tr>
<tr><td>macOS (Metal)</td><td>90%</td><td>Good, but Metal has different characteristics</td></tr>
<tr><td>Web (WebGPU)</td><td>70%</td><td>JavaScript overhead</td></tr>
</tbody></table>
</div>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="windows-no-suitable-adapter-found"><a class="header" href="#windows-no-suitable-adapter-found">Windows: "No suitable adapter found"</a></h3>
<ul>
<li>Update GPU drivers</li>
<li>Install Vulkan Runtime</li>
<li>Try forcing DX12: <code>WGPU_BACKEND=dx12 ./game.exe</code></li>
</ul>
<h3 id="linux-failed-to-create-vulkan-instance"><a class="header" href="#linux-failed-to-create-vulkan-instance">Linux: "Failed to create Vulkan instance"</a></h3>
<ul>
<li>Install Vulkan drivers for your GPU</li>
<li>Check <code>vulkaninfo</code> command works</li>
<li>Verify ICD loader: <code>ls /usr/share/vulkan/icd.d/</code></li>
</ul>
<h3 id="macos-metal-not-available"><a class="header" href="#macos-metal-not-available">macOS: "Metal not available"</a></h3>
<ul>
<li>Update macOS to 10.13+</li>
<li>Check GPU supports Metal: Apple Menu &gt; About This Mac &gt; System Report &gt; Graphics</li>
</ul>
<h3 id="web-webgpu-not-supported"><a class="header" href="#web-webgpu-not-supported">Web: "WebGPU not supported"</a></h3>
<ul>
<li>Use Chrome 113+ or Edge 113+</li>
<li>Enable WebGPU flag in browser settings if needed</li>
<li>Check <code>navigator.gpu</code> exists in browser console</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-quick-reference"><a class="header" href="#api-quick-reference">API Quick Reference</a></h1>
<p>Quick lookup for common Nightshade API functions and types.</p>
<h2 id="world"><a class="header" href="#world">World</a></h2>
<h3 id="entity-management-1"><a class="header" href="#entity-management-1">Entity Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entities = world.spawn_entities(flags, count);
let entity = world.spawn_entities(LOCAL_TRANSFORM | RENDER_MESH, 1)[0];

world.despawn_entities(&amp;[entity]);

for entity in world.query_entities(LOCAL_TRANSFORM | RENDER_MESH) {
    let transform = world.get_local_transform(entity);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="component-access"><a class="header" href="#component-access">Component Access</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.get_local_transform(entity) -&gt; Option&lt;&amp;LocalTransform&gt;
world.get_global_transform(entity) -&gt; Option&lt;&amp;GlobalTransform&gt;
world.get_render_mesh(entity) -&gt; Option&lt;&amp;RenderMesh&gt;
world.get_material_ref(entity) -&gt; Option&lt;&amp;MaterialRef&gt;
world.get_camera(entity) -&gt; Option&lt;&amp;Camera&gt;
world.get_rigid_body(entity) -&gt; Option&lt;&amp;RigidBodyComponent&gt;
world.get_collider(entity) -&gt; Option&lt;&amp;ColliderComponent&gt;
world.get_animation_player(entity) -&gt; Option&lt;&amp;AnimationPlayer&gt;
world.get_parent(entity) -&gt; Option&lt;&amp;Parent&gt;
world.get_visibility(entity) -&gt; Option&lt;&amp;Visibility&gt;

world.get_local_transform_mut(entity) -&gt; Option&lt;&amp;mut LocalTransform&gt;
world.get_rigid_body_mut(entity) -&gt; Option&lt;&amp;mut RigidBodyComponent&gt;

world.set_local_transform(entity, LocalTransform { ... })
world.set_light(entity, Light { ... })

set_material_with_textures(world, entity, Material { ... })
<span class="boring">}</span></code></pre></pre>
<h3 id="resources-3"><a class="header" href="#resources-3">Resources</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.window.timing.delta_time
world.resources.window.timing.frames_per_second
world.resources.window.timing.uptime_milliseconds
world.resources.input.keyboard
world.resources.input.mouse
world.resources.graphics.show_cursor
world.resources.active_camera
world.resources.graphics.ambient_light
world.resources.physics.gravity
<span class="boring">}</span></code></pre></pre>
<h2 id="component-flags-1"><a class="header" href="#component-flags-1">Component Flags</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ANIMATION_PLAYER
NAME
LOCAL_TRANSFORM
GLOBAL_TRANSFORM
LOCAL_TRANSFORM_DIRTY
PARENT
IGNORE_PARENT_SCALE
AUDIO_SOURCE
AUDIO_LISTENER
CAMERA
PAN_ORBIT_CAMERA
LIGHT
LINES
VISIBILITY
DECAL
RENDER_MESH
MATERIAL_REF
RENDER_LAYER
SPRITE
SPRITE_ANIMATOR
TEXT
HUD_TEXT
TEXT_CHARACTER_COLORS
TEXT_CHARACTER_BACKGROUND_COLORS
BOUNDING_VOLUME
HOVERED
ROTATION
CASTS_SHADOW
RIGID_BODY
COLLIDER
PHYSICS_MATERIAL
CHARACTER_CONTROLLER
PHYSICS_INTERPOLATION
INSTANCED_MESH
PARTICLE_EMITTER
PREFAB_SOURCE
PREFAB_INSTANCE
SCRIPT
SKIN
JOINT
MORPH_WEIGHTS
NAVMESH_AGENT
LATTICE
LATTICE_INFLUENCED
WATER
GRASS_REGION
GRASS_INTERACTOR
<span class="boring">}</span></code></pre></pre>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LocalTransform {
    translation: Vec3,
    rotation: nalgebra_glm::Quat,
    scale: Vec3,
}

LocalTransform::default()

LocalTransform {
    translation: Vec3::new(x, y, z),
    rotation: nalgebra_glm::quat_angle_axis(angle, &amp;axis),
    scale: Vec3::new(1.0, 1.0, 1.0),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Camera {
    projection: Projection,
    smoothing: Option&lt;Smoothing&gt;,
}

PerspectiveCamera {
    aspect_ratio: Option&lt;f32&gt;,
    y_fov_rad: f32,
    z_far: Option&lt;f32&gt;,
    z_near: f32,
}

OrthographicCamera {
    x_mag: f32,
    y_mag: f32,
    z_far: f32,
    z_near: f32,
}

spawn_camera(world, position: Vec3, name: String) -&gt; Entity
spawn_pan_orbit_camera(world, focus: Vec3, radius: f32, yaw: f32, pitch: f32, name: String) -&gt; Entity
spawn_ortho_camera(world, position: Vec2) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_cube_at(world, position: Vec3) -&gt; Entity
spawn_sphere_at(world, position: Vec3) -&gt; Entity
spawn_plane_at(world, position: Vec3) -&gt; Entity
spawn_cylinder_at(world, position: Vec3) -&gt; Entity
spawn_cone_at(world, position: Vec3) -&gt; Entity
spawn_torus_at(world, position: Vec3) -&gt; Entity
spawn_mesh_at(world, mesh_name: &amp;str, position: Vec3, scale: Vec3) -&gt; Entity
spawn_water_plane_at(world, position: Vec3) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="model-loading"><a class="header" href="#model-loading">Model Loading</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let prefab = import_gltf_from_bytes(world, model_data, "character").unwrap();
let entity = spawn_prefab_with_animations(world, &amp;prefab, Vec3::zeros());

for entity in entities {
    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.scale = Vec3::new(0.01, 0.01, 0.01);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="materials-1"><a class="header" href="#materials-1">Materials</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Material {
    base_color: [f32; 4],
    emissive_factor: [f32; 3],
    alpha_mode: AlphaMode,
    alpha_cutoff: f32,
    base_texture: Option&lt;String&gt;,
    base_texture_uv_set: u32,
    emissive_texture: Option&lt;String&gt;,
    emissive_texture_uv_set: u32,
    normal_texture: Option&lt;String&gt;,
    normal_texture_uv_set: u32,
    normal_scale: f32,
    normal_map_flip_y: bool,
    normal_map_two_component: bool,
    metallic_roughness_texture: Option&lt;String&gt;,
    metallic_roughness_texture_uv_set: u32,
    occlusion_texture: Option&lt;String&gt;,
    occlusion_texture_uv_set: u32,
    occlusion_strength: f32,
    roughness: f32,
    metallic: f32,
    unlit: bool,
    double_sided: bool,
    uv_scale: [f32; 2],
    transmission_factor: f32,
    transmission_texture: Option&lt;String&gt;,
    transmission_texture_uv_set: u32,
    thickness: f32,
    thickness_texture: Option&lt;String&gt;,
    thickness_texture_uv_set: u32,
    attenuation_color: [f32; 3],
    attenuation_distance: f32,
    ior: f32,
    specular_factor: f32,
    specular_color_factor: [f32; 3],
    specular_texture: Option&lt;String&gt;,
    specular_texture_uv_set: u32,
    specular_color_texture: Option&lt;String&gt;,
    specular_color_texture_uv_set: u32,
    emissive_strength: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lighting-2"><a class="header" href="#lighting-2">Lighting</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_sun(world) -&gt; Entity
spawn_sun_without_shadows(world) -&gt; Entity

Light {
    light_type: LightType,
    color: Vec3,
    intensity: f32,
    range: f32,
    inner_cone_angle: f32,
    outer_cone_angle: f32,
    cast_shadows: bool,
    shadow_bias: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-2"><a class="header" href="#physics-2">Physics</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.physics.add_rigid_body(rigid_body: RigidBody) -&gt; RigidBodyHandle
world.resources.physics.add_collider(collider, parent) -&gt; ColliderHandle

RigidBodyComponent::new_dynamic()
RigidBodyComponent::new_static()

ColliderComponent::cuboid(hx: f32, hy: f32, hz: f32)

run_physics_systems(world)
sync_transforms_from_physics_system(world)
sync_transforms_to_physics_system(world)
initialize_physics_bodies_system(world)
physics_interpolation_system(world)
character_controller_system(world)
character_controller_input_system(world)
<span class="boring">}</span></code></pre></pre>
<h3 id="joints-1"><a class="header" href="#joints-1">Joints</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_fixed_joint(world, body1, anchor1, body2, anchor2)
create_revolute_joint(world, body1, anchor1, body2, anchor2, axis)
create_prismatic_joint(world, body1, anchor1, body2, anchor2, axis)
create_spherical_joint(world, body1, anchor1, body2, anchor2)
create_rope_joint(world, body1, anchor1, body2, anchor2, max_distance)
create_spring_joint(world, body1, anchor1, body2, anchor2, rest_length, stiffness, damping)
<span class="boring">}</span></code></pre></pre>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(player) = world.get_animation_player_mut(entity) {
    player.play(clip_index);
    player.blend_to(clip_index, duration);
    player.stop();
    player.pause();
    player.resume();
    player.looping = true;
    player.speed = 1.0;
    player.time = 0.0;
    player.playing
    player.current_clip
}

update_animation_players(world, dt: f32)
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-2"><a class="header" href="#audio-2">Audio</a></h2>
<p>Requires the <code>audio</code> feature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sound_data = load_sound_from_bytes(include_bytes!("sound.ogg")).unwrap();
let sound_data = load_sound_from_file("path/to/sound.wav").unwrap();
let sound_data = load_sound_from_cursor(data).unwrap();

world.resources.audio.load_sound("name", sound_data);

world.resources.audio.stop_sound(entity);

let source = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];
world.set_audio_source(source, AudioSource::new(sound_data).with_spatial(true));
<span class="boring">}</span></code></pre></pre>
<h2 id="input-3"><a class="header" href="#input-3">Input</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.input.keyboard.is_key_pressed(KeyCode::KeyW) -&gt; bool

world.resources.input.mouse.position -&gt; Vec2
world.resources.input.mouse.position_delta -&gt; Vec2
world.resources.input.mouse.wheel_delta -&gt; Vec2
world.resources.input.mouse.state.contains(MouseState::LEFT_CLICKED) -&gt; bool
world.resources.input.mouse.state.contains(MouseState::RIGHT_CLICKED) -&gt; bool
world.resources.input.mouse.state.contains(MouseState::LEFT_JUST_PRESSED) -&gt; bool

world.resources.graphics.show_cursor = false;

query_active_gamepad(world) -&gt; Option&lt;gilrs::Gamepad&lt;'_&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<h2 id="hud-text-1"><a class="header" href="#hud-text-1">HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_hud_text(world, text: impl Into&lt;String&gt;, anchor: HudAnchor, position: Vec2) -&gt; Entity
spawn_hud_text_with_properties(world, text: impl Into&lt;String&gt;, anchor: HudAnchor, position: Vec2, properties: TextProperties) -&gt; Entity

TextProperties {
    font_size: f32,
    color: Vec4,
    alignment: TextAlignment,
    vertical_alignment: VerticalAlignment,
    line_height: f32,
    letter_spacing: f32,
    outline_width: f32,
    outline_color: Vec4,
    smoothing: f32,
    monospace_width: Option&lt;f32&gt;,
    anchor_character: Option&lt;usize&gt;,
}

HudAnchor::TopLeft | TopCenter | TopRight
HudAnchor::CenterLeft | Center | CenterRight
HudAnchor::BottomLeft | BottomCenter | BottomRight
<span class="boring">}</span></code></pre></pre>
<h2 id="particles"><a class="header" href="#particles">Particles</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParticleEmitter {
    emitter_type: EmitterType,
    shape: EmitterShape,
    position: Vec3,
    direction: Vec3,
    spawn_rate: f32,
    burst_count: u32,
    particle_lifetime_min: f32,
    particle_lifetime_max: f32,
    initial_velocity_min: f32,
    initial_velocity_max: f32,
    velocity_spread: f32,
    gravity: Vec3,
    drag: f32,
    size_start: f32,
    size_end: f32,
    color_gradient: ColorGradient,
    emissive_strength: f32,
    turbulence_strength: f32,
    turbulence_frequency: f32,
    enabled: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<p>Requires the <code>navmesh</code> feature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>generate_navmesh_recast(vertices: &amp;[[f32; 3]], indices: &amp;[[u32; 3]], config: &amp;RecastNavMeshConfig) -&gt; Option&lt;NavMeshWorld&gt;

spawn_navmesh_agent(world, position: Vec3, radius: f32, height: f32) -&gt; Entity
set_agent_destination(world, entity: Entity, destination: Vec3)
set_agent_speed(world, entity: Entity, speed: f32)
stop_agent(world, entity: Entity)
get_agent_state(world, entity: Entity) -&gt; Option&lt;NavMeshAgentState&gt;
get_agent_path_length(world, entity: Entity) -&gt; Option&lt;f32&gt;

find_closest_point_on_navmesh(navmesh: &amp;NavMeshWorld, point: Vec3) -&gt; Option&lt;Vec3&gt;
sample_navmesh_height(navmesh: &amp;NavMeshWorld, x: f32, z: f32) -&gt; Option&lt;f32&gt;
set_navmesh_debug_draw(world, enabled: bool)
clear_navmesh(world)

run_navmesh_systems(world, delta_time: f32)
<span class="boring">}</span></code></pre></pre>
<h2 id="math-nalgebra_glm"><a class="header" href="#math-nalgebra_glm">Math (nalgebra_glm)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Vec2::new(x, y)
Vec3::new(x, y, z)
Vec4::new(x, y, z, w)
Vec3::zeros()
Vec3::x()
Vec3::y()
Vec3::z()

vec.normalize()
vec.magnitude()
vec.dot(&amp;other)
vec.cross(&amp;other)

nalgebra_glm::quat_identity()
nalgebra_glm::quat_angle_axis(angle: f32, axis: &amp;Vec3) -&gt; Quat
nalgebra_glm::quat_slerp(from: &amp;Quat, to: &amp;Quat, t: f32) -&gt; Quat

nalgebra_glm::lerp(from: &amp;Vec3, to: &amp;Vec3, t: f32) -&gt; Vec3
<span class="boring">}</span></code></pre></pre>
<h2 id="state-trait"><a class="header" href="#state-trait">State Trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait State {
    fn title(&amp;self) -&gt; &amp;str { "Nightshade" }
    fn icon_bytes(&amp;self) -&gt; Option&lt;&amp;'static [u8]&gt; { ... }
    fn initialize(&amp;mut self, world: &amp;mut World) {}
    fn run_systems(&amp;mut self, world: &amp;mut World) {}
    fn ui(&amp;mut self, world: &amp;mut World, ctx: &amp;egui::Context) {}
    fn secondary_ui(&amp;mut self, world: &amp;mut World, window_index: usize, ctx: &amp;egui::Context) {}
    fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {}
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key_code: KeyCode, key_state: ElementState) {}
    fn on_mouse_input(&amp;mut self, world: &amp;mut World, state: ElementState, button: MouseButton) {}
    fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {}
    fn handle_event(&amp;mut self, world: &amp;mut World, message: &amp;Message) {}
    fn on_dropped_file(&amp;mut self, world: &amp;mut World, path: &amp;Path) {}
    fn on_dropped_file_data(&amp;mut self, world: &amp;mut World, name: &amp;str, data: &amp;[u8]) {}
    fn on_hovered_file(&amp;mut self, world: &amp;mut World, path: &amp;Path) {}
    fn on_hovered_file_cancelled(&amp;mut self, world: &amp;mut World) {}
    fn configure_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, device: &amp;wgpu::Device, surface_format: wgpu::TextureFormat, resources: RenderResources) {}
    fn update_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, world: &amp;World) {}
    fn pre_render(&amp;mut self, renderer: &amp;mut dyn Render, world: &amp;mut World) {}
    fn next_state(&amp;mut self, world: &amp;mut World) -&gt; Option&lt;Box&lt;dyn State&gt;&gt; { None }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-analyzer-fft-feature"><a class="header" href="#audio-analyzer-fft-feature">Audio Analyzer (fft feature)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut analyzer = AudioAnalyzer::new();
analyzer.load_samples(samples, sample_rate);

analyzer.analyze_at_time(time_seconds);

analyzer.sub_bass
analyzer.bass
analyzer.low_mids
analyzer.mids
analyzer.high_mids
analyzer.highs

analyzer.smoothed_bass
analyzer.smoothed_mids

analyzer.onset_detected
analyzer.kick_decay
analyzer.snare_decay
analyzer.hat_decay

analyzer.estimated_bpm
analyzer.beat_phase
analyzer.beat_confidence

analyzer.is_building
analyzer.is_dropping
analyzer.is_breakdown
analyzer.build_intensity
analyzer.drop_intensity

analyzer.spectral_centroid
analyzer.spectral_flatness
analyzer.spectral_flux
analyzer.intensity
<span class="boring">}</span></code></pre></pre>
<h2 id="effects-pass-2"><a class="header" href="#effects-pass-2">Effects Pass</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::wgpu::passes::postprocess::effects::*;

let effects_state = create_effects_state();

if let Ok(mut state) = effects_state.write() {
    state.uniforms.chromatic_aberration = 0.02;
    state.uniforms.vignette = 0.3;
    state.uniforms.glitch_intensity = 0.5;
    state.uniforms.wave_distortion = 0.2;
    state.uniforms.crt_scanlines = 0.3;
    state.uniforms.film_grain = 0.1;
    state.uniforms.hue_rotation = 0.5;
    state.uniforms.saturation = 1.2;
    state.uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
    state.uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
    state.uniforms.raymarch_blend = 0.5;
    state.enabled = true;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-lines"><a class="header" href="#debug-lines">Debug Lines</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lines_entity = world.spawn_entities(LOCAL_TRANSFORM | LINES, 1)[0];

world.set_lines(lines_entity, Lines {
    lines: vec![
        Line { start: Vec3::zeros(), end: Vec3::new(1.0, 0.0, 0.0), color: Vec4::new(1.0, 0.0, 0.0, 1.0) },
        Line { start: Vec3::zeros(), end: Vec3::new(0.0, 1.0, 0.0), color: Vec4::new(0.0, 1.0, 0.0, 1.0) },
        Line { start: Vec3::zeros(), end: Vec3::new(0.0, 0.0, 1.0), color: Vec4::new(0.0, 0.0, 1.0, 1.0) },
    ],
    version: 0,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="world-commands-3"><a class="header" href="#world-commands-3">World Commands</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.queue_command(WorldCommand::LoadTexture {
    name: "my_texture".to_string(),
    rgba_data: texture_bytes,
    width: 256,
    height: 256,
});

world.queue_command(WorldCommand::DespawnRecursive { entity });
world.queue_command(WorldCommand::LoadHdrSkybox { hdr_data });
world.queue_command(WorldCommand::CaptureScreenshot { path: None });

despawn_recursive_immediate(world, entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="running-1"><a class="header" href="#running-1">Running</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    nightshade::launch(MyGame::default())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<p>Quick recipes organized by what you want to accomplish. Each recipe is self-contained and uses real Nightshade API patterns.</p>
<h2 id="i-want-to-move-things"><a class="header" href="#i-want-to-move-things">I Want To... Move Things</a></h2>
<h3 id="move-a-player-with-wasd"><a class="header" href="#move-a-player-with-wasd">Move a player with WASD</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_movement(world: &amp;mut World, player: Entity, speed: f32) {
    let dt = world.resources.window.timing.delta_time;
    let keyboard = &amp;world.resources.input.keyboard;

    let mut direction = Vec3::zeros();

    if keyboard.is_key_pressed(KeyCode::KeyW) { direction.z -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { direction.z += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { direction.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { direction.x += 1.0; }

    if direction.magnitude() &gt; 0.0 {
        direction = direction.normalize();

        if let Some(transform) = world.get_local_transform_mut(player) {
            transform.translation += direction * speed * dt;
        }
        mark_local_transform_dirty(world, player);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="move-a-player-relative-to-the-camera"><a class="header" href="#move-a-player-relative-to-the-camera">Move a player relative to the camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn camera_relative_movement(
    world: &amp;mut World,
    player: Entity,
    camera: Entity,
    speed: f32,
) {
    let dt = world.resources.window.timing.delta_time;
    let keyboard = &amp;world.resources.input.keyboard;

    let mut input = Vec2::zeros();
    if keyboard.is_key_pressed(KeyCode::KeyW) { input.y -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { input.y += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { input.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { input.x += 1.0; }

    if input.magnitude() &lt; 0.01 {
        return;
    }
    input = input.normalize();

    let Some(camera_transform) = world.get_global_transform(camera) else { return };
    let forward = camera_transform.forward_vector();
    let forward_flat = Vec3::new(forward.x, 0.0, forward.z).normalize();
    let right_flat = Vec3::new(forward.z, 0.0, -forward.x).normalize();

    let world_direction = forward_flat * -input.y + right_flat * input.x;

    if let Some(transform) = world.get_local_transform_mut(player) {
        transform.translation += world_direction * speed * dt;

        let target_yaw = world_direction.x.atan2(world_direction.z);
        let target_rotation = nalgebra_glm::quat_angle_axis(target_yaw, &amp;Vec3::y());
        transform.rotation = nalgebra_glm::quat_slerp(
            &amp;transform.rotation,
            &amp;target_rotation,
            dt * 10.0,
        );
    }
    mark_local_transform_dirty(world, player);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-jumping-with-gravity"><a class="header" href="#add-jumping-with-gravity">Add jumping with gravity</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JumpState {
    velocity_y: f32,
    grounded: bool,
}

fn handle_jumping(
    world: &amp;mut World,
    player: Entity,
    state: &amp;mut JumpState,
    jump_force: f32,
    gravity: f32,
) {
    let dt = world.resources.window.timing.delta_time;

    if state.grounded &amp;&amp; world.resources.input.keyboard.is_key_pressed(KeyCode::Space) {
        state.velocity_y = jump_force;
        state.grounded = false;
    }

    if !state.grounded {
        state.velocity_y -= gravity * dt;
    }

    if let Some(transform) = world.get_local_transform_mut(player) {
        transform.translation.y += state.velocity_y * dt;

        if transform.translation.y &lt;= 0.0 {
            transform.translation.y = 0.0;
            state.velocity_y = 0.0;
            state.grounded = true;
        }
    }
    mark_local_transform_dirty(world, player);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="make-an-object-bob-up-and-down"><a class="header" href="#make-an-object-bob-up-and-down">Make an object bob up and down</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bob_system(world: &amp;mut World, entity: Entity, time: f32, amplitude: f32, frequency: f32) {
    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.translation.y = 1.0 + (time * frequency).sin() * amplitude;
    }
    mark_local_transform_dirty(world, entity);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rotate-an-object-continuously"><a class="header" href="#rotate-an-object-continuously">Rotate an object continuously</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spin_system(world: &amp;mut World, entity: Entity, time: f32) {
    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.rotation = nalgebra_glm::quat_angle_axis(time, &amp;Vec3::y());
    }
    mark_local_transform_dirty(world, entity);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-set-up-cameras"><a class="header" href="#i-want-to-set-up-cameras">I Want To... Set Up Cameras</a></h2>
<h3 id="make-a-first-person-camera"><a class="header" href="#make-a-first-person-camera">Make a first-person camera</a></h3>
<p>Horizontal yaw on the player body, vertical pitch on the camera. The camera is parented to the player so it follows automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_fps_camera(world: &amp;mut World, player: Entity) -&gt; Entity {
    let camera = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PARENT,
        1,
    )[0];

    world.set_local_transform(camera, LocalTransform {
        translation: Vec3::new(0.0, 0.7, 0.0),
        ..Default::default()
    });
    world.set_camera(camera, Camera::default());
    world.set_parent(camera, Parent(Some(player)));
    world.resources.active_camera = Some(camera);

    camera
}

fn fps_look(world: &amp;mut World, player: Entity, camera: Entity) {
    let mouse_delta = world.resources.input.mouse.position_delta;
    let sensitivity = 0.002;

    if let Some(transform) = world.get_local_transform_mut(player) {
        let yaw = nalgebra_glm::quat_angle_axis(-mouse_delta.x * sensitivity, &amp;Vec3::y());
        transform.rotation = yaw * transform.rotation;
    }
    mark_local_transform_dirty(world, player);

    if let Some(transform) = world.get_local_transform_mut(camera) {
        let pitch = nalgebra_glm::quat_angle_axis(-mouse_delta.y * sensitivity, &amp;Vec3::x());
        transform.rotation = transform.rotation * pitch;
    }
    mark_local_transform_dirty(world, camera);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="make-a-third-person-orbit-camera"><a class="header" href="#make-a-third-person-orbit-camera">Make a third-person orbit camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OrbitCamera {
    target: Entity,
    distance: f32,
    yaw: f32,
    pitch: f32,
}

fn orbit_camera_system(world: &amp;mut World, camera: Entity, orbit: &amp;mut OrbitCamera) {
    let mouse_delta = world.resources.input.mouse.position_delta;
    let scroll = world.resources.input.mouse.wheel_delta;

    orbit.yaw -= mouse_delta.x * 0.003;
    orbit.pitch -= mouse_delta.y * 0.003;
    orbit.pitch = orbit.pitch.clamp(-1.4, 1.4);
    orbit.distance = (orbit.distance - scroll.y * 0.5).clamp(2.0, 20.0);

    let Some(target_transform) = world.get_global_transform(orbit.target) else { return };
    let target_pos = target_transform.translation() + Vec3::new(0.0, 1.5, 0.0);

    let offset = Vec3::new(
        orbit.yaw.sin() * orbit.pitch.cos(),
        orbit.pitch.sin(),
        orbit.yaw.cos() * orbit.pitch.cos(),
    ) * orbit.distance;

    let camera_pos = target_pos + offset;

    if let Some(transform) = world.get_local_transform_mut(camera) {
        transform.translation = camera_pos;

        let direction = (target_pos - camera_pos).normalize();
        let pitch = (-direction.y).asin();
        let yaw = direction.x.atan2(direction.z);

        transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
            * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
    }
    mark_local_transform_dirty(world, camera);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="make-a-smooth-follow-camera"><a class="header" href="#make-a-smooth-follow-camera">Make a smooth follow camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn follow_camera(
    world: &amp;mut World,
    target: Entity,
    camera: Entity,
    offset: Vec3,
    smoothness: f32,
) {
    let dt = world.resources.window.timing.delta_time;

    let Some(target_transform) = world.get_global_transform(target) else { return };
    let target_pos = target_transform.translation() + offset;

    if let Some(cam_transform) = world.get_local_transform_mut(camera) {
        cam_transform.translation = nalgebra_glm::lerp(
            &amp;cam_transform.translation,
            &amp;target_pos,
            dt * smoothness,
        );

        let look_at = target_transform.translation();
        let direction = (look_at - cam_transform.translation).normalize();
        let pitch = (-direction.y).asin();
        let yaw = direction.x.atan2(direction.z);

        cam_transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
            * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
    }
    mark_local_transform_dirty(world, camera);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-spawn-objects"><a class="header" href="#i-want-to-spawn-objects">I Want To... Spawn Objects</a></h2>
<h3 id="spawn-a-colored-cube"><a class="header" href="#spawn-a-colored-cube">Spawn a colored cube</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_colored_cube(world: &amp;mut World, position: Vec3, color: [f32; 4]) -&gt; Entity {
    let cube = spawn_cube_at(world, position);

    material_registry_insert(
        &amp;mut world.resources.material_registry,
        format!("cube_{}", cube.id),
        Material {
            base_color: color,
            ..Default::default()
        },
    );

    let material_name = format!("cube_{}", cube.id);
    if let Some(&amp;index) = world.resources.material_registry.registry.name_to_index.get(&amp;material_name) {
        world.resources.material_registry.registry.add_reference(index);
    }
    world.set_material_ref(cube, MaterialRef::new(material_name));

    cube
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spawn-objects-at-random-positions"><a class="header" href="#spawn-objects-at-random-positions">Spawn objects at random positions</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn random_position_in_box(center: Vec3, half_extents: Vec3) -&gt; Vec3 {
    Vec3::new(
        center.x + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.x,
        center.y + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.y,
        center.z + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.z,
    )
}

fn random_position_on_circle(center: Vec3, radius: f32) -&gt; Vec3 {
    let angle = rand::random::&lt;f32&gt;() * std::f32::consts::TAU;
    Vec3::new(
        center.x + angle.cos() * radius,
        center.y,
        center.z + angle.sin() * radius,
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spawn-a-physics-object-that-falls"><a class="header" href="#spawn-a-physics-object-that-falls">Spawn a physics object that falls</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_physics_cube(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let cube = spawn_cube_at(world, position);
    add_rigid_body(world, cube, RigidBodyType::Dynamic, 1.0);
    add_collider(world, cube, ColliderShape::Cuboid {
        half_extents: Vec3::new(0.5, 0.5, 0.5),
    });
    cube
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spawn-a-wave-of-enemies-at-intervals"><a class="header" href="#spawn-a-wave-of-enemies-at-intervals">Spawn a wave of enemies at intervals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WaveSpawner {
    wave: u32,
    enemies_remaining: u32,
    spawn_timer: f32,
    spawn_interval: f32,
}

impl WaveSpawner {
    fn update(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.enemies_remaining == 0 {
            self.wave += 1;
            self.enemies_remaining = 5 + self.wave * 2;
            self.spawn_interval = (2.0 - self.wave as f32 * 0.1).max(0.3);
            return;
        }

        self.spawn_timer -= dt;
        if self.spawn_timer &lt;= 0.0 {
            let position = random_position_on_circle(Vec3::zeros(), 20.0);
            spawn_cube_at(world, position);
            self.enemies_remaining -= 1;
            self.spawn_timer = self.spawn_interval;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="load-a-3d-model"><a class="header" href="#load-a-3d-model">Load a 3D model</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let entities = load_gltf(world, "assets/models/character.glb");
    let root = entities[0];

    world.set_local_transform(root, LocalTransform {
        translation: Vec3::new(0.0, 0.0, 0.0),
        scale: Vec3::new(1.0, 1.0, 1.0),
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-use-physics"><a class="header" href="#i-want-to-use-physics">I Want To... Use Physics</a></h2>
<h3 id="apply-an-explosion-force"><a class="header" href="#apply-an-explosion-force">Apply an explosion force</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn explosion(world: &amp;mut World, center: Vec3, radius: f32, force: f32) {
    for entity in world.query_entities(RIGID_BODY | GLOBAL_TRANSFORM) {
        let Some(transform) = world.get_global_transform(entity) else { continue };
        let to_entity = transform.translation() - center;
        let distance = to_entity.magnitude();

        if distance &lt; radius &amp;&amp; distance &gt; 0.1 {
            let falloff = 1.0 - (distance / radius);
            let impulse = to_entity.normalize() * force * falloff;

            if let Some(body) = world.get_rigid_body_mut(entity) {
                body.linvel = [
                    body.linvel[0] + impulse.x,
                    body.linvel[1] + impulse.y,
                    body.linvel[2] + impulse.z,
                ];
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="raycast-from-the-camera"><a class="header" href="#raycast-from-the-camera">Raycast from the camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shoot_from_camera(world: &amp;mut World) {
    let Some(camera) = world.resources.active_camera else { return };
    let Some(transform) = world.get_global_transform(camera) else { return };

    let origin = transform.translation();
    let direction = transform.forward_vector();

    if let Some(hit) = raycast(world, origin, direction, 100.0) {
        let hit_position = hit.position;
        let hit_normal = hit.normal;
        let hit_entity = hit.entity;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="grab-and-throw-objects"><a class="header" href="#grab-and-throw-objects">Grab and throw objects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GrabState {
    entity: Option&lt;Entity&gt;,
    distance: f32,
}

fn grab_object(world: &amp;mut World, state: &amp;mut GrabState) {
    let Some(camera) = world.resources.active_camera else { return };
    let Some(transform) = world.get_global_transform(camera) else { return };

    if let Some(hit) = raycast(world, transform.translation(), transform.forward_vector(), 20.0) {
        if world.get_rigid_body(hit.entity).is_some() {
            state.entity = Some(hit.entity);
            state.distance = hit.distance;

            if let Some(body) = world.get_rigid_body_mut(hit.entity) {
                body.linear_damping = 10.0;
                body.angular_damping = 10.0;
            }
        }
    }
}

fn update_held_object(world: &amp;mut World, state: &amp;GrabState) {
    let Some(entity) = state.entity else { return };
    let Some(camera) = world.resources.active_camera else { return };
    let Some(camera_transform) = world.get_global_transform(camera) else { return };

    let target = camera_transform.translation() +
        camera_transform.forward_vector() * state.distance;

    if let Some(transform) = world.get_local_transform(entity) {
        let to_target = target - transform.translation;
        if let Some(body) = world.get_rigid_body_mut(entity) {
            body.linvel = [to_target.x * 20.0, to_target.y * 20.0, to_target.z * 20.0];
        }
    }
}

fn throw_object(world: &amp;mut World, state: &amp;mut GrabState) {
    if let Some(entity) = state.entity.take() {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };
        let direction = transform.forward_vector();

        if let Some(body) = world.get_rigid_body_mut(entity) {
            body.linear_damping = 0.0;
            body.angular_damping = 0.0;
            body.linvel = [direction.x * 20.0, direction.y * 20.0, direction.z * 20.0];
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-create-materials"><a class="header" href="#i-want-to-create-materials">I Want To... Create Materials</a></h2>
<h3 id="make-a-glowing-emissive-material"><a class="header" href="#make-a-glowing-emissive-material">Make a glowing emissive material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let neon = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [0.2, 0.8, 1.0],
    emissive_strength: 10.0,
    roughness: 0.8,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="make-glass"><a class="header" href="#make-glass">Make glass</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glass = Material {
    base_color: [0.95, 0.95, 1.0, 1.0],
    roughness: 0.05,
    metallic: 0.0,
    transmission_factor: 0.95,
    ior: 1.5,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="make-a-metallic-surface"><a class="header" href="#make-a-metallic-surface">Make a metallic surface</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let gold = Material {
    base_color: [1.0, 0.84, 0.0, 1.0],
    roughness: 0.3,
    metallic: 1.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="make-a-transparent-ghost-like-material"><a class="header" href="#make-a-transparent-ghost-like-material">Make a transparent ghost-like material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ghost = Material {
    base_color: [0.9, 0.95, 1.0, 0.3],
    alpha_mode: AlphaMode::Blend,
    roughness: 0.1,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-show-ui"><a class="header" href="#i-want-to-show-ui">I Want To... Show UI</a></h2>
<h3 id="display-an-fps-counter"><a class="header" href="#display-an-fps-counter">Display an FPS counter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FpsCounter {
    samples: Vec&lt;f32&gt;,
    text_entity: Entity,
}

impl FpsCounter {
    fn update(&amp;mut self, world: &amp;mut World) {
        let fps = world.resources.window.timing.frames_per_second;
        self.samples.push(fps);

        if self.samples.len() &gt; 60 {
            self.samples.remove(0);
        }

        let avg: f32 = self.samples.iter().sum::&lt;f32&gt;() / self.samples.len() as f32;

        if let Some(text) = world.get_hud_text_mut(self.text_entity) {
            text.text = format!("FPS: {:.0}", avg);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="display-a-health-bar-as-hud-text"><a class="header" href="#display-a-health-bar-as-hud-text">Display a health bar as HUD text</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_health_bar(world: &amp;mut World, text_entity: Entity, current: f32, max: f32) {
    let bar_length = 20;
    let filled = ((current / max) * bar_length as f32) as usize;

    let bar = format!(
        "[{}{}] {}/{}",
        "|".repeat(filled.min(bar_length)),
        ".".repeat(bar_length - filled.min(bar_length)),
        current as u32,
        max as u32,
    );

    if let Some(text) = world.get_hud_text_mut(text_entity) {
        text.text = bar;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="show-a-scoreboard-with-egui"><a class="header" href="#show-a-scoreboard-with-egui">Show a scoreboard with egui</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, _world: &amp;mut World, ctx: &amp;egui::Context) {
    egui::Window::new("Score")
        .anchor(egui::Align2::CENTER_TOP, [0.0, 10.0])
        .resizable(false)
        .collapsible(false)
        .title_bar(false)
        .show(ctx, |ui| {
            ui.heading(format!("{} - {}", self.left_score, self.right_score));
        });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-handle-game-states"><a class="header" href="#i-want-to-handle-game-states">I Want To... Handle Game States</a></h2>
<h3 id="pause-the-game"><a class="header" href="#pause-the-game">Pause the game</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
    if state == KeyState::Pressed &amp;&amp; key == KeyCode::Escape {
        self.paused = !self.paused;
        world.resources.graphics.show_cursor = self.paused;
    }
}

fn run_systems(&amp;mut self, world: &amp;mut World) {
    if self.paused {
        return;
    }

    self.update_game_logic(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="build-a-state-machine-for-player-actions"><a class="header" href="#build-a-state-machine-for-player-actions">Build a state machine for player actions</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq)]
enum PlayerAction {
    Idle,
    Walking,
    Running,
    Attacking,
    Dodging,
}

struct ActionState {
    current: PlayerAction,
    timer: f32,
}

impl ActionState {
    fn transition(&amp;mut self, new_state: PlayerAction) {
        if self.current != new_state {
            self.current = new_state;
            self.timer = 0.0;
        }
    }

    fn update(&amp;mut self, dt: f32) {
        self.timer += dt;
    }

    fn can_interrupt(&amp;self) -&gt; bool {
        match self.current {
            PlayerAction::Attacking =&gt; self.timer &gt; 0.5,
            PlayerAction::Dodging =&gt; self.timer &gt; 0.3,
            _ =&gt; true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-use-timers"><a class="header" href="#i-want-to-use-timers">I Want To... Use Timers</a></h2>
<h3 id="cooldown-timer"><a class="header" href="#cooldown-timer">Cooldown timer</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cooldown {
    duration: f32,
    remaining: f32,
}

impl Cooldown {
    fn new(duration: f32) -&gt; Self {
        Self { duration, remaining: 0.0 }
    }

    fn update(&amp;mut self, dt: f32) {
        self.remaining = (self.remaining - dt).max(0.0);
    }

    fn ready(&amp;self) -&gt; bool {
        self.remaining &lt;= 0.0
    }

    fn trigger(&amp;mut self) {
        self.remaining = self.duration;
    }

    fn progress(&amp;self) -&gt; f32 {
        1.0 - (self.remaining / self.duration)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="repeating-timer"><a class="header" href="#repeating-timer">Repeating timer</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RepeatingTimer {
    interval: f32,
    elapsed: f32,
}

impl RepeatingTimer {
    fn new(interval: f32) -&gt; Self {
        Self { interval, elapsed: 0.0 }
    }

    fn tick(&amp;mut self, dt: f32) -&gt; bool {
        self.elapsed += dt;

        if self.elapsed &gt;= self.interval {
            self.elapsed -= self.interval;
            true
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-debug-things"><a class="header" href="#i-want-to-debug-things">I Want To... Debug Things</a></h2>
<h3 id="draw-wireframe-collision-boxes"><a class="header" href="#draw-wireframe-collision-boxes">Draw wireframe collision boxes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_draw_boxes(
    world: &amp;mut World,
    lines_entity: Entity,
    entities: &amp;[Entity],
    half_extents: Vec3,
) {
    let mut lines = vec![];

    for &amp;entity in entities {
        let Some(transform) = world.get_global_transform(entity) else { continue };
        let pos = transform.translation();
        let color = Vec4::new(0.0, 1.0, 0.0, 1.0);
        let half = half_extents;

        let corners = [
            pos + Vec3::new(-half.x, -half.y, -half.z),
            pos + Vec3::new( half.x, -half.y, -half.z),
            pos + Vec3::new( half.x, -half.y,  half.z),
            pos + Vec3::new(-half.x, -half.y,  half.z),
            pos + Vec3::new(-half.x,  half.y, -half.z),
            pos + Vec3::new( half.x,  half.y, -half.z),
            pos + Vec3::new( half.x,  half.y,  half.z),
            pos + Vec3::new(-half.x,  half.y,  half.z),
        ];

        let edges = [
            (0,1), (1,2), (2,3), (3,0),
            (4,5), (5,6), (6,7), (7,4),
            (0,4), (1,5), (2,6), (3,7),
        ];

        for (a, b) in edges {
            lines.push(Line { start: corners[a], end: corners[b], color });
        }
    }

    world.set_lines(lines_entity, Lines { lines, version: 0 });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-save-and-load"><a class="header" href="#i-want-to-save-and-load">I Want To... Save and Load</a></h2>
<h3 id="save-game-state-to-json"><a class="header" href="#save-game-state-to-json">Save game state to JSON</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct SaveData {
    player_position: [f32; 3],
    player_health: f32,
    score: u32,
    level: u32,
}

fn save_game(data: &amp;SaveData, path: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    let json = serde_json::to_string_pretty(data)?;
    std::fs::write(path, json)?;
    Ok(())
}

fn load_game(path: &amp;str) -&gt; std::io::Result&lt;SaveData&gt; {
    let json = std::fs::read_to_string(path)?;
    let data: SaveData = serde_json::from_str(&amp;json)?;
    Ok(data)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-play-audio"><a class="header" href="#i-want-to-play-audio">I Want To... Play Audio</a></h2>
<h3 id="footstep-sounds-while-moving"><a class="header" href="#footstep-sounds-while-moving">Footstep sounds while moving</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FootstepSystem {
    timer: f32,
    interval: f32,
    sounds: Vec&lt;String&gt;,
    last_index: usize,
}

impl FootstepSystem {
    fn update(&amp;mut self, world: &amp;mut World, is_moving: bool, is_running: bool, dt: f32) {
        if !is_moving {
            self.timer = 0.0;
            return;
        }

        let interval = if is_running { self.interval * 0.6 } else { self.interval };
        self.timer += dt;

        if self.timer &gt;= interval {
            self.timer = 0.0;

            let mut index = rand::random::&lt;usize&gt;() % self.sounds.len();
            if index == self.last_index &amp;&amp; self.sounds.len() &gt; 1 {
                index = (index + 1) % self.sounds.len();
            }
            self.last_index = index;

            play_sound(world, &amp;self.sounds[index]);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-pool-entities"><a class="header" href="#i-want-to-pool-entities">I Want To... Pool Entities</a></h2>
<h3 id="reuse-entities-instead-of-spawningdespawning"><a class="header" href="#reuse-entities-instead-of-spawningdespawning">Reuse entities instead of spawning/despawning</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EntityPool {
    available: Vec&lt;Entity&gt;,
    active: Vec&lt;Entity&gt;,
    spawn_fn: fn(&amp;mut World) -&gt; Entity,
}

impl EntityPool {
    fn new(world: &amp;mut World, initial_size: usize, spawn_fn: fn(&amp;mut World) -&gt; Entity) -&gt; Self {
        let mut available = Vec::with_capacity(initial_size);

        for _ in 0..initial_size {
            let entity = spawn_fn(world);
            world.set_visibility(entity, Visibility { visible: false });
            available.push(entity);
        }

        Self { available, active: Vec::new(), spawn_fn }
    }

    fn acquire(&amp;mut self, world: &amp;mut World) -&gt; Entity {
        let entity = self.available.pop().unwrap_or_else(|| (self.spawn_fn)(world));
        world.set_visibility(entity, Visibility { visible: true });
        self.active.push(entity);
        entity
    }

    fn release(&amp;mut self, world: &amp;mut World, entity: Entity) {
        if let Some(index) = self.active.iter().position(|&amp;entity_in_pool| entity_in_pool == entity) {
            self.active.swap_remove(index);
            world.set_visibility(entity, Visibility { visible: false });
            self.available.push(entity);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="i-want-to-attach-things-to-other-things"><a class="header" href="#i-want-to-attach-things-to-other-things">I Want To... Attach Things to Other Things</a></h2>
<h3 id="parent-an-object-to-another-entity"><a class="header" href="#parent-an-object-to-another-entity">Parent an object to another entity</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(child, Parent(Some(parent)));
<span class="boring">}</span></code></pre></pre>
<p>The child's <code>LocalTransform</code> becomes relative to the parent. The engine computes the <code>GlobalTransform</code> automatically via the transform hierarchy.</p>
<h3 id="attach-a-weapon-to-a-camera"><a class="header" href="#attach-a-weapon-to-a-camera">Attach a weapon to a camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attach_weapon_to_camera(world: &amp;mut World, camera: Entity) -&gt; Entity {
    let weapon = load_gltf(world, "assets/models/pistol.glb")[0];

    world.set_local_transform(weapon, LocalTransform {
        translation: Vec3::new(0.3, -0.2, -0.5),
        rotation: nalgebra_glm::quat_angle_axis(std::f32::consts::PI, &amp;Vec3::y()),
        scale: Vec3::new(0.1, 0.1, 0.1),
    });

    world.set_parent(weapon, Parent(Some(camera)));
    weapon
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-weapon-sway-from-mouse-movement"><a class="header" href="#add-weapon-sway-from-mouse-movement">Add weapon sway from mouse movement</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn weapon_sway(world: &amp;mut World, weapon: Entity, rest_x: f32, rest_y: f32) {
    let dt = world.resources.window.timing.delta_time;
    let mouse_delta = world.resources.input.mouse.position_delta;

    if let Some(transform) = world.get_local_transform_mut(weapon) {
        let target_x = rest_x - mouse_delta.x * 0.001;
        let target_y = rest_y - mouse_delta.y * 0.001;

        transform.translation.x += (target_x - transform.translation.x) * dt * 10.0;
        transform.translation.y += (target_y - transform.translation.y) * dt * 10.0;
    }
    mark_local_transform_dirty(world, weapon);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Common terms used in game development and Nightshade.</p>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<p><strong>Alpha Blending</strong>
Technique for rendering transparent objects by mixing colors based on alpha (transparency) values.</p>
<p><strong>Alpha Cutoff</strong>
Threshold for alpha testing. Pixels with alpha below this value are discarded entirely.</p>
<p><strong>Ambient Light</strong>
Constant, directionless light that illuminates all surfaces equally. Simulates indirect illumination.</p>
<p><strong>Ambient Occlusion (AO)</strong>
Technique that darkens creases and corners where ambient light would be blocked. See SSAO.</p>
<p><strong>Animation Blending</strong>
Smoothly transitioning between two animations by interpolating their transforms.</p>
<p><strong>Animation Clip</strong>
A single named animation (e.g., "walk", "run", "idle") containing keyframed transforms.</p>
<p><strong>Aspect Ratio</strong>
Width divided by height of the viewport (e.g., 16:9 = 1.777).</p>
<h2 id="b"><a class="header" href="#b">B</a></h2>
<p><strong>Billboard</strong>
A sprite that always faces the camera, commonly used for particles and distant objects.</p>
<p><strong>Bind Pose</strong>
The default pose of a skeletal mesh before any animation is applied.</p>
<p><strong>Bloom</strong>
Post-processing effect that creates a glow around bright areas.</p>
<p><strong>Bone</strong>
A joint in a skeletal hierarchy used for animation. Also called a joint.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<p><strong>Cascaded Shadow Maps (CSM)</strong>
Technique using multiple shadow maps at different resolutions for different distances.</p>
<p><strong>CCD (Continuous Collision Detection)</strong>
Physics technique to prevent fast-moving objects from passing through thin surfaces.</p>
<p><strong>Character Controller</strong>
A kinematic physics body designed for player movement with special handling for steps and slopes.</p>
<p><strong>Collider</strong>
A simplified shape used for physics collision detection (box, sphere, capsule, etc.).</p>
<p><strong>Component</strong>
Data attached to an entity in an ECS. Contains no logic, only state.</p>
<p><strong>Culling</strong>
Excluding objects from rendering if they're outside the view or occluded.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<p><strong>Delta Time (dt)</strong>
Time elapsed since the previous frame. Used to make movement frame-rate independent.</p>
<p><strong>Depth Buffer (Z-Buffer)</strong>
Texture storing the distance of each pixel from the camera. Used for depth testing.</p>
<p><strong>Diffuse</strong>
The base color of a surface, independent of view angle.</p>
<p><strong>Dynamic Body</strong>
A physics body affected by forces, gravity, and collisions.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<p><strong>ECS (Entity Component System)</strong>
Architecture where entities are IDs, components are data, and systems are logic.</p>
<p><strong>Emission/Emissive</strong>
Light that a surface produces itself, independent of external lighting.</p>
<p><strong>Entity</strong>
A unique identifier that groups related components together. Has no data itself.</p>
<p><strong>Euler Angles</strong>
Representation of rotation as three angles (pitch, yaw, roll). Can suffer from gimbal lock.</p>
<p><strong>Exposure</strong>
Brightness adjustment simulating camera exposure settings.</p>
<h2 id="f"><a class="header" href="#f">F</a></h2>
<p><strong>Far Plane</strong>
Maximum distance from the camera at which objects are rendered.</p>
<p><strong>FFT (Fast Fourier Transform)</strong>
Algorithm to convert audio from time domain to frequency domain.</p>
<p><strong>Field of View (FOV)</strong>
Angle of the visible area. Typically 60-90 degrees for games.</p>
<p><strong>Forward Rendering</strong>
Rendering each object completely in one pass. Simple but expensive with many lights.</p>
<p><strong>Frame</strong>
One complete update and render cycle.</p>
<p><strong>Frustum</strong>
The 3D region visible to the camera, shaped like a truncated pyramid.</p>
<h2 id="g"><a class="header" href="#g">G</a></h2>
<p><strong>G-Buffer</strong>
Textures storing geometry information (normals, depth, albedo) for deferred rendering.</p>
<p><strong>Gimbal Lock</strong>
Loss of one degree of freedom when two rotation axes align. Quaternions avoid this.</p>
<p><strong>glTF/GLB</strong>
Standard 3D model format. glTF is JSON + binary, GLB is single binary file.</p>
<p><strong>Global Transform</strong>
World-space transformation after parent transforms are applied.</p>
<h2 id="h"><a class="header" href="#h">H</a></h2>
<p><strong>HDR (High Dynamic Range)</strong>
Color values exceeding 0-1 range, allowing for realistic lighting before tonemapping.</p>
<p><strong>Heightfield</strong>
A 2D grid of height values representing terrain or other surfaces.</p>
<p><strong>Hierarchy</strong>
Parent-child relationships between entities where child transforms are relative to parents.</p>
<h2 id="i"><a class="header" href="#i">I</a></h2>
<p><strong>Index Buffer</strong>
List of vertex indices defining triangles. Allows vertex reuse.</p>
<p><strong>Instancing</strong>
Rendering many copies of the same mesh efficiently in a single draw call.</p>
<p><strong>Interpolation</strong>
Smoothly blending between two values. Linear interpolation (lerp) is most common.</p>
<h2 id="j"><a class="header" href="#j">J</a></h2>
<p><strong>Joint</strong>
Connection point between physics bodies with constraints on movement.</p>
<h2 id="k"><a class="header" href="#k">K</a></h2>
<p><strong>Keyframe</strong>
A specific value at a specific time in an animation. Values are interpolated between keyframes.</p>
<p><strong>Kinematic Body</strong>
A physics body moved by code that affects dynamic bodies but isn't affected by physics.</p>
<h2 id="l"><a class="header" href="#l">L</a></h2>
<p><strong>LDR (Low Dynamic Range)</strong>
Standard 0-1 color range suitable for display.</p>
<p><strong>Lerp (Linear Interpolation)</strong>
Blending between two values: <code>result = a + (b - a) * t</code> where t is 0-1.</p>
<p><strong>LOD (Level of Detail)</strong>
Using simpler meshes for distant objects to improve performance.</p>
<p><strong>Local Transform</strong>
Position, rotation, scale relative to the parent entity (or world if no parent).</p>
<h2 id="m"><a class="header" href="#m">M</a></h2>
<p><strong>Material</strong>
Defines how a surface looks: color, roughness, metallic, textures, etc.</p>
<p><strong>Mesh</strong>
Geometry defined by vertices and indices forming triangles.</p>
<p><strong>Metallic</strong>
PBR property indicating whether a surface is metal (1.0) or dielectric (0.0).</p>
<p><strong>Mipmaps</strong>
Pre-calculated, progressively smaller versions of a texture for efficient sampling at distance.</p>
<p><strong>Morph Targets</strong>
Vertex positions for blending between shapes (facial expressions, etc.). Also called blend shapes.</p>
<h2 id="n"><a class="header" href="#n">N</a></h2>
<p><strong>NavMesh (Navigation Mesh)</strong>
Simplified geometry representing walkable areas for AI pathfinding.</p>
<p><strong>Near Plane</strong>
Minimum distance from camera at which objects are rendered. Objects closer are clipped.</p>
<p><strong>Normal Map</strong>
Texture encoding surface direction variations to simulate detail without geometry.</p>
<h2 id="o"><a class="header" href="#o">O</a></h2>
<p><strong>Occlusion</strong>
When one object blocks another from view or light.</p>
<p><strong>Orthographic Projection</strong>
Parallel projection with no perspective. Objects don't get smaller with distance.</p>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<p><strong>PBR (Physically Based Rendering)</strong>
Material model based on real-world physics for consistent, realistic lighting.</p>
<p><strong>Perspective Projection</strong>
Projection where distant objects appear smaller, simulating human vision.</p>
<p><strong>Pitch</strong>
Rotation around the X (left-right) axis. Looking up/down.</p>
<p><strong>Point Light</strong>
Light emitting equally in all directions from a point.</p>
<p><strong>Prefab</strong>
Pre-configured entity template that can be instantiated multiple times.</p>
<h2 id="q"><a class="header" href="#q">Q</a></h2>
<p><strong>Quaternion</strong>
4D number representing rotation without gimbal lock. Used for smooth interpolation.</p>
<p><strong>Query</strong>
Finding entities that have specific components.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<p><strong>Raycast</strong>
Tracing a line through space to find intersections with geometry.</p>
<p><strong>Render Graph</strong>
Declarative system for defining rendering passes and their dependencies.</p>
<p><strong>Render Pass</strong>
A single stage of rendering (shadow pass, color pass, post-processing pass).</p>
<p><strong>Rigid Body</strong>
Physics object that doesn't deform. Can be dynamic, kinematic, or static.</p>
<p><strong>Roll</strong>
Rotation around the Z (forward) axis. Tilting sideways.</p>
<p><strong>Roughness</strong>
PBR property controlling how scattered light reflections are. 0=mirror, 1=diffuse.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><strong>Skinning</strong>
Deforming mesh vertices based on bone positions. Used for character animation.</p>
<p><strong>Skybox</strong>
Cubemap texture surrounding the scene representing distant environment.</p>
<p><strong>Slerp (Spherical Linear Interpolation)</strong>
Interpolation for quaternions that maintains constant angular velocity.</p>
<p><strong>Specular</strong>
Mirror-like reflection of light. Intensity depends on view angle.</p>
<p><strong>Spot Light</strong>
Light emitting in a cone shape, like a flashlight.</p>
<p><strong>SSAO (Screen-Space Ambient Occlusion)</strong>
Post-processing technique approximating ambient occlusion from depth buffer.</p>
<p><strong>Static Body</strong>
Physics body that never moves. Used for floors, walls, terrain.</p>
<p><strong>System</strong>
Logic that operates on entities with specific components.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<p><strong>Tessellation</strong>
Subdividing geometry into smaller triangles for detail.</p>
<p><strong>Texture</strong>
2D image mapped onto 3D geometry.</p>
<p><strong>Tonemapping</strong>
Converting HDR colors to displayable LDR range.</p>
<p><strong>Transform</strong>
Position, rotation, and scale of an object in 3D space.</p>
<p><strong>Transparency</strong>
See Alpha Blending.</p>
<p><strong>Trimesh (Triangle Mesh)</strong>
Collision shape using actual mesh geometry. Accurate but expensive.</p>
<h2 id="u"><a class="header" href="#u">U</a></h2>
<p><strong>UV Coordinates</strong>
2D texture coordinates mapping texture pixels to mesh vertices.</p>
<p><strong>Uniform</strong>
Shader constant that's the same for all vertices/pixels in a draw call.</p>
<h2 id="v"><a class="header" href="#v">V</a></h2>
<p><strong>Vertex</strong>
Point in 3D space with position, normal, texture coordinates, etc.</p>
<p><strong>Vertex Buffer</strong>
GPU memory containing vertex data.</p>
<p><strong>Vignette</strong>
Post-processing effect darkening screen edges.</p>
<p><strong>Vulkan</strong>
Low-level graphics API. Used by wgpu on Windows/Linux.</p>
<h2 id="w"><a class="header" href="#w">W</a></h2>
<p><strong>WebGPU</strong>
Modern web graphics API. Used by wgpu for cross-platform rendering.</p>
<p><strong>World Space</strong>
Global coordinate system. Contrast with local/object space.</p>
<p><strong>wgpu</strong>
Rust graphics library providing cross-platform GPU access.</p>
<h2 id="y"><a class="header" href="#y">Y</a></h2>
<p><strong>Yaw</strong>
Rotation around the Y (up) axis. Looking left/right.</p>
<h2 id="z"><a class="header" href="#z">Z</a></h2>
<p><strong>Z-Buffer</strong>
See Depth Buffer.</p>
<p><strong>Z-Fighting</strong>
Visual artifacts when two surfaces are at nearly the same depth.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>Common issues and their solutions.</p>
<h2 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h2>
<h3 id="feature-x-is-not-enabled"><a class="header" href="#feature-x-is-not-enabled">"feature <code>X</code> is not enabled"</a></h3>
<p>You're using a feature that isn't enabled in your <code>Cargo.toml</code>. Add the required feature:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "wgpu", "physics", "audio"] }
</code></pre>
<p>See <a href="appendix-features.html">Feature Flags</a> for the complete list.</p>
<h3 id="cannot-find-function-spawn_cube_at"><a class="header" href="#cannot-find-function-spawn_cube_at">"cannot find function <code>spawn_cube_at</code>"</a></h3>
<p>Import the prelude:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;
<span class="boring">}</span></code></pre></pre>
<h3 id="the-trait-state-is-not-implemented"><a class="header" href="#the-trait-state-is-not-implemented">"the trait <code>State</code> is not implemented"</a></h3>
<p>Ensure your game struct implements all required methods:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str { "My Game" }
    fn initialize(&amp;mut self, world: &amp;mut World) {}
    fn run_systems(&amp;mut self, world: &amp;mut World) {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nalgebra_glm-vs-glam-conflict"><a class="header" href="#nalgebra_glm-vs-glam-conflict">"nalgebra_glm vs glam conflict"</a></h3>
<p>Nightshade uses <code>nalgebra_glm</code> exclusively. Don't mix with <code>glam</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Correct
use nalgebra_glm::Vec3;

// Wrong - will cause type mismatches
use glam::Vec3;
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h2>
<h3 id="no-suitable-adapter-found"><a class="header" href="#no-suitable-adapter-found">"No suitable adapter found"</a></h3>
<p>Your GPU doesn't support the required graphics API.</p>
<p><strong>Windows:</strong></p>
<ul>
<li>Update graphics drivers</li>
<li>Install Vulkan Runtime from https://vulkan.lunarg.com/</li>
<li>Try forcing DX12: <code>WGPU_BACKEND=dx12 ./game.exe</code></li>
</ul>
<p><strong>Linux:</strong></p>
<ul>
<li>Install Vulkan drivers: <code>sudo apt install mesa-vulkan-drivers</code></li>
<li>Verify with <code>vulkaninfo</code></li>
</ul>
<p><strong>macOS:</strong></p>
<ul>
<li>Ensure macOS 10.13+ (Metal required)</li>
<li>Check System Report &gt; Graphics for Metal support</li>
</ul>
<h3 id="entity-not-found"><a class="header" href="#entity-not-found">"Entity not found"</a></h3>
<p>You're accessing an entity that was despawned or never existed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check entity exists before access
if world.has_entity(entity) {
    if let Some(transform) = world.get_local_transform(entity) {
        // Safe to use
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="texture-not-found"><a class="header" href="#texture-not-found">"Texture not found"</a></h3>
<p>The texture path is incorrect or the file doesn't exist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Paths are relative to the executable
load_gltf(world, "assets/models/character.glb");  // Correct
load_gltf(world, "/home/user/game/assets/models/character.glb");  // Avoid absolute paths
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-objects-fall-through-floor"><a class="header" href="#physics-objects-fall-through-floor">Physics objects fall through floor</a></h3>
<p>Common causes:</p>
<ol>
<li><strong>Missing collider on floor:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add_collider(world, floor, ColliderShape::Box {
    half_extents: Vec3::new(50.0, 0.5, 50.0),
});
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Objects spawned inside each other:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn above the floor, not at y=0
transform.translation = Vec3::new(0.0, 2.0, 0.0);
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>High velocity causing tunneling:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable CCD for fast objects
let mut body = RigidBodyComponent::new_dynamic();
body.ccd_enabled = true;
world.set_rigid_body(entity, body);
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-not-playing"><a class="header" href="#animation-not-playing">Animation not playing</a></h3>
<ol>
<li><strong>Check animation name exists:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(player) = world.get_animation_player_mut(entity) {
    // List available animations
    for name in player.available_animations() {
        println!("Animation: {}", name);
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Call update each frame:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    update_animation_players(world, dt);
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Animation player is on child entity:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// glTF animations are often on child nodes
for child in world.resources.children_cache.get(&amp;model_root).cloned().unwrap_or_default() {
    if let Some(player) = world.get_animation_player_mut(child) {
        player.play("idle");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="no-audio-output"><a class="header" href="#no-audio-output">No audio output</a></h3>
<ol>
<li><strong>Load sound before playing:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_sound(world, "shoot", "assets/audio/shoot.wav");
play_sound(world, "shoot");
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Check audio feature is enabled:</strong></li>
</ol>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "wgpu", "audio"] }
</code></pre>
<ol start="3">
<li><strong>Verify file format:</strong> Supported formats are WAV, OGG, MP3, FLAC.</li>
</ol>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="low-frame-rate"><a class="header" href="#low-frame-rate">Low frame rate</a></h3>
<ol>
<li><strong>Check entity count:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Entities: {}", world.query_entities(RENDER_MESH).count());
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Disable expensive effects:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.ssao_enabled = false;
world.resources.graphics.bloom_enabled = false;
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Reduce shadow quality:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.shadow_map_size = 1024; // Default is 2048
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li><strong>Use simpler colliders:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefer boxes/spheres over trimesh
add_collider(world, entity, ColliderShape::Box { ... });
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-usage-high"><a class="header" href="#memory-usage-high">Memory usage high</a></h3>
<ol>
<li><strong>Despawn unused entities:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.despawn_entities(&amp;[entity]);
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Unload unused textures:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.texture_cache.clear_unused();
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Use smaller textures for distant objects.</strong></li>
</ol>
<h3 id="stuttering--hitching"><a class="header" href="#stuttering--hitching">Stuttering / hitching</a></h3>
<ol>
<li><strong>Avoid allocations in run_systems:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - allocates every frame
let entities: Vec&lt;Entity&gt; = world.query_entities(LOCAL_TRANSFORM).collect();

// Good - iterate directly
for entity in world.query_entities(LOCAL_TRANSFORM) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Preload assets in initialize:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    load_gltf(world, "assets/models/enemy.glb");
    load_sound(world, "explosion", "assets/audio/explosion.wav");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visual-issues"><a class="header" href="#visual-issues">Visual Issues</a></h2>
<h3 id="objects-are-black"><a class="header" href="#objects-are-black">Objects are black</a></h3>
<p>Missing or incorrect lighting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_sun(world);
world.resources.graphics.ambient_light = [0.1, 0.1, 0.1, 1.0];
<span class="boring">}</span></code></pre></pre>
<h3 id="objects-are-too-bright--washed-out"><a class="header" href="#objects-are-too-bright--washed-out">Objects are too bright / washed out</a></h3>
<p>Adjust tonemapping and color grading:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
world.resources.graphics.color_grading.brightness = 0.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="textures-look-wrong"><a class="header" href="#textures-look-wrong">Textures look wrong</a></h3>
<ol>
<li>
<p><strong>Normal maps inverted:</strong> Some tools export Y-flipped normals. Check your export settings.</p>
</li>
<li>
<p><strong>sRGB vs Linear:</strong> Base color textures should be sRGB. Normal/metallic/roughness should be linear.</p>
</li>
<li>
<p><strong>Texture coordinates flipped:</strong> glTF uses top-left origin. Some models may need UV adjustment.</p>
</li>
</ol>
<h3 id="z-fighting-flickering-surfaces"><a class="header" href="#z-fighting-flickering-surfaces">Z-fighting (flickering surfaces)</a></h3>
<p>Surfaces too close together:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increase near plane
camera.near = 0.1;  // Instead of 0.01

// Or separate surfaces more
floor_transform.translation.y = 0.0;
decal_transform.translation.y = 0.01;  // Slight offset
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-issues"><a class="header" href="#webassembly-issues">WebAssembly Issues</a></h2>
<h3 id="webgpu-not-supported"><a class="header" href="#webgpu-not-supported">"WebGPU not supported"</a></h3>
<ul>
<li>Use Chrome 113+ or Edge 113+</li>
<li>Firefox requires enabling <code>dom.webgpu.enabled</code> in about:config</li>
<li>Safari support is limited</li>
</ul>
<h3 id="assets-fail-to-load"><a class="header" href="#assets-fail-to-load">Assets fail to load</a></h3>
<p>WASM can't access the filesystem. Serve assets via HTTP:</p>
<pre><code class="language-html">&lt;script&gt;
// Assets must be fetched, not loaded from disk
fetch('assets/model.glb')
    .then(response =&gt; response.arrayBuffer())
    .then(data =&gt; { /* use data */ });
&lt;/script&gt;
</code></pre>
<h3 id="performance-worse-than-native"><a class="header" href="#performance-worse-than-native">Performance worse than native</a></h3>
<p>Expected. WebGPU has overhead. Reduce quality settings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
{
    world.resources.graphics.ssao_enabled = false;
    world.resources.graphics.shadow_map_size = 512;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<p>If your issue isn't listed here:</p>
<ol>
<li>Check the <a href="https://github.com/matthewjberger/nightshade/issues">GitHub Issues</a></li>
<li>Search existing issues for similar problems</li>
<li>Create a new issue with:
<ul>
<li>Nightshade version</li>
<li>Platform (OS, GPU)</li>
<li>Minimal code to reproduce</li>
<li>Error message or screenshot</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
