<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nightshade Game Engine</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nightshade Game Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Nightshade</strong> is a modern game engine written in Rust, designed for creating 3D games and interactive applications. It provides a complete toolkit for game development including rendering, physics, audio, animation, and more.</p>
<h2 id="what-is-nightshade"><a class="header" href="#what-is-nightshade">What is Nightshade?</a></h2>
<p>Nightshade is a batteries-included game engine that handles the complexity of modern 3D graphics while remaining approachable for developers of all skill levels. Whether you're building a simple visualizer, a physics playground, or a complete 3D game, Nightshade provides the foundation you need.</p>
<p>The engine is built on top of industry-standard libraries:</p>
<ul>
<li><strong>wgpu</strong> for cross-platform GPU access (Vulkan, Metal, DirectX 12, WebGPU)</li>
<li><strong>Rapier3D</strong> for physics simulation</li>
<li><strong>Kira</strong> for audio playback and spatial sound</li>
<li><strong>egui</strong> for immediate-mode UI</li>
<li><strong>glTF</strong> for 3D model loading</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<ul>
<li><strong>Physically Based Rendering (PBR)</strong> - Metallic-roughness workflow with support for all standard texture maps</li>
<li><strong>Dynamic Lighting</strong> - Directional, point, and spot lights with real-time shadows</li>
<li><strong>Post-Processing</strong> - Bloom, SSAO, depth of field, tonemapping, and custom effects</li>
<li><strong>Skeletal Animation</strong> - Smooth blending and crossfading between animations</li>
<li><strong>Particle Systems</strong> - GPU-accelerated particles with configurable emitters</li>
<li><strong>Terrain</strong> - Procedural generation with tessellation and LOD</li>
<li><strong>Grass</strong> - Thousands of interactive grass blades with wind simulation</li>
</ul>
<h3 id="physics"><a class="header" href="#physics">Physics</a></h3>
<ul>
<li><strong>Rigid Body Dynamics</strong> - Dynamic, kinematic, and static bodies</li>
<li><strong>Collision Shapes</strong> - Box, sphere, capsule, cylinder, convex hull, trimesh, heightfield</li>
<li><strong>Character Controllers</strong> - Built-in player movement with slopes, steps, and jumping</li>
<li><strong>Physics Joints</strong> - Fixed, revolute, prismatic, spherical, rope, and spring joints</li>
<li><strong>Raycasting</strong> - Query the physics world for line-of-sight and hit detection</li>
</ul>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<ul>
<li><strong>Sound Playback</strong> - WAV, OGG, MP3, FLAC support</li>
<li><strong>Spatial Audio</strong> - 3D positioned sound sources with distance attenuation</li>
<li><strong>FFT Analysis</strong> - Real-time spectral analysis for music visualizers</li>
</ul>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<ul>
<li><strong>Keyboard &amp; Mouse</strong> - Full key detection with press/release states</li>
<li><strong>Gamepad</strong> - Controller support with analog sticks, triggers, and rumble</li>
<li><strong>Cursor Control</strong> - Lock and hide cursor for FPS-style games</li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><strong>Navigation Mesh</strong> - AI pathfinding with Recast integration</li>
<li><strong>Debug Rendering</strong> - Lines, boxes, spheres for visualization</li>
<li><strong>HUD Text</strong> - Screen-space text rendering with anchoring</li>
<li><strong>Screenshot Capture</strong> - Save frames to PNG</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Nightshade follows a simple architecture centered around the <code>State</code> trait and the <code>World</code> container:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                      Your Game (State)                       │
├─────────────────────────────────────────────────────────────┤
│  initialize()  │  run_systems()  │  ui()  │  input handlers │
└────────────────┴─────────────────┴────────┴─────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                          World                               │
├──────────────────┬──────────────────┬───────────────────────┤
│     Entities     │    Components    │      Resources        │
│  (unique IDs)    │  (data arrays)   │  (global singletons)  │
└──────────────────┴──────────────────┴───────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌───────────────┐    ┌───────────────┐    ┌───────────────┐
│   Renderer    │    │    Physics    │    │     Audio     │
│    (wgpu)     │    │   (Rapier)    │    │    (Kira)     │
└───────────────┘    └───────────────┘    └───────────────┘
</code></pre>
<h3 id="the-game-loop"><a class="header" href="#the-game-loop">The Game Loop</a></h3>
<p>Each frame, Nightshade:</p>
<ol>
<li>Processes window and input events</li>
<li>Calls your <code>run_systems()</code> method</li>
<li>Updates physics simulation</li>
<li>Propagates transform hierarchies</li>
<li>Renders the scene</li>
<li>Presents to the screen</li>
</ol>
<p>You control game logic in <code>run_systems()</code>, and the engine handles everything else.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>Nightshade follows these core principles:</p>
<h3 id="simplicity"><a class="header" href="#simplicity">Simplicity</a></h3>
<p>The API surface is minimal and consistent. Common tasks like spawning entities, loading models, and handling input should be intuitive. If something feels overly complex, it's probably a bug.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>The engine uses data-oriented design throughout. The ECS stores components in contiguous arrays for cache-friendly access. The renderer batches draw calls and uses GPU instancing where possible.</p>
<h3 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h3>
<p>Feature flags let you include only what you need. Building a simple visualizer? Just use <code>engine</code>. Need physics? Add <code>physics</code>. Everything is opt-in.</p>
<h3 id="cross-platform"><a class="header" href="#cross-platform">Cross-Platform</a></h3>
<p>Write once, run everywhere. The same code runs on Windows, macOS, Linux, and WebAssembly. The engine automatically selects the appropriate graphics backend.</p>
<h2 id="when-to-use-nightshade"><a class="header" href="#when-to-use-nightshade">When to Use Nightshade</a></h2>
<p>Nightshade is well-suited for:</p>
<ul>
<li><strong>3D Games</strong> - Action games, platformers, simulations</li>
<li><strong>Visualizers</strong> - Music-reactive graphics, data visualization</li>
<li><strong>Prototypes</strong> - Quickly test game ideas</li>
<li><strong>Learning</strong> - Understanding game engine concepts</li>
</ul>
<p>Nightshade may not be ideal for:</p>
<ul>
<li><strong>2D-only games</strong> - Consider a dedicated 2D engine</li>
<li><strong>AAA production</strong> - Missing some advanced features (GI, complex animation graphs)</li>
<li><strong>Mobile</strong> - Not yet optimized for mobile platforms</li>
</ul>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>This documentation covers <strong>Nightshade v0.6.69</strong> using <strong>Rust 2024 Edition</strong>.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><a href="https://github.com/matthewjberger/nightshade">GitHub Repository</a> - Source code and issue tracker</li>
<li><a href="https://docs.rs/nightshade">API Documentation</a> - Generated API docs</li>
</ul>
<p>Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before using Nightshade, ensure you have:</p>
<ul>
<li><strong>Rust 1.90+</strong> with the 2024 edition</li>
<li>A graphics driver supporting Vulkan 1.2, Metal, or DirectX 12</li>
</ul>
<h2 id="adding-nightshade-to-your-project"><a class="header" href="#adding-nightshade-to-your-project">Adding Nightshade to Your Project</a></h2>
<p>Add Nightshade to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade.git" }
</code></pre>
<h3 id="with-specific-features"><a class="header" href="#with-specific-features">With Specific Features</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade.git", features = ["engine", "physics", "audio"] }
</code></pre>
<h3 id="feature-sets"><a class="header" href="#feature-sets">Feature Sets</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default</code></td><td>Engine + wgpu backend</td></tr>
<tr><td><code>engine</code></td><td>Full game engine capabilities</td></tr>
<tr><td><code>runtime</code></td><td>Minimal rendering without asset loading</td></tr>
<tr><td><code>full</code></td><td>Everything including niche features</td></tr>
</tbody></table>
</div>
<p>See the <a href="appendix-features.html">Feature Flags</a> appendix for a complete list.</p>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a minimal application to verify everything works:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(MyGame::default())
}

#[derive(Default)]
struct MyGame;

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "Nightshade Test"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
    }

    fn run_systems(&amp;mut self, _world: &amp;mut World) {}
}</code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see a window with a default sky background.</p>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>DirectX 12 is the default backend. Ensure your graphics drivers are up to date.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>Metal is used automatically. No additional setup required.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Vulkan is required. Install Vulkan drivers for your GPU:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install vulkan-tools libvulkan-dev

# Fedora
sudo dnf install vulkan-tools vulkan-loader-devel

# Arch
sudo pacman -S vulkan-tools vulkan-icd-loader
</code></pre>
<h3 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h3>
<p>WebGPU support requires a compatible browser (Chrome 113+, Firefox 121+). Build with:</p>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h1>
<p>Let's create a simple application that displays a 3D scene with a camera, lighting, and some cubes.</p>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>Every Nightshade application implements the <code>State</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(MyGame::default())
}

#[derive(Default)]
struct MyGame;

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My First Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Setup happens here
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        // Game logic runs every frame
    }
}</code></pre></pre>
<h2 id="adding-a-camera"><a class="header" href="#adding-a-camera">Adding a Camera</a></h2>
<p>The camera determines what the player sees:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(
        world,
        Vec3::new(0.0, 5.0, 10.0),
        "Main Camera".to_string(),
    );
    world.resources.active_camera = Some(camera);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-lighting"><a class="header" href="#adding-lighting">Adding Lighting</a></h2>
<p>Without lights, everything is dark. Add a directional light (sun):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    // Camera setup...

    spawn_sun(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="enabling-the-grid"><a class="header" href="#enabling-the-grid">Enabling the Grid</a></h2>
<p>For development, a ground grid is helpful:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.show_grid = true;
    world.resources.graphics.atmosphere = Atmosphere::Sky;

    // Camera and lighting...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-geometry"><a class="header" href="#adding-geometry">Adding Geometry</a></h2>
<p>Spawn a cube using the built-in primitive:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::mesh::primitives::spawn_cube;

fn initialize(&amp;mut self, world: &amp;mut World) {
    // Previous setup...

    spawn_cube(world, Vec3::new(0.0, 1.0, 0.0), 1.0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-controls"><a class="header" href="#camera-controls">Camera Controls</a></h2>
<p>Add a fly camera system so you can navigate the scene:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    fly_camera_system(world);
    escape_key_exit_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;
use nightshade::ecs::mesh::primitives::spawn_cube;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(MyGame::default())
}

#[derive(Default)]
struct MyGame;

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My First Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        world.resources.graphics.show_grid = true;
        world.resources.graphics.atmosphere = Atmosphere::Sky;

        let camera = spawn_camera(
            world,
            Vec3::new(0.0, 5.0, 10.0),
            "Main Camera".to_string(),
        );
        world.resources.active_camera = Some(camera);

        spawn_sun(world);

        spawn_cube(world, Vec3::new(0.0, 1.0, 0.0), 1.0);
        spawn_cube(world, Vec3::new(3.0, 0.5, 0.0), 0.5);
        spawn_cube(world, Vec3::new(-2.0, 1.5, 2.0), 1.5);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        fly_camera_system(world);
        escape_key_exit_system(world);
    }
}</code></pre></pre>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>With the fly camera system enabled:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Action</th></tr></thead><tbody>
<tr><td>W/A/S/D</td><td>Move forward/left/back/right</td></tr>
<tr><td>Space</td><td>Move up</td></tr>
<tr><td>Shift</td><td>Move down</td></tr>
<tr><td>Mouse</td><td>Look around</td></tr>
<tr><td>Escape</td><td>Exit</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have a basic scene, explore:</p>
<ul>
<li><a href="meshes-models.html">Meshes &amp; Models</a> - Load 3D models</li>
<li><a href="materials.html">Materials</a> - Customize appearance</li>
<li><a href="physics-overview.html">Physics</a> - Add physics simulation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<h2 id="recommended-layout"><a class="header" href="#recommended-layout">Recommended Layout</a></h2>
<p>A typical Nightshade project follows this structure:</p>
<pre><code>my_game/
├── Cargo.toml
├── src/
│   ├── main.rs           # Entry point
│   ├── game.rs           # Game state
│   └── systems/          # Game systems
│       ├── player.rs
│       ├── camera.rs
│       └── ...
├── assets/
│   ├── models/           # glTF/GLB files
│   ├── textures/         # PNG, JPG, HDR
│   └── sounds/           # Audio files
└── README.md
</code></pre>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "my_game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/matthewjberger/nightshade.git" }
</code></pre>
<h2 id="entry-point-mainrs"><a class="header" href="#entry-point-mainrs">Entry Point (main.rs)</a></h2>
<p>Keep <code>main.rs</code> minimal:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod game;

use nightshade::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(game::MyGame::default())
}</code></pre></pre>
<h2 id="game-state-gamers"><a class="header" href="#game-state-gamers">Game State (game.rs)</a></h2>
<p>Implement your game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

#[derive(Default)]
pub struct MyGame {
    player: Option&lt;Entity&gt;,
    score: u32,
}

impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str {
        "My Game"
    }

    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Setup code
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        // Per-frame logic
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="embedding-assets"><a class="header" href="#embedding-assets">Embedding Assets</a></h2>
<p>For distribution, embed assets directly in the binary:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MODEL_BYTES: &amp;[u8] = include_bytes!("../assets/models/character.glb");
const SKY_HDR: &amp;[u8] = include_bytes!("../assets/textures/sky.hdr");
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-ecs"><a class="header" href="#custom-ecs">Custom ECS</a></h2>
<p>For complex games, create a separate game ECS alongside the engine's World:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use freecs::ecs;

ecs! {
    GameWorld {
        components {
            player_state: PlayerState,
            inventory: Inventory,
            health: Health,
        },
        resources {
            game_time: GameTime,
            score: u32,
        }
    }
}

pub struct MyGame {
    game: GameWorld,
}
<span class="boring">}</span></code></pre></pre>
<p>This keeps game-specific data separate from engine data while allowing both to coexist.</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module Organization</a></h2>
<p>For larger projects, organize systems into modules:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/systems/mod.rs
pub mod camera;
pub mod player;
pub mod enemies;
pub mod ui;

// src/game.rs
mod systems;

impl State for MyGame {
    fn run_systems(&amp;mut self, world: &amp;mut World) {
        systems::player::update(&amp;mut self.game, world);
        systems::camera::follow(&amp;self.game, world);
        systems::enemies::ai(&amp;mut self.game, world);
        systems::ui::update(&amp;self.game, world);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-state-trait"><a class="header" href="#the-state-trait">The State Trait</a></h1>
<p>The <code>State</code> trait is the primary interface between your game and the Nightshade engine. Every game implements this trait to define its behavior.</p>
<h2 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait State: 'static {
    fn title(&amp;self) -&gt; &amp;str;
    fn initialize(&amp;mut self, world: &amp;mut World);
    fn run_systems(&amp;mut self, world: &amp;mut World);

    // Optional methods with default implementations
    fn ui(&amp;mut self, ctx: &amp;egui::Context, world: &amp;mut World) {}
    fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {}
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {}
    fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {}
    fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {}
    fn on_dropped_file(&amp;mut self, world: &amp;mut World, path: PathBuf) {}
    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) {}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="required-methods"><a class="header" href="#required-methods">Required Methods</a></h2>
<h3 id="title"><a class="header" href="#title">title()</a></h3>
<p>Returns the window title:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn title(&amp;self) -&gt; &amp;str {
    "My Awesome Game"
}
<span class="boring">}</span></code></pre></pre>
<h3 id="initialize"><a class="header" href="#initialize">initialize()</a></h3>
<p>Called once when the application starts. Use this to set up your initial game state:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.atmosphere = Atmosphere::Sky;

    let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    self.player = Some(spawn_player(world));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="run_systems"><a class="header" href="#run_systems">run_systems()</a></h3>
<p>Called every frame. This is where your game logic lives:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    player_movement_system(world);
    enemy_ai_system(world);
    collision_response_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-methods"><a class="header" href="#optional-methods">Optional Methods</a></h2>
<h3 id="ui"><a class="header" href="#ui">ui()</a></h3>
<p>For egui-based user interfaces:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ui(&amp;mut self, ctx: &amp;egui::Context, world: &amp;mut World) {
    egui::Window::new("Debug").show(ctx, |ui| {
        ui.label(format!("FPS: {:.0}", world.resources.window.timing.frames_per_second));
        ui.label(format!("Entities: {}", world.entity_count()));
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="immediate_ui"><a class="header" href="#immediate_ui">immediate_ui()</a></h3>
<p>For the built-in immediate mode UI (menus, HUD):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn immediate_ui(&amp;mut self, world: &amp;mut World, ui: &amp;mut ImmediateUi) {
    if self.paused {
        ui.panel("Pause Menu", |ui| {
            if ui.button("Resume") {
                self.paused = false;
            }
            if ui.button("Quit") {
                std::process::exit(0);
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_keyboard_input"><a class="header" href="#on_keyboard_input">on_keyboard_input()</a></h3>
<p>Handle keyboard events directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
    if state == KeyState::Pressed {
        match key {
            KeyCode::Escape =&gt; self.paused = !self.paused,
            KeyCode::F11 =&gt; toggle_fullscreen(world),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="on_gamepad_event"><a class="header" href="#on_gamepad_event">on_gamepad_event()</a></h3>
<p>Handle gamepad button presses:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {
    if let gilrs::EventType::ButtonPressed(button, _) = event.event {
        match button {
            gilrs::Button::Start =&gt; self.paused = !self.paused,
            gilrs::Button::South =&gt; self.player_jump(),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configure_render_graph"><a class="header" href="#configure_render_graph">configure_render_graph()</a></h3>
<p>Customize the rendering pipeline:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    let bloom_pass = passes::BloomPass::new(device, 1920, 1080);
    graph
        .pass(Box::new(bloom_pass))
        .read("hdr", resources.scene_color)
        .write("bloom", resources.bloom);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="launching-your-game"><a class="header" href="#launching-your-game">Launching Your Game</a></h2>
<p>Use the <code>launch</code> function to run your game:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    launch(MyGame::default())
}</code></pre></pre>
<p>Or with an HDR skybox:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    load_hdr_skybox(world, include_bytes!("../assets/sky.hdr").to_vec());
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world--resources"><a class="header" href="#world--resources">World &amp; Resources</a></h1>
<p>The <code>World</code> is the central data container in Nightshade. It holds all entities, components, and global resources.</p>
<h2 id="world-structure"><a class="header" href="#world-structure">World Structure</a></h2>
<p>The World is generated by the <code>freecs::ecs!</code> macro and contains:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct World {
    // Entity storage with component arrays
    pub entities: EntityStorage,

    // Global singleton resources
    pub resources: Resources,

    // Hierarchy tracking
    pub children_cache: HashMap&lt;Entity, Vec&lt;Entity&gt;&gt;,

    // Deferred operations
    pub command_queue: CommandQueue,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Resources are global singletons accessible throughout the engine:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Resources {
    // Timing
    pub time: Time,
    pub window: WindowState,

    // Input
    pub input: Input,

    // Rendering
    pub graphics: Graphics,
    pub texture_cache: TextureCache,
    pub material_registry: MaterialRegistry,
    pub mesh_cache: MeshCache,
    pub active_camera: Option&lt;Entity&gt;,

    // Physics
    pub physics: PhysicsWorld,

    // Audio
    pub audio_engine: AudioEngine,

    // Navigation
    pub navmesh_world: NavMeshWorld,

    // Events
    pub event_bus: EventBus,

    // Assets
    pub prefab_cache: PrefabCache,
    pub animation_cache: AnimationCache,

    // UI
    pub user_interface: UserInterface,

    // Text
    pub text_cache: TextCache,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>Resources are accessed through <code>world.resources</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // Get delta time
    let dt = world.resources.window.timing.delta_time;

    // Check input
    if world.resources.input.keyboard.is_key_pressed(KeyCode::Space) {
        self.jump();
    }

    // Modify graphics settings
    world.resources.graphics.bloom_enabled = true;
    world.resources.graphics.bloom_intensity = 0.5;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-resources"><a class="header" href="#common-resources">Common Resources</a></h2>
<h3 id="time--timing"><a class="header" href="#time--timing">Time &amp; Timing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dt = world.resources.window.timing.delta_time;
let fps = world.resources.window.timing.frames_per_second;
let elapsed = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keyboard
if world.resources.input.keyboard.is_key_pressed(KeyCode::KeyW) {
    move_forward();
}

// Mouse position
let mouse_pos = world.resources.input.mouse.position;

// Mouse buttons
if world.resources.input.mouse.state.contains(MouseState::LEFT_JUST_PRESSED) {
    shoot();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="graphics-settings"><a class="header" href="#graphics-settings">Graphics Settings</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable/disable features
world.resources.graphics.show_grid = true;
world.resources.graphics.atmosphere = Atmosphere::Sky;
world.resources.graphics.bloom_enabled = true;
world.resources.graphics.ssao_enabled = true;

// Tonemapping
world.resources.graphics.tonemap_method = TonemapMethod::Aces;
<span class="boring">}</span></code></pre></pre>
<h3 id="active-camera"><a class="header" href="#active-camera">Active Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set active camera
world.resources.active_camera = Some(camera_entity);

// Get active camera
if let Some(camera) = world.resources.active_camera {
    let transform = world.get_global_transform(camera);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deferred-commands"><a class="header" href="#deferred-commands">Deferred Commands</a></h2>
<p>Some operations must be deferred to avoid invalidating iterators:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Queue entity spawn
world.command_queue.spawn(|world| {
    let entity = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];
    world.set_local_transform(entity, LocalTransform::default());
});

// Queue entity despawn
world.command_queue.despawn(entity);

// Flush at safe point (called automatically at frame end)
world.command_queue.flush(world);
<span class="boring">}</span></code></pre></pre>
<h2 id="queuing-world-commands"><a class="header" href="#queuing-world-commands">Queuing World Commands</a></h2>
<p>For GPU resource operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load texture
world.queue_command(WorldCommand::LoadTexture {
    name: "my_texture".to_string(),
    rgba_data: texture_bytes,
    width: 256,
    height: 256,
});
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system"><a class="header" href="#entity-component-system">Entity Component System</a></h1>
<p>Nightshade uses <code>freecs</code>, a code-generated ECS with struct-of-arrays storage for cache-friendly access patterns.</p>
<h2 id="ecs-concepts"><a class="header" href="#ecs-concepts">ECS Concepts</a></h2>
<h3 id="entities"><a class="header" href="#entities">Entities</a></h3>
<p>Entities are unique identifiers (IDs) that group components together. An entity is just a number - it has no data of its own.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity: Entity = world.spawn_entities(LOCAL_TRANSFORM, 1)[0];
<span class="boring">}</span></code></pre></pre>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>Components are plain data structs attached to entities:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalTransform {
    pub translation: Vec3,
    pub rotation: UnitQuaternion&lt;f32&gt;,
    pub scale: Vec3,
}

pub struct Health {
    pub current: f32,
    pub maximum: f32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="systems"><a class="header" href="#systems">Systems</a></h3>
<p>Systems are functions that process entities with specific components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn damage_system(world: &amp;mut World) {
    for entity in world.query(HEALTH | DAMAGE_OVER_TIME) {
        let dot = world.get_damage_over_time(entity).unwrap();
        if let Some(health) = world.get_health_mut(entity) {
            health.current -= dot.damage_per_second * world.resources.time.delta_seconds;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="component-flags"><a class="header" href="#component-flags">Component Flags</a></h2>
<p>Each component type has a corresponding bitflag for efficient queries:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const LOCAL_TRANSFORM: ComponentFlags = 1 &lt;&lt; 0;
pub const GLOBAL_TRANSFORM: ComponentFlags = 1 &lt;&lt; 1;
pub const RENDER_MESH: ComponentFlags = 1 &lt;&lt; 2;
pub const MATERIAL_REF: ComponentFlags = 1 &lt;&lt; 3;
pub const CAMERA: ComponentFlags = 1 &lt;&lt; 4;
pub const LIGHT: ComponentFlags = 1 &lt;&lt; 5;
// ... and so on
<span class="boring">}</span></code></pre></pre>
<p>Combine flags with bitwise OR:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RENDERABLE: ComponentFlags = LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF;

let entity = world.spawn_entities(RENDERABLE, 1)[0];
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-components"><a class="header" href="#working-with-components">Working with Components</a></h2>
<h3 id="setting-components"><a class="header" href="#setting-components">Setting Components</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 5.0, 0.0),
    rotation: UnitQuaternion::identity(),
    scale: Vec3::new(1.0, 1.0, 1.0),
});

world.set_render_mesh(entity, RenderMesh {
    mesh_name: "cube".to_string(),
    gpu_mesh_id: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-components-immutable"><a class="header" href="#getting-components-immutable">Getting Components (Immutable)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(transform) = world.get_local_transform(entity) {
    println!("Position: {:?}", transform.translation);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-components-mutable"><a class="header" href="#getting-components-mutable">Getting Components (Mutable)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(transform) = world.get_local_transform_mut(entity) {
    transform.translation.y += 1.0;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checking-component-presence"><a class="header" href="#checking-component-presence">Checking Component Presence</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.has_component(entity, RENDER_MESH) {
    // Entity has a render mesh
}
<span class="boring">}</span></code></pre></pre>
<h2 id="entity-hierarchy"><a class="header" href="#entity-hierarchy">Entity Hierarchy</a></h2>
<p>Entities can form parent-child relationships:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::transform::components::Parent;

// Set parent
world.update_parent(child_entity, Some(Parent(Some(parent_entity))));

// Clear parent
world.update_parent(child_entity, Some(Parent(None)));

// Get children
if let Some(children) = world.children_cache.get(&amp;parent_entity) {
    for child in children {
        // Process child
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Child transforms are relative to their parent. The engine automatically propagates transforms through the hierarchy.</p>
<h2 id="custom-game-ecs"><a class="header" href="#custom-game-ecs">Custom Game ECS</a></h2>
<p>For complex games, define a separate ECS for game-specific data:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use freecs::ecs;

ecs! {
    GameWorld {
        components {
            player_state: PlayerState,
            inventory: Inventory,
            health: Health,
            enemy_ai: EnemyAI,
        },
        resources {
            game_time: GameTime,
            score: u32,
            level: u32,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Then use both worlds together:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGame {
    game: GameWorld,
}

impl State for MyGame {
    fn run_systems(&amp;mut self, world: &amp;mut World) {
        // Update game ECS
        update_player(&amp;mut self.game);

        // Sync with engine world
        sync_positions(&amp;self.game, world);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Nightshade provides 44 built-in components across several categories.</p>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>LocalTransform</code></td><td>Position, rotation, scale relative to parent</td></tr>
<tr><td><code>GlobalTransform</code></td><td>Computed world-space transformation matrix</td></tr>
<tr><td><code>LocalTransformDirty</code></td><td>Marker for transforms needing propagation</td></tr>
<tr><td><code>Parent</code></td><td>Parent entity reference for hierarchy</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalTransform {
    pub translation: Vec3,
    pub rotation: UnitQuaternion&lt;f32&gt;,
    pub scale: Vec3,
}

pub struct GlobalTransform {
    pub matrix: Mat4,
}

pub struct Parent(pub Option&lt;Entity&gt;);
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-components"><a class="header" href="#rendering-components">Rendering Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RenderMesh</code></td><td>References mesh by name</td></tr>
<tr><td><code>MaterialRef</code></td><td>References material by name</td></tr>
<tr><td><code>Sprite</code></td><td>2D billboard rendering</td></tr>
<tr><td><code>RenderLayer</code></td><td>Depth/layer for ordering</td></tr>
<tr><td><code>CastsShadow</code></td><td>Marks mesh for shadow maps</td></tr>
<tr><td><code>Visibility</code></td><td>Visibility toggle</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderMesh {
    pub mesh_name: String,
    pub gpu_mesh_id: Option&lt;MeshId&gt;,
}

pub struct MaterialRef {
    pub material_name: String,
}

pub struct Visibility {
    pub visible: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-components"><a class="header" href="#camera-components">Camera Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Camera</code></td><td>Projection mode and smoothing</td></tr>
<tr><td><code>PerspectiveCamera</code></td><td>FOV, aspect, near/far planes</td></tr>
<tr><td><code>OrthographicCamera</code></td><td>Size, near/far for orthographic</td></tr>
<tr><td><code>PanOrbitCamera</code></td><td>Orbiting camera controller</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PerspectiveCamera {
    pub fov: f32,
    pub aspect: f32,
    pub near: f32,
    pub far: f32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lighting"><a class="header" href="#lighting">Lighting</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Light</code></td><td>Directional, Point, or Spot light</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Light {
    pub light_type: LightType,
    pub color: Vec3,
    pub intensity: f32,
    pub range: f32,
    pub cast_shadows: bool,
    pub shadow_bias: f32,
    pub inner_cone_angle: f32,
    pub outer_cone_angle: f32,
}

pub enum LightType {
    Directional,
    Point,
    Spot,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-components"><a class="header" href="#physics-components">Physics Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RigidBodyComponent</code></td><td>Dynamic/Kinematic/Static body</td></tr>
<tr><td><code>ColliderComponent</code></td><td>Collision shape</td></tr>
<tr><td><code>CharacterController</code></td><td>Kinematic player controller</td></tr>
<tr><td><code>PhysicsInterpolation</code></td><td>Smooth physics rendering</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RigidBodyComponent {
    pub body_type: RigidBodyType,
    pub handle: Option&lt;RigidBodyHandle&gt;,
}

pub enum RigidBodyType {
    Dynamic,
    Kinematic,
    Static,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-components"><a class="header" href="#animation-components">Animation Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AnimationPlayer</code></td><td>Animation playback control</td></tr>
<tr><td><code>Skin</code></td><td>Skeleton definition</td></tr>
<tr><td><code>Joint</code></td><td>Bone in skeleton</td></tr>
<tr><td><code>MorphWeights</code></td><td>Blend shape weights</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationPlayer {
    pub clips: Vec&lt;AnimationClip&gt;,
    pub current_clip: usize,
    pub playing: bool,
    pub speed: f32,
    pub time: f32,
    pub looping: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-components"><a class="header" href="#audio-components">Audio Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AudioSource</code></td><td>Sound playback</td></tr>
<tr><td><code>AudioListener</code></td><td>3D audio receiver</td></tr>
</tbody></table>
</div>
<h2 id="geometry-components"><a class="header" href="#geometry-components">Geometry Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Text</code></td><td>3D world text</td></tr>
<tr><td><code>HudText</code></td><td>Screen-space HUD text</td></tr>
<tr><td><code>Lines</code></td><td>Debug line rendering</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lines {
    pub lines: Vec&lt;Line&gt;,
}

pub struct Line {
    pub start: Vec3,
    pub end: Vec3,
    pub color: Vec4,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-components"><a class="header" href="#advanced-components">Advanced Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ParticleEmitter</code></td><td>GPU particle system</td></tr>
<tr><td><code>GrassRegion</code></td><td>Procedural grass field</td></tr>
<tr><td><code>GrassInteractor</code></td><td>Grass bending interaction</td></tr>
<tr><td><code>NavMeshAgent</code></td><td>AI pathfinding agent</td></tr>
<tr><td><code>Water</code></td><td>Water surface/volume</td></tr>
<tr><td><code>Decal</code></td><td>Projected texture</td></tr>
<tr><td><code>Name</code></td><td>String identifier</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-entities"><a class="header" href="#spawning-entities">Spawning Entities</a></h1>
<h2 id="basic-entity-spawning"><a class="header" href="#basic-entity-spawning">Basic Entity Spawning</a></h2>
<p>Spawn entities with <code>spawn_entities</code>, specifying component flags:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF,
    1
)[0];
<span class="boring">}</span></code></pre></pre>
<p>Then set component values:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),
    rotation: UnitQuaternion::identity(),
    scale: Vec3::new(1.0, 1.0, 1.0),
});

world.set_render_mesh(entity, RenderMesh {
    mesh_name: "cube".to_string(),
    gpu_mesh_id: None,
});

world.set_material_ref(entity, MaterialRef::new("default".to_string()));
<span class="boring">}</span></code></pre></pre>
<h2 id="spawning-multiple-entities"><a class="header" href="#spawning-multiple-entities">Spawning Multiple Entities</a></h2>
<p>Spawn multiple entities at once:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entities = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 100);

for (index, entity) in entities.iter().enumerate() {
    world.set_local_transform(*entity, LocalTransform {
        translation: Vec3::new(index as f32 * 2.0, 0.0, 0.0),
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h2>
<p>Nightshade provides convenience functions for common entities:</p>
<h3 id="cameras"><a class="header" href="#cameras">Cameras</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = spawn_camera(world, Vec3::new(0.0, 5.0, 10.0), "Main Camera".to_string());
world.resources.active_camera = Some(camera);

// Pan-orbit camera
let orbit_camera = spawn_pan_orbit_camera(
    world,
    Vec3::zeros(),  // focus point
    10.0,           // radius
    0.5,            // yaw
    0.4,            // pitch
    "Orbit Camera".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<h3 id="lights"><a class="header" href="#lights">Lights</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_sun(world);

spawn_point_light(world, Vec3::new(0.0, 3.0, 0.0), Vec3::new(1.0, 0.8, 0.6), 5.0);
<span class="boring">}</span></code></pre></pre>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::mesh::primitives::*;

spawn_cube(world, Vec3::new(0.0, 1.0, 0.0), 1.0);
spawn_sphere(world, Vec3::new(2.0, 1.0, 0.0), 0.5);
spawn_plane(world, Vec3::zeros(), Vec2::new(10.0, 10.0));
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-objects"><a class="header" href="#physics-objects">Physics Objects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::*;

// Dynamic cube
spawn_dynamic_physics_cube(world, Vec3::new(0.0, 5.0, 0.0), Vec3::new(1.0, 1.0, 1.0), 1.0);

// Static floor
spawn_static_physics_cube(world, Vec3::new(0.0, -0.5, 0.0), Vec3::new(50.0, 1.0, 50.0));

// Dynamic sphere
spawn_dynamic_physics_sphere(world, Vec3::new(0.0, 10.0, 0.0), 0.5, 1.0);
<span class="boring">}</span></code></pre></pre>
<h3 id="character-controllers"><a class="header" href="#character-controllers">Character Controllers</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First-person player
let (player, camera) = spawn_first_person_player(world, Vec3::new(0.0, 2.0, 0.0));

// Custom character controller
let controller = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | CHARACTER_CONTROLLER,
    1,
)[0];

if let Some(cc) = world.get_character_controller_mut(controller) {
    *cc = CharacterControllerComponent::new_capsule(0.5, 0.3);
    cc.max_speed = 5.0;
    cc.jump_impulse = 6.0;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-models"><a class="header" href="#loading-models">Loading Models</a></h2>
<p>Load glTF/GLB models:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

let model_bytes = include_bytes!("../assets/character.glb");
let result = import_gltf_from_bytes(model_bytes)?;

// Register textures
for (name, (rgba_data, width, height)) in result.textures {
    world.queue_command(WorldCommand::LoadTexture {
        name,
        rgba_data,
        width,
        height,
    });
}

// Register meshes
for (name, mesh) in result.meshes {
    mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
}

// Spawn prefab
for prefab in result.prefabs {
    let entity = spawn_prefab_with_skins(
        world,
        &amp;prefab,
        &amp;result.animations,
        &amp;result.skins,
        Vec3::new(0.0, 0.0, 0.0),
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="despawning-entities"><a class="header" href="#despawning-entities">Despawning Entities</a></h2>
<p>Remove entities from the world:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Immediate despawn
world.despawn(entity);

// Deferred despawn (safe during iteration)
world.command_queue.despawn(entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="entity-with-parent"><a class="header" href="#entity-with-parent">Entity with Parent</a></h2>
<p>Spawn an entity as a child:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parent = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];
let child = world.spawn_entities(LOCAL_TRANSFORM | GLOBAL_TRANSFORM | PARENT, 1)[0];

world.update_parent(child, Some(Parent(Some(parent))));
world.set_local_transform(child, LocalTransform {
    translation: Vec3::new(0.0, 1.0, 0.0),  // 1 unit above parent
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-entities"><a class="header" href="#querying-entities">Querying Entities</a></h1>
<h2 id="basic-queries"><a class="header" href="#basic-queries">Basic Queries</a></h2>
<p>Query entities with specific components using component flags:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all entities with transforms
for entity in world.query(LOCAL_TRANSFORM | GLOBAL_TRANSFORM) {
    if let Some(transform) = world.get_local_transform(entity) {
        println!("Entity at {:?}", transform.translation);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-query-patterns"><a class="header" href="#common-query-patterns">Common Query Patterns</a></h2>
<h3 id="renderable-entities"><a class="header" href="#renderable-entities">Renderable Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RENDERABLE: ComponentFlags = LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF;

for entity in world.query(RENDERABLE) {
    let transform = world.get_global_transform(entity).unwrap();
    let mesh = world.get_render_mesh(entity).unwrap();
    // Process renderable
}
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-entities"><a class="header" href="#physics-entities">Physics Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query(RIGID_BODY_COMPONENT | LOCAL_TRANSFORM) {
    if let Some(rb) = world.get_rigid_body(entity) {
        if rb.body_type == RigidBodyType::Dynamic {
            // Process dynamic body
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="animated-entities"><a class="header" href="#animated-entities">Animated Entities</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query(ANIMATION_PLAYER) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.speed = 1.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering-results"><a class="header" href="#filtering-results">Filtering Results</a></h2>
<p>Filter query results with additional checks:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entity in world.query(LIGHT) {
    let light = world.get_light(entity).unwrap();

    // Only process point lights
    if light.light_type == LightType::Point {
        // Update point light
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-components"><a class="header" href="#checking-components">Checking Components</a></h2>
<p>Check if an entity has specific components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.has_component(entity, RENDER_MESH) {
    // Entity is renderable
}

if world.has_component(entity, ANIMATION_PLAYER | SKIN) {
    // Entity is animated
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-single-entities"><a class="header" href="#getting-single-entities">Getting Single Entities</a></h2>
<p>For singleton-like entities, query and take the first:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get player entity (assuming only one exists)
let player = world.query(CHARACTER_CONTROLLER).next();

if let Some(player_entity) = player {
    let controller = world.get_character_controller(player_entity);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="entity-count"><a class="header" href="#entity-count">Entity Count</a></h2>
<p>Count entities matching a query:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let renderable_count = world.query(RENDER_MESH).count();
let light_count = world.query(LIGHT).count();

println!("Renderables: {}, Lights: {}", renderable_count, light_count);
<span class="boring">}</span></code></pre></pre>
<h2 id="named-entity-lookup"><a class="header" href="#named-entity-lookup">Named Entity Lookup</a></h2>
<p>If entities have the <code>Name</code> component:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_by_name(world: &amp;World, name: &amp;str) -&gt; Option&lt;Entity&gt; {
    for entity in world.query(NAME) {
        if let Some(entity_name) = world.get_name(entity) {
            if entity_name.0 == name {
                return Some(entity);
            }
        }
    }
    None
}

let player = find_by_name(world, "Player");
<span class="boring">}</span></code></pre></pre>
<h2 id="children-queries"><a class="header" href="#children-queries">Children Queries</a></h2>
<p>Query children of a specific parent:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(children) = world.children_cache.get(&amp;parent_entity) {
    for child in children {
        if let Some(transform) = world.get_local_transform(*child) {
            // Process child transform (relative to parent)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iteration-with-index"><a class="header" href="#iteration-with-index">Iteration with Index</a></h2>
<p>When you need the iteration index:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (index, entity) in world.query(RENDER_MESH).enumerate() {
    println!("Entity {} at index {}", entity, index);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="collecting-entities"><a class="header" href="#collecting-entities">Collecting Entities</a></h2>
<p>Collect query results for later processing:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let enemies: Vec&lt;Entity&gt; = world.query(ENEMY_TAG | HEALTH).collect();

for enemy in &amp;enemies {
    // Safe to modify world here since we're not iterating
    apply_damage(world, *enemy, 10.0);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cameras-1"><a class="header" href="#cameras-1">Cameras</a></h1>
<p>Cameras define what the player sees in your game.</p>
<h2 id="camera-components-1"><a class="header" href="#camera-components-1">Camera Components</a></h2>
<p>A camera entity needs these components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PERSPECTIVE_CAMERA,
    1
)[0];
<span class="boring">}</span></code></pre></pre>
<h2 id="spawning-cameras"><a class="header" href="#spawning-cameras">Spawning Cameras</a></h2>
<h3 id="basic-camera"><a class="header" href="#basic-camera">Basic Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = spawn_camera(
    world,
    Vec3::new(0.0, 5.0, 10.0),
    "Main Camera".to_string(),
);
world.resources.active_camera = Some(camera);
<span class="boring">}</span></code></pre></pre>
<h3 id="pan-orbit-camera"><a class="header" href="#pan-orbit-camera">Pan-Orbit Camera</a></h3>
<p>For editor-style camera controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::camera::commands::spawn_pan_orbit_camera;

let camera = spawn_pan_orbit_camera(
    world,
    Vec3::new(0.0, 2.0, 0.0),  // focus point
    10.0,                       // radius (distance)
    0.5,                        // yaw (horizontal angle)
    0.4,                        // pitch (vertical angle)
    "Orbit Camera".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-systems"><a class="header" href="#camera-systems">Camera Systems</a></h2>
<h3 id="fly-camera"><a class="header" href="#fly-camera">Fly Camera</a></h3>
<p>Free-flying camera with WASD controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    fly_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pan-orbit-camera-1"><a class="header" href="#pan-orbit-camera-1">Pan-Orbit Camera</a></h3>
<p>Orbit around a focus point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::camera::systems::pan_orbit_camera_system;

fn run_systems(&amp;mut self, world: &amp;mut World) {
    pan_orbit_camera_system(world);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="follow-camera"><a class="header" href="#follow-camera">Follow Camera</a></h3>
<p>Make camera follow a target:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn follow_camera_system(world: &amp;mut World, target: Entity, camera: Entity) {
    let Some(target_pos) = world.get_local_transform(target).map(|t| t.translation) else {
        return;
    };

    let offset = Vec3::new(0.0, 5.0, -10.0);
    let camera_pos = target_pos + offset;

    if let Some(transform) = world.get_local_transform_mut(camera) {
        transform.translation = camera_pos;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="perspective-vs-orthographic"><a class="header" href="#perspective-vs-orthographic">Perspective vs Orthographic</a></h2>
<h3 id="perspective-camera"><a class="header" href="#perspective-camera">Perspective Camera</a></h3>
<p>Standard 3D perspective with depth:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_perspective_camera(camera, PerspectiveCamera {
    fov: 1.0,        // ~57 degrees
    aspect: 16.0 / 9.0,
    near: 0.1,
    far: 1000.0,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="orthographic-camera"><a class="header" href="#orthographic-camera">Orthographic Camera</a></h3>
<p>No perspective distortion (useful for 2D or isometric):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_camera(camera, Camera {
    projection: ProjectionMode::Orthographic,
    smoothing: None,
});

world.set_orthographic_camera(camera, OrthographicCamera {
    size: 10.0,
    near: 0.1,
    far: 100.0,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="controlling-pan-orbit-camera"><a class="header" href="#controlling-pan-orbit-camera">Controlling Pan-Orbit Camera</a></h2>
<p>Modify pan-orbit camera at runtime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(pan_orbit) = world.get_pan_orbit_camera_mut(camera) {
    // Change focus point
    pan_orbit.target_focus = Vec3::new(0.0, 2.0, 0.0);

    // Zoom in/out
    pan_orbit.target_radius = 5.0;

    // Rotate
    pan_orbit.target_yaw += 0.1;
    pan_orbit.target_pitch += 0.05;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-smoothing"><a class="header" href="#camera-smoothing">Camera Smoothing</a></h2>
<p>Add smoothing for smoother camera movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_camera(camera, Camera {
    projection: ProjectionMode::Perspective,
    smoothing: Some(CameraSmoothing {
        position_smoothing: 5.0,
        rotation_smoothing: 10.0,
    }),
});
<span class="boring">}</span></code></pre></pre>
<h2 id="screen-to-world-conversion"><a class="header" href="#screen-to-world-conversion">Screen-to-World Conversion</a></h2>
<p>Convert screen coordinates to world ray:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::picking::PickingRay;

let screen_pos = Vec2::new(mouse_x, mouse_y);
if let Some(ray) = PickingRay::from_screen_position(world, screen_pos) {
    let origin = ray.origin;
    let direction = ray.direction;
    // Use ray for picking, projectiles, etc.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-cameras"><a class="header" href="#multiple-cameras">Multiple Cameras</a></h2>
<p>Switch between cameras:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyGame {
    main_camera: Entity,
    debug_camera: Entity,
}

fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
    if state == KeyState::Pressed &amp;&amp; key == KeyCode::Tab {
        let current = world.resources.active_camera;
        world.resources.active_camera = if current == Some(self.main_camera) {
            Some(self.debug_camera)
        } else {
            Some(self.main_camera)
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshes--models"><a class="header" href="#meshes--models">Meshes &amp; Models</a></h1>
<h2 id="built-in-primitives"><a class="header" href="#built-in-primitives">Built-in Primitives</a></h2>
<p>Nightshade provides basic geometric primitives:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::mesh::primitives::*;

spawn_cube(world, Vec3::new(0.0, 1.0, 0.0), 1.0);
spawn_sphere(world, Vec3::new(2.0, 1.0, 0.0), 0.5);
spawn_plane(world, Vec3::zeros(), Vec2::new(10.0, 10.0));
spawn_cylinder(world, Vec3::new(-2.0, 1.0, 0.0), 0.5, 1.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-gltfglb-models"><a class="header" href="#loading-gltfglb-models">Loading glTF/GLB Models</a></h2>
<h3 id="basic-loading"><a class="header" href="#basic-loading">Basic Loading</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

const MODEL_BYTES: &amp;[u8] = include_bytes!("../assets/character.glb");

fn load_model(world: &amp;mut World) -&gt; Option&lt;Entity&gt; {
    let result = import_gltf_from_bytes(MODEL_BYTES).ok()?;

    // Register textures
    for (name, (rgba_data, width, height)) in result.textures {
        world.queue_command(WorldCommand::LoadTexture {
            name,
            rgba_data,
            width,
            height,
        });
    }

    // Register meshes
    for (name, mesh) in result.meshes {
        mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
    }

    // Spawn first prefab
    result.prefabs.first().map(|prefab| {
        spawn_prefab_with_skins(
            world,
            prefab,
            &amp;result.animations,
            &amp;result.skins,
            Vec3::zeros(),
        )
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-custom-positiontransform"><a class="header" href="#with-custom-positiontransform">With Custom Position/Transform</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_model_at(world: &amp;mut World, prefab: &amp;Prefab, position: Vec3, scale: f32) -&gt; Entity {
    let entity = spawn_prefab(world, prefab, position);

    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.scale = Vec3::new(scale, scale, scale);
    }

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="filtered-animation-channels"><a class="header" href="#filtered-animation-channels">Filtered Animation Channels</a></h3>
<p>Remove root motion from animations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let root_bone_indices: HashSet&lt;usize&gt; = [0, 1, 2, 3].into();

let filtered_animations: Vec&lt;AnimationClip&gt; = result
    .animations
    .iter()
    .map(|clip| AnimationClip {
        name: clip.name.clone(),
        duration: clip.duration,
        channels: clip
            .channels
            .iter()
            .filter(|channel| {
                // Skip translation on all bones
                if channel.target_property == AnimationProperty::Translation {
                    return false;
                }
                // Skip rotation on root bones
                if root_bone_indices.contains(&amp;channel.target_node)
                    &amp;&amp; channel.target_property == AnimationProperty::Rotation
                {
                    return false;
                }
                true
            })
            .cloned()
            .collect(),
    })
    .collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="manual-mesh-creation"><a class="header" href="#manual-mesh-creation">Manual Mesh Creation</a></h2>
<p>Create meshes programmatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::mesh::*;

let vertices = vec![
    Vertex {
        position: [0.0, 0.0, 0.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [0.0, 0.0],
        ..Default::default()
    },
    Vertex {
        position: [1.0, 0.0, 0.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [1.0, 0.0],
        ..Default::default()
    },
    Vertex {
        position: [0.5, 0.0, 1.0],
        normal: [0.0, 1.0, 0.0],
        tex_coords: [0.5, 1.0],
        ..Default::default()
    },
];

let indices = vec![0, 1, 2];

let mesh = Mesh {
    vertices,
    indices,
    ..Default::default()
};

mesh_cache_insert(&amp;mut world.resources.mesh_cache, "triangle".to_string(), mesh);
<span class="boring">}</span></code></pre></pre>
<h2 id="mesh-component"><a class="header" href="#mesh-component">Mesh Component</a></h2>
<p>Assign a mesh to an entity:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RENDER_MESH | MATERIAL_REF,
    1
)[0];

world.set_render_mesh(entity, RenderMesh {
    mesh_name: "triangle".to_string(),
    gpu_mesh_id: None,
});

world.set_material_ref(entity, MaterialRef::new("default".to_string()));
<span class="boring">}</span></code></pre></pre>
<h2 id="instanced-meshes"><a class="header" href="#instanced-meshes">Instanced Meshes</a></h2>
<p>For rendering many copies of the same mesh efficiently:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_instanced_mesh(entity, InstancedMesh {
    mesh_name: "tree".to_string(),
    instance_count: 1000,
    instance_data: instance_transforms,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="mesh-cache"><a class="header" href="#mesh-cache">Mesh Cache</a></h2>
<p>Access the mesh cache:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if mesh exists
if world.resources.mesh_cache.contains("cube") {
    // Mesh is available
}

// Get mesh data (for physics, etc.)
if let Some(mesh) = world.resources.mesh_cache.get("terrain") {
    let vertices: Vec&lt;Vec3&gt; = mesh.vertices.iter()
        .map(|v| Vec3::new(v.position[0], v.position[1], v.position[2]))
        .collect();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="skinned-meshes"><a class="header" href="#skinned-meshes">Skinned Meshes</a></h2>
<p>For animated characters with skeletons:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = spawn_prefab_with_skins(
    world,
    &amp;prefab,
    &amp;animations,
    &amp;skins,
    position,
);

// The entity will have Skin and AnimationPlayer components
if let Some(player) = world.get_animation_player_mut(entity) {
    player.playing = true;
    player.looping = true;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shadow-casting"><a class="header" href="#shadow-casting">Shadow Casting</a></h2>
<p>Control whether a mesh casts shadows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable shadow casting
world.set_casts_shadow(entity, CastsShadow(true));

// Disable shadow casting (for UI elements, etc.)
world.set_casts_shadow(entity, CastsShadow(false));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<p>Materials define the visual appearance of meshes using PBR (Physically Based Rendering).</p>
<h2 id="material-structure"><a class="header" href="#material-structure">Material Structure</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Material {
    pub base_color: [f32; 4],
    pub base_color_texture: Option&lt;String&gt;,
    pub metallic: f32,
    pub roughness: f32,
    pub metallic_roughness_texture: Option&lt;String&gt;,
    pub normal_texture: Option&lt;String&gt;,
    pub normal_scale: f32,
    pub occlusion_texture: Option&lt;String&gt;,
    pub occlusion_strength: f32,
    pub emissive_factor: [f32; 3],
    pub emissive_texture: Option&lt;String&gt;,
    pub alpha_mode: AlphaMode,
    pub alpha_cutoff: f32,
    pub double_sided: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-materials"><a class="header" href="#creating-materials">Creating Materials</a></h2>
<h3 id="basic-colored-material"><a class="header" href="#basic-colored-material">Basic Colored Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::material::*;

let red_material = Material {
    base_color: [1.0, 0.0, 0.0, 1.0],
    roughness: 0.5,
    metallic: 0.0,
    ..Default::default()
};

material_registry_insert(
    &amp;mut world.resources.material_registry,
    "red".to_string(),
    red_material,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="metallic-material"><a class="header" href="#metallic-material">Metallic Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let gold_material = Material {
    base_color: [1.0, 0.84, 0.0, 1.0],
    roughness: 0.3,
    metallic: 1.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="emissive-material"><a class="header" href="#emissive-material">Emissive Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glowing_material = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [2.0, 8.0, 10.0],
    roughness: 0.8,
    metallic: 0.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="transparent-material"><a class="header" href="#transparent-material">Transparent Material</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glass_material = Material {
    base_color: [0.9, 0.95, 1.0, 0.3],
    alpha_mode: AlphaMode::Blend,
    roughness: 0.1,
    metallic: 0.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="alpha-modes"><a class="header" href="#alpha-modes">Alpha Modes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AlphaMode {
    Opaque,       // Fully opaque, alpha ignored
    Mask,         // Binary transparency using alpha_cutoff
    Blend,        // Full alpha blending
}
<span class="boring">}</span></code></pre></pre>
<h3 id="alpha-cutoff-mask-mode"><a class="header" href="#alpha-cutoff-mask-mode">Alpha Cutoff (Mask Mode)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foliage_material = Material {
    base_color: [0.2, 0.8, 0.2, 1.0],
    alpha_mode: AlphaMode::Mask,
    alpha_cutoff: 0.5,  // Pixels with alpha &lt; 0.5 are discarded
    double_sided: true,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="textured-materials"><a class="header" href="#textured-materials">Textured Materials</a></h2>
<h3 id="loading-textures"><a class="header" href="#loading-textures">Loading Textures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From embedded bytes
let texture_bytes = include_bytes!("../assets/wood.png");
let image = image::load_from_memory(texture_bytes).unwrap().to_rgba8();

world.queue_command(WorldCommand::LoadTexture {
    name: "wood".to_string(),
    rgba_data: image.to_vec(),
    width: image.width(),
    height: image.height(),
});
<span class="boring">}</span></code></pre></pre>
<h3 id="applying-textures"><a class="header" href="#applying-textures">Applying Textures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wood_material = Material {
    base_color: [1.0, 1.0, 1.0, 1.0],
    base_color_texture: Some("wood".to_string()),
    roughness: 0.8,
    metallic: 0.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="with-normal-map"><a class="header" href="#with-normal-map">With Normal Map</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let brick_material = Material {
    base_color: [1.0, 1.0, 1.0, 1.0],
    base_color_texture: Some("brick_color".to_string()),
    normal_texture: Some("brick_normal".to_string()),
    normal_scale: 1.0,
    roughness: 0.9,
    metallic: 0.0,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="assigning-materials-to-entities"><a class="header" href="#assigning-materials-to-entities">Assigning Materials to Entities</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register material
material_registry_insert(
    &amp;mut world.resources.material_registry,
    "my_material".to_string(),
    my_material,
);

// Add reference
if let Some(&amp;index) = world.resources.material_registry.registry.name_to_index.get("my_material") {
    world.resources.material_registry.registry.add_reference(index);
}

// Assign to entity
world.set_material_ref(entity, MaterialRef::new("my_material".to_string()));
<span class="boring">}</span></code></pre></pre>
<h2 id="procedural-textures"><a class="header" href="#procedural-textures">Procedural Textures</a></h2>
<p>Generate textures at runtime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_checkerboard(size: usize) -&gt; Vec&lt;u8&gt; {
    let mut data = vec![0u8; size * size * 4];

    for y in 0..size {
        for x in 0..size {
            let idx = (y * size + x) * 4;
            let checker = ((x / 32) + (y / 32)) % 2 == 0;
            let value = if checker { 255 } else { 64 };
            data[idx] = value;
            data[idx + 1] = value;
            data[idx + 2] = value;
            data[idx + 3] = 255;
        }
    }

    data
}

let checkerboard = create_checkerboard(256);
world.queue_command(WorldCommand::LoadTexture {
    name: "checkerboard".to_string(),
    rgba_data: checkerboard,
    width: 256,
    height: 256,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-material-presets"><a class="header" href="#common-material-presets">Common Material Presets</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_plastic(color: Vec3) -&gt; Material {
    Material {
        base_color: [color.x, color.y, color.z, 1.0],
        roughness: 0.4,
        metallic: 0.0,
        ..Default::default()
    }
}

fn create_metal(color: Vec3) -&gt; Material {
    Material {
        base_color: [color.x, color.y, color.z, 1.0],
        roughness: 0.2,
        metallic: 1.0,
        ..Default::default()
    }
}

fn create_rough(color: Vec3) -&gt; Material {
    Material {
        base_color: [color.x, color.y, color.z, 1.0],
        roughness: 0.95,
        metallic: 0.0,
        ..Default::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighting-1"><a class="header" href="#lighting-1">Lighting</a></h1>
<p>Nightshade supports three types of lights: directional, point, and spot lights.</p>
<h2 id="light-types"><a class="header" href="#light-types">Light Types</a></h2>
<h3 id="directional-light-sun"><a class="header" href="#directional-light-sun">Directional Light (Sun)</a></h3>
<p>Illuminates the entire scene from a direction, simulating distant light sources like the sun:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_sun(world: &amp;mut World) -&gt; Entity {
    let entity = world.spawn_entities(
        LIGHT | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
        1
    )[0];

    world.set_light(entity, Light {
        light_type: LightType::Directional,
        color: Vec3::new(1.0, 0.98, 0.95),
        intensity: 2.0,
        cast_shadows: true,
        shadow_bias: 0.001,
        ..Default::default()
    });

    // Point light downward at an angle
    world.set_local_transform(entity, LocalTransform {
        rotation: nalgebra_glm::quat_look_at(
            &amp;Vec3::new(-0.5, -1.0, -0.3).normalize(),
            &amp;Vec3::y(),
        ),
        ..Default::default()
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point Light</a></h3>
<p>Emits light in all directions from a point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_point_light(world: &amp;mut World, position: Vec3, color: Vec3, intensity: f32) -&gt; Entity {
    let entity = world.spawn_entities(
        LIGHT | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
        1
    )[0];

    world.set_light(entity, Light {
        light_type: LightType::Point,
        color,
        intensity,
        range: 10.0,
        cast_shadows: false,
        ..Default::default()
    });

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spot-light"><a class="header" href="#spot-light">Spot Light</a></h3>
<p>Cone-shaped light, perfect for flashlights or stage lighting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_spotlight(world: &amp;mut World, position: Vec3, direction: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LIGHT | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY,
        1
    )[0];

    world.set_light(entity, Light {
        light_type: LightType::Spot,
        color: Vec3::new(1.0, 0.95, 0.9),
        intensity: 15.0,
        range: 20.0,
        inner_cone_angle: 0.2,  // Full intensity cone
        outer_cone_angle: 0.5,  // Falloff cone
        cast_shadows: true,
        shadow_bias: 0.002,
    });

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        rotation: nalgebra_glm::quat_look_at(&amp;direction.normalize(), &amp;Vec3::y()),
        ..Default::default()
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="light-properties"><a class="header" href="#light-properties">Light Properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>color</code></td><td>RGB color of the light</td></tr>
<tr><td><code>intensity</code></td><td>Brightness multiplier</td></tr>
<tr><td><code>range</code></td><td>Maximum distance for point/spot lights</td></tr>
<tr><td><code>cast_shadows</code></td><td>Whether this light creates shadows</td></tr>
<tr><td><code>shadow_bias</code></td><td>Offset to reduce shadow acne</td></tr>
<tr><td><code>inner_cone_angle</code></td><td>Spot light inner cone (full intensity)</td></tr>
<tr><td><code>outer_cone_angle</code></td><td>Spot light outer cone (falloff edge)</td></tr>
</tbody></table>
</div>
<h2 id="dynamic-lighting"><a class="header" href="#dynamic-lighting">Dynamic Lighting</a></h2>
<h3 id="flickering-light"><a class="header" href="#flickering-light">Flickering Light</a></h3>
<p>Create a flickering fire/torch effect:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_flickering_light(world: &amp;mut World, light_entity: Entity) {
    let time = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;

    if let Some(light) = world.get_light_mut(light_entity) {
        let flicker1 = (time * 8.0).sin() * 0.15;
        let flicker2 = (time * 12.5).sin() * 0.1;
        let flicker3 = (time * 23.0).sin() * 0.08;

        let base_intensity = 3.5;
        light.intensity = base_intensity + flicker1 + flicker2 + flicker3;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="color-cycling"><a class="header" href="#color-cycling">Color Cycling</a></h3>
<p>Animated color changes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_disco_light(world: &amp;mut World, light_entity: Entity) {
    let time = world.resources.window.timing.uptime_milliseconds as f32 / 1000.0;

    if let Some(light) = world.get_light_mut(light_entity) {
        light.color = Vec3::new(
            (time * 2.0).sin() * 0.5 + 0.5,
            (time * 2.0 + 2.094).sin() * 0.5 + 0.5,
            (time * 2.0 + 4.188).sin() * 0.5 + 0.5,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flashlight-camera-attached-spotlight"><a class="header" href="#flashlight-camera-attached-spotlight">Flashlight (Camera-Attached Spotlight)</a></h2>
<p>Attach a spotlight to the camera for a flashlight effect:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_flashlight(world: &amp;mut World, flashlight: Entity) {
    let Some(camera) = world.resources.active_camera else { return };
    let Some(camera_transform) = world.get_global_transform(camera) else { return };

    let position = camera_transform.translation();
    let forward = camera_transform.forward();

    if let Some(transform) = world.get_local_transform_mut(flashlight) {
        transform.translation = position;
        transform.rotation = nalgebra_glm::quat_look_at(&amp;forward, &amp;Vec3::y());
    }
    world.mark_local_transform_dirty(flashlight);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shadow-settings"><a class="header" href="#shadow-settings">Shadow Settings</a></h2>
<p>Configure shadow quality through graphics resources:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.shadow_map_size = 2048;
world.resources.graphics.shadow_cascades = 4;
world.resources.graphics.shadow_distance = 100.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="ambient-light"><a class="header" href="#ambient-light">Ambient Light</a></h2>
<p>Set ambient lighting through the atmosphere:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.atmosphere = Atmosphere::Sky;
world.resources.graphics.ambient_intensity = 0.3;
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-lights"><a class="header" href="#multiple-lights">Multiple Lights</a></h2>
<p>Nightshade supports multiple lights in a scene:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_lighting(world: &amp;mut World) {
    // Main sun
    spawn_sun(world);

    // Fill lights
    spawn_point_light(world, Vec3::new(5.0, 3.0, 5.0), Vec3::new(0.8, 0.9, 1.0), 2.0);
    spawn_point_light(world, Vec3::new(-5.0, 3.0, -5.0), Vec3::new(1.0, 0.8, 0.7), 1.5);

    // Accent spotlight
    spawn_spotlight(world, Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.0, -1.0, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="post-processing"><a class="header" href="#post-processing">Post-Processing</a></h1>
<p>Nightshade includes several post-processing effects that enhance visual quality.</p>
<h2 id="available-effects"><a class="header" href="#available-effects">Available Effects</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Effect</th><th>Description</th></tr></thead><tbody>
<tr><td>Bloom</td><td>Glow around bright areas</td></tr>
<tr><td>SSAO</td><td>Screen-space ambient occlusion</td></tr>
<tr><td>Depth of Field</td><td>Focus blur effect</td></tr>
<tr><td>Tonemapping</td><td>HDR to LDR conversion</td></tr>
<tr><td>Color Grading</td><td>Color adjustments</td></tr>
<tr><td>Anti-Aliasing</td><td>Edge smoothing</td></tr>
</tbody></table>
</div>
<h2 id="enabling-effects"><a class="header" href="#enabling-effects">Enabling Effects</a></h2>
<p>Control post-processing through <code>world.resources.graphics</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    // Bloom
    world.resources.graphics.bloom_enabled = true;
    world.resources.graphics.bloom_intensity = 0.3;
    world.resources.graphics.bloom_threshold = 1.0;

    // SSAO
    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.ssao_radius = 0.5;
    world.resources.graphics.ssao_intensity = 1.0;

    // Tonemapping
    world.resources.graphics.tonemap_method = TonemapMethod::Aces;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bloom"><a class="header" href="#bloom">Bloom</a></h2>
<p>Bloom creates a glow effect around bright pixels:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.bloom_enabled = true;
world.resources.graphics.bloom_intensity = 0.5;  // Glow strength
world.resources.graphics.bloom_threshold = 1.0;  // Brightness cutoff
world.resources.graphics.bloom_radius = 0.005;   // Blur spread
<span class="boring">}</span></code></pre></pre>
<h3 id="emissive-materials-for-bloom"><a class="header" href="#emissive-materials-for-bloom">Emissive Materials for Bloom</a></h3>
<p>Materials with emissive values will glow:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glowing_material = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [2.0, 8.0, 10.0],  // High values create bloom
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="ssao-screen-space-ambient-occlusion"><a class="header" href="#ssao-screen-space-ambient-occlusion">SSAO (Screen-Space Ambient Occlusion)</a></h2>
<p>SSAO adds subtle shadows in corners and crevices:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.ssao_enabled = true;
world.resources.graphics.ssao_radius = 0.5;     // Sample radius
world.resources.graphics.ssao_intensity = 1.0;  // Shadow darkness
world.resources.graphics.ssao_bias = 0.025;     // Depth comparison bias
<span class="boring">}</span></code></pre></pre>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>Convert HDR colors to displayable range:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TonemapMethod {
    Reinhard,         // Simple, good for general use
    ReinhardExtended, // Reinhard with white point
    Aces,             // Film-like, high contrast
    AcesApprox,       // Faster ACES approximation
    Filmic,           // Cinematic look
    Uncharted2,       // Video game standard
    None,             // No tonemapping (LDR only)
}

world.resources.graphics.tonemap_method = TonemapMethod::Aces;
world.resources.graphics.exposure = 1.0;  // Brightness adjustment
<span class="boring">}</span></code></pre></pre>
<h2 id="depth-of-field"><a class="header" href="#depth-of-field">Depth of Field</a></h2>
<p>Blur based on distance from focus:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.dof_enabled = true;
world.resources.graphics.dof_focus_distance = 10.0;  // In-focus distance
world.resources.graphics.dof_aperture = 0.05;        // Blur amount
world.resources.graphics.dof_focal_length = 50.0;    // Lens simulation
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<p>Adjust colors for stylistic effect:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.saturation = 1.0;   // 0 = grayscale, 1 = normal
world.resources.graphics.contrast = 1.0;     // Higher = more contrast
world.resources.graphics.brightness = 0.0;   // Offset
<span class="boring">}</span></code></pre></pre>
<h2 id="vignette"><a class="header" href="#vignette">Vignette</a></h2>
<p>Darken screen edges:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.vignette_enabled = true;
world.resources.graphics.vignette_intensity = 0.3;
world.resources.graphics.vignette_radius = 0.75;
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-post-processing"><a class="header" href="#custom-post-processing">Custom Post-Processing</a></h2>
<p>Add custom passes via the render graph:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    // Custom shader pass
    let custom_pass = MyCustomPass::new(device);
    graph
        .pass(Box::new(custom_pass))
        .read("input", resources.scene_color)
        .write("output", resources.post_processed);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Post-processing effects have performance costs:</p>
<div class="table-wrapper"><table><thead><tr><th>Effect</th><th>Cost</th><th>Notes</th></tr></thead><tbody>
<tr><td>Bloom</td><td>Medium</td><td>Multiple blur passes</td></tr>
<tr><td>SSAO</td><td>High</td><td>Many depth samples</td></tr>
<tr><td>DoF</td><td>Medium</td><td>Gaussian blur</td></tr>
<tr><td>Tonemapping</td><td>Low</td><td>Per-pixel math</td></tr>
<tr><td>Color Grading</td><td>Low</td><td>Per-pixel math</td></tr>
</tbody></table>
</div>
<p>Disable expensive effects for better performance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_quality_low(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = false;
    world.resources.graphics.bloom_enabled = false;
}

fn set_quality_high(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.bloom_enabled = true;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-graph"><a class="header" href="#render-graph">Render Graph</a></h1>
<p>The render graph is a declarative system for defining the rendering pipeline. Passes are automatically ordered based on their dependencies.</p>
<h2 id="default-pipeline"><a class="header" href="#default-pipeline">Default Pipeline</a></h2>
<p>Nightshade's default render pipeline includes:</p>
<ol>
<li>Shadow map generation</li>
<li>Depth prepass</li>
<li>G-buffer pass</li>
<li>Lighting pass</li>
<li>Skybox</li>
<li>Transparent objects</li>
<li>Particles</li>
<li>Post-processing (bloom, SSAO, tonemapping)</li>
<li>UI/HUD</li>
<li>Final blit to screen</li>
</ol>
<h2 id="custom-render-graph"><a class="header" href="#custom-render-graph">Custom Render Graph</a></h2>
<p>Override the render graph in your State implementation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) {
        // Add custom passes
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-passes"><a class="header" href="#adding-passes">Adding Passes</a></h2>
<h3 id="built-in-passes"><a class="header" href="#built-in-passes">Built-in Passes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::passes;

fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    // Particle rendering
    let particle_pass = passes::ParticlePass::new(device, wgpu::TextureFormat::Rgba16Float);
    graph
        .pass(Box::new(particle_pass))
        .slot("color", resources.scene_color)
        .slot("depth", resources.depth);

    // Bloom
    let bloom_pass = passes::BloomPass::new(device, 1920, 1080);
    graph
        .pass(Box::new(bloom_pass))
        .read("hdr", resources.scene_color)
        .write("bloom", resources.bloom);

    // SSAO
    let ssao_pass = passes::SsaoPass::new(device);
    graph
        .pass(Box::new(ssao_pass))
        .read("depth", resources.depth)
        .read("normals", resources.view_normals)
        .write("ssao_raw", resources.ssao_raw);

    // SSAO blur
    let ssao_blur_pass = passes::SsaoBlurPass::new(device);
    graph
        .pass(Box::new(ssao_blur_pass))
        .read("ssao_raw", resources.ssao_raw)
        .write("ssao", resources.ssao);

    // Final composite
    let postprocess_pass = passes::PostProcessPass::new(device, surface_format, 0.3);
    graph
        .pass(Box::new(postprocess_pass))
        .read("hdr", resources.scene_color)
        .read("bloom", resources.bloom)
        .read("ssao", resources.ssao)
        .write("output", resources.swapchain);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-custom-textures"><a class="header" href="#creating-custom-textures">Creating Custom Textures</a></h2>
<p>Add intermediate textures for custom passes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let custom_texture = graph
    .add_color_texture("my_effect")
    .format(wgpu::TextureFormat::Rgba16Float)
    .size(1920, 1080)
    .clear_color(wgpu::Color::BLACK)
    .transient();  // Freed after use
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-pass-implementation"><a class="header" href="#custom-pass-implementation">Custom Pass Implementation</a></h2>
<p>Implement the <code>PassNode</code> trait for custom passes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::render_graph::{PassNode, ResourceInput, ResourceOutput};

pub struct MyCustomPass {
    pipeline: wgpu::RenderPipeline,
    bind_group_layout: wgpu::BindGroupLayout,
}

impl PassNode&lt;World&gt; for MyCustomPass {
    fn name(&amp;self) -&gt; &amp;str {
        "my_custom_pass"
    }

    fn inputs(&amp;self) -&gt; Vec&lt;ResourceInput&gt; {
        vec![
            ResourceInput::texture("input_color"),
        ]
    }

    fn outputs(&amp;self) -&gt; Vec&lt;ResourceOutput&gt; {
        vec![
            ResourceOutput::texture("output_color"),
        ]
    }

    fn execute(
        &amp;mut self,
        world: &amp;mut World,
        encoder: &amp;mut wgpu::CommandEncoder,
        resources: &amp;RenderResources,
    ) {
        // Get input/output textures from resources
        // Create render pass
        // Draw full-screen quad with shader
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pass-dependencies"><a class="header" href="#pass-dependencies">Pass Dependencies</a></h2>
<p>The graph automatically orders passes based on read/write dependencies:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pass A writes to "intermediate"
graph
    .pass(Box::new(pass_a))
    .write("intermediate", texture_a);

// Pass B reads from "intermediate" - automatically runs after Pass A
graph
    .pass(Box::new(pass_b))
    .read("intermediate", texture_a)
    .write("final", texture_b);
<span class="boring">}</span></code></pre></pre>
<h2 id="render-resources"><a class="header" href="#render-resources">Render Resources</a></h2>
<p>Available built-in resources:</p>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td><code>scene_color</code></td><td>HDR color buffer</td></tr>
<tr><td><code>depth</code></td><td>Depth buffer</td></tr>
<tr><td><code>view_normals</code></td><td>World-space normals</td></tr>
<tr><td><code>ssao_raw</code></td><td>Raw SSAO output</td></tr>
<tr><td><code>ssao</code></td><td>Blurred SSAO</td></tr>
<tr><td><code>bloom</code></td><td>Bloom texture</td></tr>
<tr><td><code>swapchain</code></td><td>Final output</td></tr>
</tbody></table>
</div>
<h2 id="conditional-passes"><a class="header" href="#conditional-passes">Conditional Passes</a></h2>
<p>Enable/disable passes based on settings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if world.resources.graphics.bloom_enabled {
    let bloom_pass = passes::BloomPass::new(device, width, height);
    graph.pass(Box::new(bloom_pass))
        .read("hdr", resources.scene_color)
        .write("bloom", resources.bloom);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-overview"><a class="header" href="#physics-overview">Physics Overview</a></h1>
<p>Nightshade integrates Rapier3D for physics simulation, providing rigid body dynamics, collision detection, and character controllers.</p>
<h2 id="enabling-physics"><a class="header" href="#enabling-physics">Enabling Physics</a></h2>
<p>Physics is enabled with the <code>physics</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "physics"] }
</code></pre>
<h2 id="physics-world"><a class="header" href="#physics-world">Physics World</a></h2>
<p>The physics world is accessed through resources:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let physics = &amp;mut world.resources.physics;

// Configuration
physics.gravity = Vec3::new(0.0, -9.81, 0.0);
physics.fixed_timestep = 1.0 / 60.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="rigid-bodies"><a class="header" href="#rigid-bodies">Rigid Bodies</a></h3>
<p>Objects that can move and be affected by forces:</p>
<ul>
<li><strong>Dynamic</strong>: Affected by gravity and forces</li>
<li><strong>Kinematic</strong>: Moved by code, affects dynamic bodies</li>
<li><strong>Static</strong>: Immovable, infinite mass</li>
</ul>
<h3 id="colliders"><a class="header" href="#colliders">Colliders</a></h3>
<p>Shapes used for collision detection:</p>
<ul>
<li>Box, Sphere, Capsule, Cylinder</li>
<li>Triangle mesh, Heightfield</li>
<li>Compound shapes</li>
</ul>
<h3 id="character-controllers-1"><a class="header" href="#character-controllers-1">Character Controllers</a></h3>
<p>Kinematic bodies with special handling for player movement.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    // Static floor
    spawn_static_physics_cube(
        world,
        Vec3::new(0.0, -0.5, 0.0),
        Vec3::new(50.0, 1.0, 50.0),
    );

    // Dynamic cubes
    for index in 0..10 {
        spawn_dynamic_physics_cube(
            world,
            Vec3::new(0.0, 2.0 + index as f32 * 1.5, 0.0),
            Vec3::new(1.0, 1.0, 1.0),
            1.0,  // mass
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-synchronization"><a class="header" href="#physics-synchronization">Physics Synchronization</a></h2>
<p>Physics runs at a fixed timestep. Transforms are automatically synchronized:</p>
<ol>
<li>Game logic updates entity transforms</li>
<li>Physics simulation steps (may run multiple times per frame)</li>
<li>Physics transforms sync back to entities</li>
<li>Interpolation smooths visual positions</li>
</ol>
<h2 id="querying-physics"><a class="header" href="#querying-physics">Querying Physics</a></h2>
<h3 id="raycasting"><a class="header" href="#raycasting">Raycasting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::queries::*;

let ray_origin = Vec3::new(0.0, 5.0, 0.0);
let ray_direction = Vec3::new(0.0, -1.0, 0.0);
let max_distance = 100.0;

if let Some(hit) = raycast(world, ray_origin, ray_direction, max_distance) {
    let hit_point = hit.point;
    let hit_normal = hit.normal;
    let hit_entity = hit.entity;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="overlap-tests"><a class="header" href="#overlap-tests">Overlap Tests</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if a sphere overlaps any colliders
let overlaps = sphere_overlap(world, center, radius);
for entity in overlaps {
    // Handle collision
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-materials"><a class="header" href="#physics-materials">Physics Materials</a></h2>
<p>Control friction and bounciness:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_physics_material(entity, PhysicsMaterialComponent {
    friction: 0.5,
    restitution: 0.3,  // Bounciness
    density: 1.0,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization"><a class="header" href="#debug-visualization">Debug Visualization</a></h2>
<p>Enable physics debug drawing:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.physics.debug_draw = true;

// In run_systems
physics_debug_draw_system(world);
<span class="boring">}</span></code></pre></pre>
<p>This renders:</p>
<ul>
<li>Collider shapes (wireframe)</li>
<li>Contact points</li>
<li>Collision normals</li>
</ul>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li>Use simple collider shapes (boxes, spheres) when possible</li>
<li>Disable collision between groups that don't need it</li>
<li>Use compound colliders instead of many small colliders</li>
<li>Set bodies to sleep when inactive</li>
<li>Use appropriate fixed timestep (60 Hz is standard)</li>
</ol>
<h2 id="joints"><a class="header" href="#joints">Joints</a></h2>
<p>Connect bodies with joints for:</p>
<ul>
<li>Doors (revolute)</li>
<li>Drawers (prismatic)</li>
<li>Ropes (rope/spring)</li>
<li>Chains (spherical)</li>
</ul>
<p>See <a href="physics-joints.html">Physics Joints</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-bodies-1"><a class="header" href="#rigid-bodies-1">Rigid Bodies</a></h1>
<p>Rigid bodies are the foundation of physics simulation. They define how objects move and respond to forces.</p>
<h2 id="body-types"><a class="header" href="#body-types">Body Types</a></h2>
<h3 id="dynamic-bodies"><a class="header" href="#dynamic-bodies">Dynamic Bodies</a></h3>
<p>Fully simulated physics objects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | RIGID_BODY_COMPONENT | COLLIDER_COMPONENT,
    1
)[0];

world.set_rigid_body(entity, RigidBodyComponent {
    body_type: RigidBodyType::Dynamic,
    handle: None,  // Set by physics sync
});

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Ball { radius: 0.5 },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="kinematic-bodies"><a class="header" href="#kinematic-bodies">Kinematic Bodies</a></h3>
<p>Controlled by code, not affected by forces:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_rigid_body(entity, RigidBodyComponent {
    body_type: RigidBodyType::Kinematic,
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<p>Move kinematic bodies by updating their transform:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(transform) = world.get_local_transform_mut(kinematic_entity) {
    transform.translation.x += velocity.x * dt;
}
world.mark_local_transform_dirty(kinematic_entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="static-bodies"><a class="header" href="#static-bodies">Static Bodies</a></h3>
<p>Immovable objects (floors, walls):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_rigid_body(entity, RigidBodyComponent {
    body_type: RigidBodyType::Static,
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="helper-functions-1"><a class="header" href="#helper-functions-1">Helper Functions</a></h2>
<h3 id="spawning-physics-cubes"><a class="header" href="#spawning-physics-cubes">Spawning Physics Cubes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::*;

// Dynamic cube
let cube = spawn_dynamic_physics_cube(
    world,
    Vec3::new(0.0, 5.0, 0.0),  // position
    Vec3::new(1.0, 1.0, 1.0),  // size
    1.0,                        // mass
);

// With custom material
let cube = spawn_dynamic_physics_cube_with_material(
    world,
    Vec3::new(0.0, 5.0, 0.0),
    Vec3::new(1.0, 1.0, 1.0),
    2.0,
    my_material,
);

// Static cube
spawn_static_physics_cube(
    world,
    Vec3::new(0.0, -0.5, 0.0),
    Vec3::new(50.0, 1.0, 50.0),
);
<span class="boring">}</span></code></pre></pre>
<h3 id="spawning-physics-spheres"><a class="header" href="#spawning-physics-spheres">Spawning Physics Spheres</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sphere = spawn_dynamic_physics_sphere(
    world,
    Vec3::new(0.0, 10.0, 0.0),
    0.5,   // radius
    1.0,   // mass
);
<span class="boring">}</span></code></pre></pre>
<h3 id="spawning-physics-cylinders"><a class="header" href="#spawning-physics-cylinders">Spawning Physics Cylinders</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cylinder = spawn_dynamic_physics_cylinder(
    world,
    Vec3::new(0.0, 5.0, 0.0),
    0.5,   // half_height
    0.3,   // radius
    2.0,   // mass
);
<span class="boring">}</span></code></pre></pre>
<h2 id="applying-forces"><a class="header" href="#applying-forces">Applying Forces</a></h2>
<p>Access the Rapier rigid body directly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_force(world: &amp;mut World, entity: Entity, force: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.add_force(
            rapier3d::prelude::Vector::new(force.x, force.y, force.z),
            true,  // wake up if sleeping
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="applying-impulses"><a class="header" href="#applying-impulses">Applying Impulses</a></h2>
<p>Instant velocity change:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_impulse(world: &amp;mut World, entity: Entity, impulse: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.apply_impulse(
            rapier3d::prelude::Vector::new(impulse.x, impulse.y, impulse.z),
            true,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-velocity"><a class="header" href="#setting-velocity">Setting Velocity</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_velocity(world: &amp;mut World, entity: Entity, velocity: Vec3) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.set_linvel(
            rapier3d::prelude::Vector::new(velocity.x, velocity.y, velocity.z),
            true,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-velocity"><a class="header" href="#getting-velocity">Getting Velocity</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_velocity(world: &amp;World, entity: Entity) -&gt; Option&lt;Vec3&gt; {
    let rb_component = world.get_rigid_body(entity)?;
    let handle = rb_component.handle?;
    let rigid_body = world.resources.physics.rigid_body_set.get(handle.into())?;

    let vel = rigid_body.linvel();
    Some(Vec3::new(vel.x, vel.y, vel.z))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mass-properties"><a class="header" href="#mass-properties">Mass Properties</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_mass(world: &amp;mut World, entity: Entity, mass: f32) {
    let Some(rb_component) = world.get_rigid_body(entity) else { return };
    let Some(handle) = rb_component.handle else { return };

    if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
        rigid_body.set_additional_mass(mass, true);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="locking-axes"><a class="header" href="#locking-axes">Locking Axes</a></h2>
<p>Prevent rotation or translation on specific axes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    // Lock rotation (useful for character controllers)
    rigid_body.lock_rotations(true, true);

    // Lock specific translation axes
    // rigid_body.lock_translations(true, true);  // Lock X and Y
}
<span class="boring">}</span></code></pre></pre>
<h2 id="damping"><a class="header" href="#damping">Damping</a></h2>
<p>Add drag to slow objects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    rigid_body.set_linear_damping(0.5);   // Translation damping
    rigid_body.set_angular_damping(0.5);  // Rotation damping
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sleeping"><a class="header" href="#sleeping">Sleeping</a></h2>
<p>Bodies automatically sleep when stationary. Wake them:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rigid_body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
    rigid_body.wake_up(true);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colliders-1"><a class="header" href="#colliders-1">Colliders</a></h1>
<p>Colliders define the physical shape of objects for collision detection.</p>
<h2 id="collider-shapes"><a class="header" href="#collider-shapes">Collider Shapes</a></h2>
<h3 id="ball-sphere"><a class="header" href="#ball-sphere">Ball (Sphere)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Ball { radius: 0.5 },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cuboid-box"><a class="header" href="#cuboid-box">Cuboid (Box)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Cuboid {
        half_extents: Vec3::new(1.0, 0.5, 1.0),  // Half-sizes
    },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="capsule"><a class="header" href="#capsule">Capsule</a></h3>
<p>Perfect for characters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Capsule {
        half_height: 0.5,  // Height of cylindrical section
        radius: 0.3,
    },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cylinder"><a class="header" href="#cylinder">Cylinder</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Cylinder {
        half_height: 1.0,
        radius: 0.5,
    },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cone"><a class="header" href="#cone">Cone</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Cone {
        half_height: 1.0,
        radius: 0.5,
    },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="triangle-mesh"><a class="header" href="#triangle-mesh">Triangle Mesh</a></h3>
<p>For complex static geometry:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vertices: Vec&lt;Vec3&gt; = mesh.vertices.iter()
    .map(|v| Vec3::new(v.position[0], v.position[1], v.position[2]))
    .collect();

let indices: Vec&lt;[u32; 3]&gt; = mesh.indices
    .chunks(3)
    .map(|c| [c[0], c[1], c[2]])
    .collect();

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Trimesh { vertices, indices },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="heightfield"><a class="header" href="#heightfield">Heightfield</a></h3>
<p>For terrain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heights: Vec&lt;Vec&lt;f32&gt;&gt; = generate_height_grid(64, 64);

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Heightfield {
        heights,
        scale: Vec3::new(100.0, 50.0, 100.0),
    },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="compound"><a class="header" href="#compound">Compound</a></h3>
<p>Multiple shapes combined:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shapes = vec![
    (ColliderShape::Cuboid { half_extents: Vec3::new(0.5, 0.1, 0.5) }, body_offset),
    (ColliderShape::Ball { radius: 0.3 }, head_offset),
];

world.set_collider(entity, ColliderComponent {
    shape: ColliderShape::Compound { shapes },
    handle: None,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-materials-1"><a class="header" href="#physics-materials-1">Physics Materials</a></h2>
<p>Control surface properties:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_physics_material(entity, PhysicsMaterialComponent {
    friction: 0.5,      // Sliding resistance (0 = ice, 1 = rubber)
    restitution: 0.3,   // Bounciness (0 = no bounce, 1 = perfect bounce)
    density: 1.0,       // Mass per unit volume
});
<span class="boring">}</span></code></pre></pre>
<h3 id="material-examples"><a class="header" href="#material-examples">Material Examples</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ice
let ice = PhysicsMaterialComponent {
    friction: 0.05,
    restitution: 0.1,
    density: 0.9,
};

// Rubber
let rubber = PhysicsMaterialComponent {
    friction: 0.9,
    restitution: 0.8,
    density: 1.1,
};

// Metal
let metal = PhysicsMaterialComponent {
    friction: 0.4,
    restitution: 0.2,
    density: 7.8,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="collision-groups"><a class="header" href="#collision-groups">Collision Groups</a></h2>
<p>Filter which objects collide:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rapier3d::prelude::*;

// Define groups
const GROUP_PLAYER: Group = Group::GROUP_1;
const GROUP_ENEMY: Group = Group::GROUP_2;
const GROUP_PROJECTILE: Group = Group::GROUP_3;
const GROUP_WORLD: Group = Group::GROUP_4;

// Player collides with enemies and world, not own projectiles
let player_filter = CollisionGroups::new(
    GROUP_PLAYER,
    GROUP_ENEMY | GROUP_WORLD,
);
<span class="boring">}</span></code></pre></pre>
<h2 id="sensor-colliders"><a class="header" href="#sensor-colliders">Sensor Colliders</a></h2>
<p>Detect overlaps without physical response:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a trigger zone
if let Some(collider) = world.resources.physics.collider_set.get_mut(handle.into()) {
    collider.set_sensor(true);
}
<span class="boring">}</span></code></pre></pre>
<p>Check sensor overlaps in your game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_trigger_zone(world: &amp;World, trigger_entity: Entity) -&gt; Vec&lt;Entity&gt; {
    // Query overlapping entities
    let overlaps = overlap_test(world, trigger_entity);
    overlaps
}
<span class="boring">}</span></code></pre></pre>
<h2 id="collision-events"><a class="header" href="#collision-events">Collision Events</a></h2>
<p>Query collision pairs:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // Check for new collisions this frame
    for (entity_a, entity_b, started) in world.resources.physics.collision_events() {
        if started {
            handle_collision_start(entity_a, entity_b);
        } else {
            handle_collision_end(entity_a, entity_b);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="convex-decomposition"><a class="header" href="#convex-decomposition">Convex Decomposition</a></h2>
<p>For complex shapes on dynamic bodies, use convex decomposition:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rapier3d::prelude::*;

// This creates multiple convex pieces from a concave mesh
let decomposed = SharedShape::convex_decomposition(&amp;vertices, &amp;indices);
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Shape</th><th>Performance</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Ball</td><td>Fastest</td><td>Rolling objects</td></tr>
<tr><td>Cuboid</td><td>Fast</td><td>Crates, buildings</td></tr>
<tr><td>Capsule</td><td>Fast</td><td>Characters</td></tr>
<tr><td>Cylinder</td><td>Medium</td><td>Barrels, pillars</td></tr>
<tr><td>Convex</td><td>Medium</td><td>Simple props</td></tr>
<tr><td>Trimesh</td><td>Slow</td><td>Static terrain only</td></tr>
<tr><td>Compound</td><td>Varies</td><td>Complex dynamic objects</td></tr>
</tbody></table>
</div>
<ul>
<li>Prefer primitive shapes over meshes</li>
<li>Use trimesh only for static geometry</li>
<li>Compound colliders are better than multiple entities</li>
<li>Simplify collision geometry vs visual geometry</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-controllers-2"><a class="header" href="#character-controllers-2">Character Controllers</a></h1>
<p>Character controllers provide smooth player movement with collision handling, slopes, and stairs.</p>
<h2 id="first-person-player"><a class="header" href="#first-person-player">First-Person Player</a></h2>
<p>The easiest way to get started:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::character::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let (player_entity, camera_entity) = spawn_first_person_player(
        world,
        Vec3::new(0.0, 2.0, 0.0),  // Spawn position
    );

    self.player = Some(player_entity);
    world.resources.active_camera = Some(camera_entity);

    // Customize controller
    if let Some(controller) = world.get_character_controller_mut(player_entity) {
        controller.max_speed = 5.0;
        controller.sprint_speed_multiplier = 2.0;
        controller.jump_impulse = 6.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-character-controller"><a class="header" href="#custom-character-controller">Custom Character Controller</a></h2>
<p>For third-person or specialized characters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_character(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        NAME | LOCAL_TRANSFORM | GLOBAL_TRANSFORM | LOCAL_TRANSFORM_DIRTY | CHARACTER_CONTROLLER,
        1,
    )[0];

    world.set_name(entity, Name("Player".to_string()));
    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    if let Some(controller) = world.get_character_controller_mut(entity) {
        *controller = CharacterControllerComponent::new_capsule(0.5, 0.3);
        controller.max_speed = 3.0;
        controller.acceleration = 15.0;
        controller.deceleration = 20.0;
        controller.jump_impulse = 4.0;
        controller.sprint_speed_multiplier = 2.0;
        controller.crouch_enabled = false;
    }

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="controller-properties"><a class="header" href="#controller-properties">Controller Properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>max_speed</code></td><td>Walking speed</td><td>5.0</td></tr>
<tr><td><code>sprint_speed_multiplier</code></td><td>Sprint multiplier</td><td>1.5</td></tr>
<tr><td><code>acceleration</code></td><td>Speed up rate</td><td>20.0</td></tr>
<tr><td><code>deceleration</code></td><td>Slow down rate</td><td>25.0</td></tr>
<tr><td><code>jump_impulse</code></td><td>Jump strength</td><td>5.0</td></tr>
<tr><td><code>gravity_multiplier</code></td><td>Fall speed modifier</td><td>1.0</td></tr>
<tr><td><code>crouch_enabled</code></td><td>Allow crouching</td><td>true</td></tr>
<tr><td><code>crouch_height</code></td><td>Height when crouched</td><td>0.6</td></tr>
</tbody></table>
</div>
<h2 id="movement-input"><a class="header" href="#movement-input">Movement Input</a></h2>
<p>Character controllers automatically process input, but you can also control them manually:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn custom_movement_system(world: &amp;mut World, player: Entity) {
    let input = &amp;world.resources.input;

    // Gather movement direction
    let mut direction = Vec3::zeros();
    if input.keyboard.is_key_pressed(KeyCode::KeyW) {
        direction.z -= 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyS) {
        direction.z += 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyA) {
        direction.x -= 1.0;
    }
    if input.keyboard.is_key_pressed(KeyCode::KeyD) {
        direction.x += 1.0;
    }

    if let Some(controller) = world.get_character_controller_mut(player) {
        controller.input_direction = direction;
        controller.wants_jump = input.keyboard.is_key_pressed(KeyCode::Space);
        controller.wants_sprint = input.keyboard.is_key_pressed(KeyCode::ShiftLeft);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ground-detection"><a class="header" href="#ground-detection">Ground Detection</a></h2>
<p>Check if the character is grounded:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller(player) {
    if controller.is_grounded {
        // On ground - can jump
    } else {
        // In air
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="slope-handling"><a class="header" href="#slope-handling">Slope Handling</a></h2>
<p>Controllers automatically handle slopes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller_mut(player) {
    controller.max_slope_angle = 0.8;  // ~45 degrees in radians
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-integration"><a class="header" href="#camera-integration">Camera Integration</a></h2>
<h3 id="first-person-camera"><a class="header" href="#first-person-camera">First-Person Camera</a></h3>
<p>The camera is a child of the player:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PERSPECTIVE_CAMERA | PARENT,
    1
)[0];

world.update_parent(camera, Some(Parent(Some(player))));
world.set_local_transform(camera, LocalTransform {
    translation: Vec3::new(0.0, 0.8, 0.0),  // Eye height
    ..Default::default()
});

world.resources.active_camera = Some(camera);
<span class="boring">}</span></code></pre></pre>
<h3 id="third-person-camera"><a class="header" href="#third-person-camera">Third-Person Camera</a></h3>
<p>Follow the character with an offset:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn third_person_camera_system(world: &amp;mut World, player: Entity, camera: Entity) {
    let Some(player_pos) = world.get_local_transform(player).map(|t| t.translation) else {
        return;
    };

    // Camera behind and above player
    let offset = Vec3::new(0.0, 3.0, 8.0);
    let target_pos = player_pos + offset;

    if let Some(pan_orbit) = world.get_pan_orbit_camera_mut(camera) {
        pan_orbit.target_focus = player_pos + Vec3::new(0.0, 1.0, 0.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-climbing"><a class="header" href="#step-climbing">Step Climbing</a></h2>
<p>Controllers can automatically climb small steps:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(controller) = world.get_character_controller_mut(player) {
    controller.max_step_height = 0.3;  // Can climb 30cm steps
    controller.min_step_width = 0.1;   // Minimum step width
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interaction-cooldowns"><a class="header" href="#interaction-cooldowns">Interaction Cooldowns</a></h2>
<p>Prevent rapid repeated actions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PlayerState {
    interaction_cooldown: f32,
}

fn update_cooldown(state: &amp;mut PlayerState, dt: f32) {
    state.interaction_cooldown = (state.interaction_cooldown - dt).max(0.0);
}

fn can_interact(state: &amp;PlayerState) -&gt; bool {
    state.interaction_cooldown &lt;= 0.0
}

fn set_cooldown(state: &amp;mut PlayerState, duration: f32) {
    state.interaction_cooldown = duration;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-joints"><a class="header" href="#physics-joints">Physics Joints</a></h1>
<p>Joints connect two rigid bodies together, constraining their relative motion.</p>
<h2 id="joint-types"><a class="header" href="#joint-types">Joint Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Joint</th><th>Description</th><th>Use Cases</th></tr></thead><tbody>
<tr><td>Fixed</td><td>Rigid connection</td><td>Welded objects</td></tr>
<tr><td>Spherical</td><td>Ball-and-socket</td><td>Pendulums, ragdolls</td></tr>
<tr><td>Revolute</td><td>Hinge</td><td>Doors, wheels</td></tr>
<tr><td>Prismatic</td><td>Slider</td><td>Drawers, pistons</td></tr>
<tr><td>Rope</td><td>Max distance</td><td>Ropes, chains</td></tr>
<tr><td>Spring</td><td>Elastic</td><td>Suspension, bouncy connections</td></tr>
</tbody></table>
</div>
<h2 id="fixed-joint"><a class="header" href="#fixed-joint">Fixed Joint</a></h2>
<p>Rigidly connects two bodies:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::physics::joints::*;

create_fixed_joint(
    world,
    body_a,
    body_b,
    FixedJoint::new()
        .with_local_anchor1(Vec3::new(0.5, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="spherical-joint-ball-and-socket"><a class="header" href="#spherical-joint-ball-and-socket">Spherical Joint (Ball-and-Socket)</a></h2>
<p>Allows rotation in all directions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pendulum
let anchor = spawn_static_physics_cube(world, Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.3, 0.3, 0.3));
let ball = spawn_dynamic_physics_sphere(world, Vec3::new(0.0, 3.0, 0.0), 0.5, 1.0);

create_spherical_joint(
    world,
    anchor,
    ball,
    SphericalJoint::new()
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 1.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="revolute-joint-hinge"><a class="header" href="#revolute-joint-hinge">Revolute Joint (Hinge)</a></h2>
<p>Rotates around a single axis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Door hinge
let door_frame = spawn_static_entity(world);
let door = spawn_dynamic_physics_cube(world, Vec3::new(0.5, 1.0, 0.0), Vec3::new(1.0, 2.0, 0.1), 5.0);

create_revolute_joint(
    world,
    door_frame,
    door,
    RevoluteJoint::new(JointAxisDirection::Y)  // Rotate around Y axis
        .with_local_anchor1(Vec3::new(0.0, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0))
        .with_limits(JointLimits::new(-1.5, 1.5)),  // Limit rotation
);
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-motor"><a class="header" href="#adding-motor">Adding Motor</a></h3>
<p>Make the door swing automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RevoluteJoint::new(JointAxisDirection::Y)
    .with_motor(0.0, 10.0, 5.0, 100.0)  // target_pos, target_vel, stiffness, damping
<span class="boring">}</span></code></pre></pre>
<h2 id="prismatic-joint-slider"><a class="header" href="#prismatic-joint-slider">Prismatic Joint (Slider)</a></h2>
<p>Slides along an axis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Drawer
let cabinet = spawn_static_entity(world);
let drawer = spawn_dynamic_physics_cube(world, Vec3::new(0.0, 0.0, 0.5), Vec3::new(0.8, 0.3, 0.5), 2.0);

create_prismatic_joint(
    world,
    cabinet,
    drawer,
    PrismaticJoint::new(JointAxisDirection::Z)  // Slide on Z axis
        .with_local_anchor1(Vec3::new(0.0, 0.0, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.0, -0.5))
        .with_limits(JointLimits::new(0.0, 0.8)),  // Min/max extension
);
<span class="boring">}</span></code></pre></pre>
<h2 id="rope-joint"><a class="header" href="#rope-joint">Rope Joint</a></h2>
<p>Maximum distance constraint:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ceiling = spawn_static_entity(world);
let weight = spawn_dynamic_physics_sphere(world, Vec3::new(0.0, 0.0, 0.0), 0.3, 2.0);

create_rope_joint(
    world,
    ceiling,
    weight,
    RopeJoint::new(2.0)  // Max length
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.0, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="spring-joint"><a class="header" href="#spring-joint">Spring Joint</a></h2>
<p>Elastic connection:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let anchor = spawn_static_entity(world);
let bob = spawn_dynamic_physics_sphere(world, Vec3::new(0.0, -2.0, 0.0), 0.3, 1.0);

create_spring_joint(
    world,
    anchor,
    bob,
    SpringJoint::new(1.5, 50.0, 2.0)  // rest_length, stiffness, damping
        .with_local_anchor1(Vec3::new(0.0, -0.15, 0.0))
        .with_local_anchor2(Vec3::new(0.0, 0.2, 0.0)),
);
<span class="boring">}</span></code></pre></pre>
<h2 id="joint-limits"><a class="header" href="#joint-limits">Joint Limits</a></h2>
<p>Constrain movement range:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rotation limits (radians)
RevoluteJoint::new(JointAxisDirection::Z)
    .with_limits(JointLimits::new(-1.57, 1.57))  // -90° to +90°

// Translation limits (meters)
PrismaticJoint::new(JointAxisDirection::X)
    .with_limits(JointLimits::new(-2.0, 2.0))
<span class="boring">}</span></code></pre></pre>
<h2 id="breaking-joints"><a class="header" href="#breaking-joints">Breaking Joints</a></h2>
<p>Joints can break under force:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(joint) = world.resources.physics.get_joint_mut(joint_handle) {
    joint.set_max_force(1000.0);  // Break if force exceeds this
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chain-example"><a class="header" href="#chain-example">Chain Example</a></h2>
<p>Create a chain of connected spheres:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_chain(world: &amp;mut World, start: Vec3, links: usize) {
    let mut previous = spawn_static_physics_cube(world, start, Vec3::new(0.2, 0.2, 0.2));

    for index in 0..links {
        let position = start - Vec3::new(0.0, (index + 1) as f32 * 0.5, 0.0);
        let link = spawn_dynamic_physics_sphere(world, position, 0.15, 0.5);

        create_spherical_joint(
            world,
            previous,
            link,
            SphericalJoint::new()
                .with_local_anchor1(Vec3::new(0.0, -0.2, 0.0))
                .with_local_anchor2(Vec3::new(0.0, 0.2, 0.0)),
        );

        previous = link;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interactive-door-example"><a class="header" href="#interactive-door-example">Interactive Door Example</a></h2>
<p>Complete door with momentum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_interactive_door(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let frame = spawn_static_physics_cube(
        world,
        position,
        Vec3::new(0.1, 2.0, 0.1),
    );

    let door = spawn_dynamic_physics_cube_with_material(
        world,
        position + Vec3::new(0.5, 0.0, 0.0),
        Vec3::new(1.0, 2.0, 0.1),
        10.0,
        wood_material,
    );

    // Lock vertical rotation
    if let Some(rb) = world.get_rigid_body(door) {
        if let Some(handle) = rb.handle {
            if let Some(body) = world.resources.physics.rigid_body_set.get_mut(handle.into()) {
                body.lock_rotations(true, true);  // Only Y rotation allowed
            }
        }
    }

    create_revolute_joint(
        world,
        frame,
        door,
        RevoluteJoint::new(JointAxisDirection::Y)
            .with_local_anchor1(Vec3::new(0.05, 0.0, 0.0))
            .with_local_anchor2(Vec3::new(-0.5, 0.0, 0.0))
            .with_limits(JointLimits::new(-2.0, 2.0)),
    );

    door
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-animated-models"><a class="header" href="#loading-animated-models">Loading Animated Models</a></h1>
<p>Nightshade supports skeletal animation through glTF/GLB files.</p>
<h2 id="loading-an-animated-model"><a class="header" href="#loading-an-animated-model">Loading an Animated Model</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::prefab::*;

const CHARACTER_GLB: &amp;[u8] = include_bytes!("../assets/character.glb");

fn load_character(world: &amp;mut World) -&gt; Option&lt;Entity&gt; {
    let result = import_gltf_from_bytes(CHARACTER_GLB).ok()?;

    // Register textures
    for (name, (rgba_data, width, height)) in result.textures {
        world.queue_command(WorldCommand::LoadTexture {
            name,
            rgba_data,
            width,
            height,
        });
    }

    // Register meshes
    for (name, mesh) in result.meshes {
        mesh_cache_insert(&amp;mut world.resources.mesh_cache, name, mesh);
    }

    // Spawn with animations and skins
    result.prefabs.first().map(|prefab| {
        spawn_prefab_with_skins(
            world,
            prefab,
            &amp;result.animations,
            &amp;result.skins,
            Vec3::zeros(),
        )
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-data-structure"><a class="header" href="#animation-data-structure">Animation Data Structure</a></h2>
<p>Loaded animations contain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationClip {
    pub name: String,
    pub duration: f32,
    pub channels: Vec&lt;AnimationChannel&gt;,
}

pub struct AnimationChannel {
    pub target_node: usize,
    pub target_property: AnimationProperty,
    pub interpolation: Interpolation,
    pub times: Vec&lt;f32&gt;,
    pub values: Vec&lt;f32&gt;,
}

pub enum AnimationProperty {
    Translation,
    Rotation,
    Scale,
    MorphWeights,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering-animation-channels"><a class="header" href="#filtering-animation-channels">Filtering Animation Channels</a></h2>
<p>Remove unwanted channels (like root motion):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_animations(animations: &amp;[AnimationClip]) -&gt; Vec&lt;AnimationClip&gt; {
    let root_bone_indices: std::collections::HashSet&lt;usize&gt; = [0, 1, 2, 3].into();

    animations
        .iter()
        .map(|clip| AnimationClip {
            name: clip.name.clone(),
            duration: clip.duration,
            channels: clip
                .channels
                .iter()
                .filter(|channel| {
                    // Remove translation from all bones (prevent sliding)
                    if channel.target_property == AnimationProperty::Translation {
                        return false;
                    }
                    // Remove rotation from root bones
                    if root_bone_indices.contains(&amp;channel.target_node)
                        &amp;&amp; channel.target_property == AnimationProperty::Rotation
                    {
                        return false;
                    }
                    true
                })
                .cloned()
                .collect(),
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="storing-animation-indices"><a class="header" href="#storing-animation-indices">Storing Animation Indices</a></h2>
<p>Track which animations are which:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AnimationIndices {
    idle: Option&lt;usize&gt;,
    walk: Option&lt;usize&gt;,
    run: Option&lt;usize&gt;,
    jump: Option&lt;usize&gt;,
}

fn find_animation_indices(clips: &amp;[AnimationClip]) -&gt; AnimationIndices {
    let mut indices = AnimationIndices {
        idle: None,
        walk: None,
        run: None,
        jump: None,
    };

    for (index, clip) in clips.iter().enumerate() {
        let name = clip.name.to_lowercase();
        if name.contains("idle") {
            indices.idle = Some(index);
        } else if name.contains("walk") {
            indices.walk = Some(index);
        } else if name.contains("run") {
            indices.run = Some(index);
        } else if name.contains("jump") {
            indices.jump = Some(index);
        }
    }

    indices
}
<span class="boring">}</span></code></pre></pre>
<h2 id="skeleton-structure"><a class="header" href="#skeleton-structure">Skeleton Structure</a></h2>
<p>Skinned meshes have a skeleton:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Skin {
    pub joints: Vec&lt;Entity&gt;,
    pub inverse_bind_matrices: Vec&lt;Mat4&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>joints</code> array contains entities for each bone in the skeleton.</p>
<h2 id="attaching-objects-to-bones"><a class="header" href="#attaching-objects-to-bones">Attaching Objects to Bones</a></h2>
<p>Attach items to specific bones:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attach_to_bone(world: &amp;mut World, item: Entity, bone: Entity) {
    world.update_parent(item, Some(Parent(Some(bone))));

    if let Some(transform) = world.get_local_transform_mut(item) {
        transform.translation = Vec3::new(0.0, 0.1, 0.0);  // Local offset
        transform.scale = Vec3::new(1.0, 1.0, 1.0);
    }
}

// Example: Attach hat to head bone
fn attach_hat(world: &amp;mut World, character: Entity, hat: Entity) {
    // Find head bone (usually named "Head" or similar in the model)
    if let Some(skin) = world.get_skin(character) {
        for joint in &amp;skin.joints {
            if let Some(name) = world.get_name(*joint) {
                if name.0.contains("Head") {
                    attach_to_bone(world, hat, *joint);
                    return;
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="finding-bones-by-name"><a class="header" href="#finding-bones-by-name">Finding Bones by Name</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_bone_by_name(world: &amp;World, character: Entity, bone_name: &amp;str) -&gt; Option&lt;Entity&gt; {
    let skin = world.get_skin(character)?;

    for joint in &amp;skin.joints {
        if let Some(name) = world.get_name(*joint) {
            if name.0.contains(bone_name) {
                return Some(*joint);
            }
        }
    }
    None
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-animated-characters"><a class="header" href="#multiple-animated-characters">Multiple Animated Characters</a></h2>
<p>Load once, spawn many:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CharacterFactory {
    prefab: Prefab,
    animations: Vec&lt;AnimationClip&gt;,
    skins: Vec&lt;SkinData&gt;,
}

impl CharacterFactory {
    fn new(bytes: &amp;[u8]) -&gt; Option&lt;Self&gt; {
        let result = import_gltf_from_bytes(bytes).ok()?;
        Some(Self {
            prefab: result.prefabs.into_iter().next()?,
            animations: result.animations,
            skins: result.skins,
        })
    }

    fn spawn(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        spawn_prefab_with_skins(
            world,
            &amp;self.prefab,
            &amp;self.animations,
            &amp;self.skins,
            position,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-playback"><a class="header" href="#animation-playback">Animation Playback</a></h1>
<p>Control animation playback through the <code>AnimationPlayer</code> component.</p>
<h2 id="animationplayer-component"><a class="header" href="#animationplayer-component">AnimationPlayer Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnimationPlayer {
    pub clips: Vec&lt;AnimationClip&gt;,
    pub current_clip: usize,
    pub playing: bool,
    pub speed: f32,
    pub time: f32,
    pub looping: bool,
    pub crossfade_duration: f32,
    pub bone_mapping: HashMap&lt;String, Entity&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-playback"><a class="header" href="#basic-playback">Basic Playback</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_animation(world: &amp;mut World, entity: Entity, clip_index: usize) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.current_clip = clip_index;
        player.time = 0.0;
        player.playing = true;
        player.looping = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="controlling-speed"><a class="header" href="#controlling-speed">Controlling Speed</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_animation_speed(world: &amp;mut World, entity: Entity, speed: f32) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.speed = speed;  // 1.0 = normal, 0.5 = half speed, 2.0 = double
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pausing-and-resuming"><a class="header" href="#pausing-and-resuming">Pausing and Resuming</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pause_animation(world: &amp;mut World, entity: Entity) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.playing = false;
    }
}

fn resume_animation(world: &amp;mut World, entity: Entity) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.playing = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="looping"><a class="header" href="#looping">Looping</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_looping(world: &amp;mut World, entity: Entity, looping: bool) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.looping = looping;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-animation-state"><a class="header" href="#checking-animation-state">Checking Animation State</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_animation_finished(world: &amp;World, entity: Entity) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        if !player.looping {
            let clip = &amp;player.clips[player.current_clip];
            return player.time &gt;= clip.duration;
        }
    }
    false
}

fn get_animation_progress(world: &amp;World, entity: Entity) -&gt; f32 {
    if let Some(player) = world.get_animation_player(entity) {
        let clip = &amp;player.clips[player.current_clip];
        player.time / clip.duration
    } else {
        0.0
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-by-name"><a class="header" href="#animation-by-name">Animation by Name</a></h2>
<p>Find and play animations by name:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_animation_by_name(world: &amp;mut World, entity: Entity, name: &amp;str) -&gt; bool {
    if let Some(player) = world.get_animation_player_mut(entity) {
        for (index, clip) in player.clips.iter().enumerate() {
            if clip.name.to_lowercase().contains(&amp;name.to_lowercase()) {
                player.current_clip = index;
                player.time = 0.0;
                player.playing = true;
                return true;
            }
        }
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-based-animation"><a class="header" href="#state-based-animation">State-Based Animation</a></h2>
<p>Common pattern for character animation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq)]
enum MovementState {
    Idle,
    Walking,
    Running,
    Jumping,
}

fn update_character_animation(
    world: &amp;mut World,
    entity: Entity,
    state: MovementState,
    indices: &amp;AnimationIndices,
    current: &amp;mut Option&lt;usize&gt;,
) {
    let target = match state {
        MovementState::Idle =&gt; indices.idle,
        MovementState::Walking =&gt; indices.walk,
        MovementState::Running =&gt; indices.run,
        MovementState::Jumping =&gt; indices.jump,
    };

    // Only change if different
    if target != *current {
        if let Some(index) = target {
            if let Some(player) = world.get_animation_player_mut(entity) {
                player.blend_to(index, 0.2);  // Smooth transition
                *current = Some(index);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="speed-based-on-movement"><a class="header" href="#speed-based-on-movement">Speed Based on Movement</a></h2>
<p>Match animation speed to movement speed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sync_animation_to_movement(world: &amp;mut World, entity: Entity, velocity: f32) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        // Assuming walk animation matches 3 m/s
        let base_speed = 3.0;
        player.speed = (velocity / base_speed).clamp(0.5, 2.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="one-shot-animations"><a class="header" href="#one-shot-animations">One-Shot Animations</a></h2>
<p>Play an animation once without looping:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_once(world: &amp;mut World, entity: Entity, clip_index: usize) {
    if let Some(player) = world.get_animation_player_mut(entity) {
        player.current_clip = clip_index;
        player.time = 0.0;
        player.playing = true;
        player.looping = false;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="animation-events"><a class="header" href="#animation-events">Animation Events</a></h2>
<p>Trigger events at specific times:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_animation_events(world: &amp;World, entity: Entity, event_time: f32) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        let prev_time = player.time - world.resources.window.timing.delta_time * player.speed;
        // Check if we crossed the event time this frame
        prev_time &lt; event_time &amp;&amp; player.time &gt;= event_time
    } else {
        false
    }
}

// Usage: Play footstep sound at specific animation times
fn footstep_system(world: &amp;mut World, character: Entity) {
    if check_animation_events(world, character, 0.3) {
        play_sound(world, "footstep_left");
    }
    if check_animation_events(world, character, 0.8) {
        play_sound(world, "footstep_right");
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blending--transitions"><a class="header" href="#blending--transitions">Blending &amp; Transitions</a></h1>
<p>Smooth transitions between animations using cross-fading.</p>
<h2 id="cross-fade-transition"><a class="header" href="#cross-fade-transition">Cross-Fade Transition</a></h2>
<p>The <code>blend_to</code> method smoothly transitions between animations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(player) = world.get_animation_player_mut(entity) {
    player.blend_to(new_animation_index, 0.2);  // 0.2 second transition
}
<span class="boring">}</span></code></pre></pre>
<h2 id="blend-duration"><a class="header" href="#blend-duration">Blend Duration</a></h2>
<p>Choose appropriate durations:</p>
<div class="table-wrapper"><table><thead><tr><th>Transition</th><th>Duration</th><th>Notes</th></tr></thead><tbody>
<tr><td>Idle → Walk</td><td>0.2s</td><td>Natural start</td></tr>
<tr><td>Walk → Run</td><td>0.15s</td><td>Quick acceleration</td></tr>
<tr><td>Run → Idle</td><td>0.3s</td><td>Gradual stop</td></tr>
<tr><td>Any → Jump</td><td>0.1s</td><td>Responsive</td></tr>
<tr><td>Attack</td><td>0.05s</td><td>Immediate</td></tr>
</tbody></table>
</div>
<h2 id="movement-state-machine"><a class="header" href="#movement-state-machine">Movement State Machine</a></h2>
<p>Manage animation states cleanly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq)]
enum CharacterState {
    Idle,
    Walking,
    Running,
    Jumping,
    Falling,
    Landing,
}

struct AnimationController {
    state: CharacterState,
    current_animation: Option&lt;usize&gt;,
    indices: AnimationIndices,
}

impl AnimationController {
    fn update(&amp;mut self, world: &amp;mut World, entity: Entity, new_state: CharacterState) {
        if self.state == new_state {
            return;
        }

        let blend_time = self.get_blend_time(self.state, new_state);
        let target_anim = self.get_animation_for_state(new_state);

        if let Some(index) = target_anim {
            if let Some(player) = world.get_animation_player_mut(entity) {
                player.blend_to(index, blend_time);
                self.current_animation = Some(index);
            }
        }

        self.state = new_state;
    }

    fn get_blend_time(&amp;self, from: CharacterState, to: CharacterState) -&gt; f32 {
        match (from, to) {
            (CharacterState::Idle, CharacterState::Walking) =&gt; 0.2,
            (CharacterState::Walking, CharacterState::Running) =&gt; 0.15,
            (CharacterState::Running, CharacterState::Idle) =&gt; 0.3,
            (_, CharacterState::Jumping) =&gt; 0.1,
            _ =&gt; 0.2,
        }
    }

    fn get_animation_for_state(&amp;self, state: CharacterState) -&gt; Option&lt;usize&gt; {
        match state {
            CharacterState::Idle =&gt; self.indices.idle,
            CharacterState::Walking =&gt; self.indices.walk,
            CharacterState::Running =&gt; self.indices.run,
            CharacterState::Jumping =&gt; self.indices.jump,
            CharacterState::Falling =&gt; self.indices.jump,  // Reuse jump
            CharacterState::Landing =&gt; self.indices.idle,   // Brief idle
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="speed-based-blending"><a class="header" href="#speed-based-blending">Speed-Based Blending</a></h2>
<p>Blend between walk and run based on speed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_locomotion(world: &amp;mut World, entity: Entity, speed: f32, indices: &amp;AnimationIndices) {
    let walk_threshold = 2.0;
    let run_threshold = 5.0;

    let state = if speed &lt; 0.1 {
        MovementState::Idle
    } else if speed &lt; walk_threshold {
        MovementState::Walking
    } else {
        MovementState::Running
    };

    let target_anim = match state {
        MovementState::Idle =&gt; indices.idle,
        MovementState::Walking =&gt; indices.walk,
        MovementState::Running =&gt; indices.run,
    };

    if let Some(index) = target_anim {
        if let Some(player) = world.get_animation_player_mut(entity) {
            if player.current_clip != index {
                player.blend_to(index, 0.2);
            }

            // Adjust playback speed
            player.speed = match state {
                MovementState::Idle =&gt; 1.0,
                MovementState::Walking =&gt; speed / walk_threshold,
                MovementState::Running =&gt; speed / run_threshold,
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interrupt-handling"><a class="header" href="#interrupt-handling">Interrupt Handling</a></h2>
<p>Handle animation interrupts gracefully:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_attack(world: &amp;mut World, entity: Entity, attack_anim: usize, current_state: &amp;mut CharacterState) -&gt; bool {
    if let Some(player) = world.get_animation_player_mut(entity) {
        // Quick blend to attack
        player.blend_to(attack_anim, 0.05);
        player.looping = false;
        *current_state = CharacterState::Attacking;
        return true;
    }
    false
}

fn check_attack_finished(world: &amp;World, entity: Entity) -&gt; bool {
    if let Some(player) = world.get_animation_player(entity) {
        if !player.looping {
            let clip = &amp;player.clips[player.current_clip];
            return player.time &gt;= clip.duration * 0.9;  // 90% complete
        }
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<h2 id="additive-blending"><a class="header" href="#additive-blending">Additive Blending</a></h2>
<p>Layer animations (e.g., breathing on top of idle):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: This is a conceptual example - actual implementation depends on engine support
struct LayeredAnimation {
    base_animation: usize,
    additive_animations: Vec&lt;(usize, f32)&gt;,  // (index, weight)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="root-motion"><a class="header" href="#root-motion">Root Motion</a></h2>
<p>When animations include movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_root_motion(world: &amp;mut World, entity: Entity) {
    let Some(player) = world.get_animation_player(entity) else { return };

    let clip = &amp;player.clips[player.current_clip];
    // Extract root bone translation from animation
    // Apply to character controller

    // Note: Often you'll want to remove root motion from animations
    // and drive movement from game code instead
}
<span class="boring">}</span></code></pre></pre>
<h2 id="transition-rules"><a class="header" href="#transition-rules">Transition Rules</a></h2>
<p>Define clear rules for when transitions can occur:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn can_transition(from: CharacterState, to: CharacterState) -&gt; bool {
    match (from, to) {
        // Can always go to these states
        (_, CharacterState::Idle) =&gt; true,
        (_, CharacterState::Falling) =&gt; true,

        // Can't interrupt attacks
        (CharacterState::Attacking, _) =&gt; false,

        // Can only jump from ground
        (CharacterState::Falling, CharacterState::Jumping) =&gt; false,
        (CharacterState::Jumping, CharacterState::Jumping) =&gt; false,

        _ =&gt; true,
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-system"><a class="header" href="#audio-system">Audio System</a></h1>
<p>Nightshade uses Kira for audio playback, supporting both sound effects and music.</p>
<h2 id="enabling-audio"><a class="header" href="#enabling-audio">Enabling Audio</a></h2>
<p>Audio requires the <code>audio</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "audio"] }
</code></pre>
<h2 id="playing-sounds"><a class="header" href="#playing-sounds">Playing Sounds</a></h2>
<h3 id="basic-playback-1"><a class="header" href="#basic-playback-1">Basic Playback</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::audio::*;

// Play a sound effect
play_sound(world, "explosion", PlaybackSettings::default());

// Play with custom settings
play_sound(world, "footstep", PlaybackSettings {
    volume: 0.5,
    speed: 1.0,
    loop_sound: false,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-sounds"><a class="header" href="#loading-sounds">Loading Sounds</a></h3>
<p>Load sounds at initialization:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const EXPLOSION_WAV: &amp;[u8] = include_bytes!("../assets/sounds/explosion.wav");
const MUSIC_OGG: &amp;[u8] = include_bytes!("../assets/sounds/music.ogg");

fn initialize(&amp;mut self, world: &amp;mut World) {
    load_sound(world, "explosion", EXPLOSION_WAV);
    load_sound(world, "music", MUSIC_OGG);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="background-music"><a class="header" href="#background-music">Background Music</a></h2>
<h3 id="play-music"><a class="header" href="#play-music">Play Music</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn start_music(world: &amp;mut World) {
    play_sound(world, "music", PlaybackSettings {
        volume: 0.7,
        speed: 1.0,
        loop_sound: true,
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="control-music"><a class="header" href="#control-music">Control Music</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stop music
stop_sound(world, "music");

// Pause music
pause_sound(world, "music");

// Resume music
resume_sound(world, "music");

// Fade out
fade_sound(world, "music", 0.0, 2.0);  // Fade to 0 volume over 2 seconds
<span class="boring">}</span></code></pre></pre>
<h2 id="volume-control"><a class="header" href="#volume-control">Volume Control</a></h2>
<h3 id="master-volume"><a class="header" href="#master-volume">Master Volume</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.audio_engine.set_master_volume(0.8);
<span class="boring">}</span></code></pre></pre>
<h3 id="category-volumes"><a class="header" href="#category-volumes">Category Volumes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Music volume
world.resources.audio_engine.set_music_volume(0.7);

// Effects volume
world.resources.audio_engine.set_sfx_volume(1.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="sound-variations"><a class="header" href="#sound-variations">Sound Variations</a></h2>
<p>Play random variations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_footstep(world: &amp;mut World) {
    let sounds = ["footstep_1", "footstep_2", "footstep_3", "footstep_4"];
    let index = rand::random::&lt;usize&gt;() % sounds.len();
    play_sound(world, sounds[index], PlaybackSettings::default());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pitch-variation"><a class="header" href="#pitch-variation">Pitch Variation</a></h2>
<p>Add variety with pitch:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_with_variation(world: &amp;mut World, sound: &amp;str) {
    let pitch = 0.9 + rand::random::&lt;f32&gt;() * 0.2;  // 0.9 to 1.1
    play_sound(world, sound, PlaybackSettings {
        speed: pitch,
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-source-component"><a class="header" href="#audio-source-component">Audio Source Component</a></h2>
<p>Attach sounds to entities:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];

world.set_audio_source(entity, AudioSource {
    sound_name: "engine_loop".to_string(),
    spatial: true,
    volume: 1.0,
    loop_sound: true,
    playing: true,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-listener"><a class="header" href="#audio-listener">Audio Listener</a></h2>
<p>Mark the entity that "hears" sounds (usually the camera):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_audio_listener(camera_entity, AudioListener);
<span class="boring">}</span></code></pre></pre>
<h2 id="triggering-sounds-on-events"><a class="header" href="#triggering-sounds-on-events">Triggering Sounds on Events</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    // Play sound on collision
    for event in world.resources.physics.collision_events() {
        if event.started {
            play_sound(world, "impact", PlaybackSettings::default());
        }
    }

    // Play sound on input
    if world.resources.input.keyboard.is_key_just_pressed(KeyCode::Space) {
        play_sound(world, "jump", PlaybackSettings::default());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sound-cooldowns"><a class="header" href="#sound-cooldowns">Sound Cooldowns</a></h2>
<p>Prevent sound spam:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SoundCooldowns {
    footstep_timer: f32,
}

fn try_play_footstep(world: &amp;mut World, cooldowns: &amp;mut SoundCooldowns, dt: f32) {
    cooldowns.footstep_timer -= dt;

    if cooldowns.footstep_timer &lt;= 0.0 {
        play_sound(world, "footstep", PlaybackSettings::default());
        cooldowns.footstep_timer = 0.3;  // 300ms cooldown
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Extension</th><th>Notes</th></tr></thead><tbody>
<tr><td>WAV</td><td>.wav</td><td>Uncompressed, fast loading</td></tr>
<tr><td>OGG</td><td>.ogg</td><td>Compressed, good for music</td></tr>
<tr><td>MP3</td><td>.mp3</td><td>Compressed, widely supported</td></tr>
<tr><td>FLAC</td><td>.flac</td><td>Lossless compression</td></tr>
</tbody></table>
</div>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<p>Unload sounds when not needed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unload a specific sound
unload_sound(world, "explosion");

// Unload all sounds (e.g., on level change)
clear_all_sounds(world);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h1>
<p>3D positional audio creates immersive soundscapes where sounds have position and direction.</p>
<h2 id="audio-listener-1"><a class="header" href="#audio-listener-1">Audio Listener</a></h2>
<p>The listener is the "ear" in the scene - usually attached to the camera:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let camera = spawn_camera(world, Vec3::new(0.0, 2.0, 10.0), "Camera".to_string());
    world.resources.active_camera = Some(camera);

    // Make camera the audio listener
    world.set_audio_listener(camera, AudioListener);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spatial-audio-source"><a class="header" href="#spatial-audio-source">Spatial Audio Source</a></h2>
<p>Attach sounds to entities for positional audio:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_ambient_sound(world: &amp;mut World, position: Vec3, sound: &amp;str) -&gt; Entity {
    let entity = world.spawn_entities(
        AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM,
        1
    )[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    world.set_audio_source(entity, AudioSource {
        sound_name: sound.to_string(),
        spatial: true,
        volume: 1.0,
        loop_sound: true,
        playing: true,
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="distance-attenuation"><a class="header" href="#distance-attenuation">Distance Attenuation</a></h2>
<p>Sounds get quieter with distance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_audio_source(entity, AudioSource {
    sound_name: "waterfall".to_string(),
    spatial: true,
    volume: 1.0,
    loop_sound: true,
    playing: true,
    min_distance: 1.0,   // Full volume within this range
    max_distance: 50.0,  // Silent beyond this range
    rolloff: AudioRolloff::Linear,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="rolloff-modes"><a class="header" href="#rolloff-modes">Rolloff Modes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Linear</code></td><td>Linear falloff between min/max distance</td></tr>
<tr><td><code>Inverse</code></td><td>Realistic 1/distance falloff</td></tr>
<tr><td><code>Exponential</code></td><td>Steep falloff, good for small sounds</td></tr>
</tbody></table>
</div>
<h2 id="moving-sound-sources"><a class="header" href="#moving-sound-sources">Moving Sound Sources</a></h2>
<p>Sounds automatically track their entity's position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_helicopter(world: &amp;mut World, helicopter: Entity, dt: f32) {
    if let Some(transform) = world.get_local_transform_mut(helicopter) {
        // Move the helicopter
        transform.translation.x += 10.0 * dt;
    }
    world.mark_local_transform_dirty(helicopter);
    // Audio position updates automatically
}
<span class="boring">}</span></code></pre></pre>
<h2 id="doppler-effect"><a class="header" href="#doppler-effect">Doppler Effect</a></h2>
<p>Moving sounds experience pitch shift:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.audio_engine.set_doppler_factor(1.0);  // 0 = off, 1 = realistic
<span class="boring">}</span></code></pre></pre>
<h2 id="reverb-zones"><a class="header" href="#reverb-zones">Reverb Zones</a></h2>
<p>Create ambient reverb for different environments:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_cave_reverb(world: &amp;mut World) {
    world.resources.audio_engine.set_reverb(ReverbSettings {
        room_size: 0.9,
        damping: 0.3,
        wet_mix: 0.6,
        dry_mix: 0.8,
    });
}

fn set_outdoor_reverb(world: &amp;mut World) {
    world.resources.audio_engine.set_reverb(ReverbSettings {
        room_size: 0.2,
        damping: 0.8,
        wet_mix: 0.1,
        dry_mix: 1.0,
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="non-spatial-2d-audio"><a class="header" href="#non-spatial-2d-audio">Non-Spatial (2D) Audio</a></h2>
<p>UI sounds and music should not be spatial:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_audio_source(entity, AudioSource {
    sound_name: "ui_click".to_string(),
    spatial: false,  // Always same volume regardless of position
    volume: 1.0,
    loop_sound: false,
    playing: true,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="directional-audio-sources"><a class="header" href="#directional-audio-sources">Directional Audio Sources</a></h2>
<p>Some sounds are directional (like a speaker):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_audio_source(entity, AudioSource {
    sound_name: "announcement".to_string(),
    spatial: true,
    volume: 1.0,
    directional: true,
    cone_inner_angle: 0.5,  // Full volume in front
    cone_outer_angle: 1.5,  // Fades to sides
    cone_outer_gain: 0.2,   // Volume outside cone
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-listeners-split-screen"><a class="header" href="#multiple-listeners-split-screen">Multiple Listeners (Split-Screen)</a></h2>
<p>For split-screen games:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Not typically supported - most games use single listener
// For split-screen, consider:
// 1. Use the average position of both players
// 2. Disable spatial audio and use manual panning
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-occlusion"><a class="header" href="#audio-occlusion">Audio Occlusion</a></h2>
<p>Simple occlusion with raycast:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_audio_occlusion(world: &amp;mut World, source: Entity, listener: Entity) {
    let source_pos = world.get_global_transform(source).map(|t| t.translation());
    let listener_pos = world.get_global_transform(listener).map(|t| t.translation());

    if let (Some(src), Some(lst)) = (source_pos, listener_pos) {
        let direction = (lst - src).normalize();
        let distance = (lst - src).magnitude();

        // Check if something blocks the sound
        if let Some(_hit) = raycast(world, src, direction, distance) {
            // Something in the way - muffle the sound
            if let Some(audio) = world.get_audio_source_mut(source) {
                audio.volume = 0.3;
            }
        } else {
            // Clear path
            if let Some(audio) = world.get_audio_source_mut(source) {
                audio.volume = 1.0;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="ambient-soundscape"><a class="header" href="#ambient-soundscape">Ambient Soundscape</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_forest_ambience(world: &amp;mut World) {
    // Background ambient loop (non-spatial)
    spawn_ambient_sound(world, Vec3::zeros(), "forest_ambient");

    // Positioned bird sounds
    spawn_ambient_sound(world, Vec3::new(10.0, 5.0, 0.0), "bird_chirp");
    spawn_ambient_sound(world, Vec3::new(-8.0, 4.0, 5.0), "bird_song");

    // Stream
    spawn_ambient_sound(world, Vec3::new(0.0, 0.0, 20.0), "stream");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="footstep-system"><a class="header" href="#footstep-system">Footstep System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_footstep_at_position(world: &amp;mut World, position: Vec3) {
    let entity = world.spawn_entities(AUDIO_SOURCE | LOCAL_TRANSFORM | GLOBAL_TRANSFORM, 1)[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    world.set_audio_source(entity, AudioSource {
        sound_name: "footstep".to_string(),
        spatial: true,
        volume: 0.5,
        loop_sound: false,
        playing: true,
        auto_despawn: true,  // Remove entity when sound finishes
    });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard--mouse"><a class="header" href="#keyboard--mouse">Keyboard &amp; Mouse</a></h1>
<p>Handle keyboard and mouse input through the input resources.</p>
<h2 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h2>
<h3 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let keyboard = &amp;world.resources.input.keyboard;

    // Key currently held down
    if keyboard.is_key_pressed(KeyCode::KeyW) {
        move_forward();
    }

    // Key just pressed this frame
    if keyboard.is_key_just_pressed(KeyCode::Space) {
        jump();
    }

    // Key just released this frame
    if keyboard.is_key_just_released(KeyCode::ShiftLeft) {
        stop_sprinting();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-key-codes"><a class="header" href="#common-key-codes">Common Key Codes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody>
<tr><td>Letters</td><td><code>KeyCode::KeyA</code> through <code>KeyCode::KeyZ</code></td></tr>
<tr><td>Numbers</td><td><code>KeyCode::Digit0</code> through <code>KeyCode::Digit9</code></td></tr>
<tr><td>Arrow keys</td><td><code>KeyCode::ArrowUp</code>, <code>ArrowDown</code>, <code>ArrowLeft</code>, <code>ArrowRight</code></td></tr>
<tr><td>Space</td><td><code>KeyCode::Space</code></td></tr>
<tr><td>Shift</td><td><code>KeyCode::ShiftLeft</code>, <code>KeyCode::ShiftRight</code></td></tr>
<tr><td>Control</td><td><code>KeyCode::ControlLeft</code>, <code>KeyCode::ControlRight</code></td></tr>
<tr><td>Alt</td><td><code>KeyCode::AltLeft</code>, <code>KeyCode::AltRight</code></td></tr>
<tr><td>Escape</td><td><code>KeyCode::Escape</code></td></tr>
<tr><td>Enter</td><td><code>KeyCode::Enter</code></td></tr>
<tr><td>Tab</td><td><code>KeyCode::Tab</code></td></tr>
<tr><td>F keys</td><td><code>KeyCode::F1</code> through <code>KeyCode::F12</code></td></tr>
</tbody></table>
</div>
<h3 id="direct-event-handling"><a class="header" href="#direct-event-handling">Direct Event Handling</a></h3>
<p>Handle key events in the State trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
    if state == KeyState::Pressed {
        match key {
            KeyCode::Escape =&gt; self.paused = !self.paused,
            KeyCode::F11 =&gt; toggle_fullscreen(world),
            KeyCode::Digit1 =&gt; self.select_weapon(0),
            KeyCode::Digit2 =&gt; self.select_weapon(1),
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mouse-input"><a class="header" href="#mouse-input">Mouse Input</a></h2>
<h3 id="mouse-position"><a class="header" href="#mouse-position">Mouse Position</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mouse = &amp;world.resources.input.mouse;
let position = mouse.position;  // Screen coordinates (x, y)
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-movement-delta"><a class="header" href="#mouse-movement-delta">Mouse Movement (Delta)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let delta = world.resources.input.mouse.delta;
camera_yaw += delta.x * sensitivity;
camera_pitch += delta.y * sensitivity;
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mouse = &amp;world.resources.input.mouse;

// Button held
if mouse.state.contains(MouseState::LEFT_CLICKED) {
    fire_weapon();
}

// Button just pressed
if mouse.state.contains(MouseState::LEFT_JUST_PRESSED) {
    start_drag();
}

// Button just released
if mouse.state.contains(MouseState::LEFT_JUST_RELEASED) {
    end_drag();
}

// Right mouse button
if mouse.state.contains(MouseState::RIGHT_CLICKED) {
    aim_down_sights();
}

// Middle mouse button
if mouse.state.contains(MouseState::MIDDLE_CLICKED) {
    pan_camera();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-scroll"><a class="header" href="#mouse-scroll">Mouse Scroll</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scroll = world.resources.input.mouse.scroll_delta;
if scroll.y != 0.0 {
    zoom_camera(scroll.y);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-event-handling-1"><a class="header" href="#direct-event-handling-1">Direct Event Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {
    match (button, state) {
        (MouseButton::Left, ElementState::Pressed) =&gt; self.shoot(),
        (MouseButton::Right, ElementState::Pressed) =&gt; self.aim(),
        (MouseButton::Right, ElementState::Released) =&gt; self.stop_aim(),
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="movement-input-pattern"><a class="header" href="#movement-input-pattern">Movement Input Pattern</a></h2>
<p>Common WASD movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_movement_input(world: &amp;World) -&gt; Vec3 {
    let keyboard = &amp;world.resources.input.keyboard;
    let mut direction = Vec3::zeros();

    if keyboard.is_key_pressed(KeyCode::KeyW) {
        direction.z -= 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyS) {
        direction.z += 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyA) {
        direction.x -= 1.0;
    }
    if keyboard.is_key_pressed(KeyCode::KeyD) {
        direction.x += 1.0;
    }

    if direction.magnitude() &gt; 0.0 {
        direction.normalize_mut();
    }

    direction
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mouse-look-pattern"><a class="header" href="#mouse-look-pattern">Mouse Look Pattern</a></h2>
<p>First-person camera control:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mouse_look_system(world: &amp;mut World, sensitivity: f32) {
    let delta = world.resources.input.mouse.delta;

    if let Some(camera) = world.resources.active_camera {
        if let Some(transform) = world.get_local_transform_mut(camera) {
            // Horizontal rotation (yaw)
            let yaw = nalgebra_glm::quat_angle_axis(
                -delta.x * sensitivity,
                &amp;Vec3::y(),
            );

            // Vertical rotation (pitch) - clamped
            let pitch = nalgebra_glm::quat_angle_axis(
                -delta.y * sensitivity,
                &amp;Vec3::x(),
            );

            transform.rotation = yaw * transform.rotation * pitch;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cursor-locking"><a class="header" href="#cursor-locking">Cursor Locking</a></h2>
<p>For first-person games:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.input.cursor_locked = true;
    world.resources.input.cursor_visible = false;
}

fn toggle_cursor(world: &amp;mut World) {
    world.resources.input.cursor_locked = !world.resources.input.cursor_locked;
    world.resources.input.cursor_visible = !world.resources.input.cursor_visible;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-bindings"><a class="header" href="#key-bindings">Key Bindings</a></h2>
<p>Create rebindable controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyBindings {
    move_forward: KeyCode,
    move_back: KeyCode,
    move_left: KeyCode,
    move_right: KeyCode,
    jump: KeyCode,
    sprint: KeyCode,
}

impl Default for KeyBindings {
    fn default() -&gt; Self {
        Self {
            move_forward: KeyCode::KeyW,
            move_back: KeyCode::KeyS,
            move_left: KeyCode::KeyA,
            move_right: KeyCode::KeyD,
            jump: KeyCode::Space,
            sprint: KeyCode::ShiftLeft,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-buffer"><a class="header" href="#input-buffer">Input Buffer</a></h2>
<p>Buffer inputs for responsive controls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InputBuffer {
    jump_buffer: f32,
}

fn update_input_buffer(buffer: &amp;mut InputBuffer, world: &amp;World, dt: f32) {
    buffer.jump_buffer = (buffer.jump_buffer - dt).max(0.0);

    if world.resources.input.keyboard.is_key_just_pressed(KeyCode::Space) {
        buffer.jump_buffer = 0.15;  // 150ms buffer
    }
}

fn try_jump(buffer: &amp;mut InputBuffer, grounded: bool) -&gt; bool {
    if grounded &amp;&amp; buffer.jump_buffer &gt; 0.0 {
        buffer.jump_buffer = 0.0;
        return true;
    }
    false
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gamepad-support"><a class="header" href="#gamepad-support">Gamepad Support</a></h1>
<p>Nightshade uses gilrs for cross-platform gamepad support.</p>
<h2 id="enabling-gamepad"><a class="header" href="#enabling-gamepad">Enabling Gamepad</a></h2>
<p>Gamepad requires the <code>gamepad</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "gamepad"] }
</code></pre>
<h2 id="checking-for-gamepad"><a class="header" href="#checking-for-gamepad">Checking for Gamepad</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::input::queries::query_active_gamepad;

fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(gamepad) = query_active_gamepad(world) {
        // Gamepad is connected and active
        handle_gamepad_input(gamepad);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="button-input"><a class="header" href="#button-input">Button Input</a></h2>
<h3 id="button-states"><a class="header" href="#button-states">Button States</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_gamepad_input(gamepad: &amp;Gamepad) {
    // Button pressed
    if gamepad.is_pressed(gilrs::Button::South) {
        // A button (Xbox) / Cross (PlayStation)
        jump();
    }

    if gamepad.is_pressed(gilrs::Button::West) {
        // X button (Xbox) / Square (PlayStation)
        attack();
    }

    if gamepad.is_pressed(gilrs::Button::RightTrigger2) {
        // Right trigger
        fire();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="button-mapping"><a class="header" href="#button-mapping">Button Mapping</a></h3>
<div class="table-wrapper"><table><thead><tr><th>gilrs Button</th><th>Xbox</th><th>PlayStation</th><th>Nintendo</th></tr></thead><tbody>
<tr><td><code>South</code></td><td>A</td><td>Cross</td><td>B</td></tr>
<tr><td><code>East</code></td><td>B</td><td>Circle</td><td>A</td></tr>
<tr><td><code>West</code></td><td>X</td><td>Square</td><td>Y</td></tr>
<tr><td><code>North</code></td><td>Y</td><td>Triangle</td><td>X</td></tr>
<tr><td><code>LeftTrigger</code></td><td>LB</td><td>L1</td><td>L</td></tr>
<tr><td><code>RightTrigger</code></td><td>RB</td><td>R1</td><td>R</td></tr>
<tr><td><code>LeftTrigger2</code></td><td>LT</td><td>L2</td><td>ZL</td></tr>
<tr><td><code>RightTrigger2</code></td><td>RT</td><td>R2</td><td>ZR</td></tr>
<tr><td><code>Select</code></td><td>View</td><td>Share</td><td>-</td></tr>
<tr><td><code>Start</code></td><td>Menu</td><td>Options</td><td>+</td></tr>
<tr><td><code>DPadUp/Down/Left/Right</code></td><td>D-Pad</td><td>D-Pad</td><td>D-Pad</td></tr>
</tbody></table>
</div>
<h2 id="analog-sticks"><a class="header" href="#analog-sticks">Analog Sticks</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_analog_input(gamepad: &amp;Gamepad) {
    // Left stick - movement
    let left_x = gamepad.axis_value(gilrs::Axis::LeftStickX);
    let left_y = gamepad.axis_value(gilrs::Axis::LeftStickY);

    // Right stick - camera
    let right_x = gamepad.axis_value(gilrs::Axis::RightStickX);
    let right_y = gamepad.axis_value(gilrs::Axis::RightStickY);

    // Apply deadzone
    let movement = apply_deadzone(left_x, left_y, 0.15);
    let look = apply_deadzone(right_x, right_y, 0.1);
}

fn apply_deadzone(x: f32, y: f32, deadzone: f32) -&gt; Vec2 {
    let magnitude = (x * x + y * y).sqrt();
    if magnitude &lt; deadzone {
        Vec2::zeros()
    } else {
        let normalized = Vec2::new(x, y) / magnitude;
        let adjusted_magnitude = (magnitude - deadzone) / (1.0 - deadzone);
        normalized * adjusted_magnitude
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="triggers"><a class="header" href="#triggers">Triggers</a></h2>
<p>Triggers return values from 0.0 (not pressed) to 1.0 (fully pressed):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let left_trigger = gamepad.axis_value(gilrs::Axis::LeftZ);
let right_trigger = gamepad.axis_value(gilrs::Axis::RightZ);

// Accelerate based on trigger pressure
let acceleration = right_trigger * max_acceleration;
<span class="boring">}</span></code></pre></pre>
<h2 id="event-based-input"><a class="header" href="#event-based-input">Event-Based Input</a></h2>
<p>Handle button events in the State trait:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {
    let gilrs::EventType::ButtonPressed(button, _) = event.event else {
        return;
    };

    match button {
        gilrs::Button::Start =&gt; {
            self.paused = !self.paused;
        }
        gilrs::Button::Select =&gt; {
            toggle_camera_mode(&amp;mut self.game);
        }
        gilrs::Button::South =&gt; {
            if self.phase == GamePhase::MainMenu {
                self.phase = GamePhase::Playing;
            }
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="vibrationrumble"><a class="header" href="#vibrationrumble">Vibration/Rumble</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trigger_rumble(world: &amp;mut World, strength: f32, duration_ms: u32) {
    if let Some(gamepad) = world.resources.input.gamepad.as_mut() {
        gamepad.set_rumble(strength, strength, duration_ms);
    }
}

// Different intensities for different events
fn hit_feedback(world: &amp;mut World) {
    trigger_rumble(world, 0.5, 100);
}

fn explosion_feedback(world: &amp;mut World) {
    trigger_rumble(world, 1.0, 300);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-keyboard-and-gamepad"><a class="header" href="#combining-keyboard-and-gamepad">Combining Keyboard and Gamepad</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PlayerInput {
    movement: Vec2,
    look: Vec2,
    jump: bool,
    attack: bool,
}

fn gather_input(world: &amp;World) -&gt; PlayerInput {
    let mut input = PlayerInput::default();

    // Keyboard input
    let keyboard = &amp;world.resources.input.keyboard;
    if keyboard.is_key_pressed(KeyCode::KeyW) { input.movement.y -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { input.movement.y += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { input.movement.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { input.movement.x += 1.0; }
    input.jump |= keyboard.is_key_just_pressed(KeyCode::Space);

    // Gamepad input (overrides if present)
    if let Some(gamepad) = query_active_gamepad(world) {
        let stick_x = gamepad.axis_value(gilrs::Axis::LeftStickX);
        let stick_y = gamepad.axis_value(gilrs::Axis::LeftStickY);
        let stick = apply_deadzone(stick_x, stick_y, 0.15);

        if stick.magnitude() &gt; 0.0 {
            input.movement = stick;
        }

        input.jump |= gamepad.is_pressed(gilrs::Button::South);
        input.attack |= gamepad.is_pressed(gilrs::Button::West);
    }

    input
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiple-gamepads"><a class="header" href="#multiple-gamepads">Multiple Gamepads</a></h2>
<p>For local multiplayer:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_player_gamepad(world: &amp;World, player_index: usize) -&gt; Option&lt;&amp;Gamepad&gt; {
    world.resources.input.gamepads.get(player_index)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terrain"><a class="header" href="#terrain">Terrain</a></h1>
<p>Nightshade supports procedural terrain generation with LOD and tessellation.</p>
<h2 id="enabling-terrain"><a class="header" href="#enabling-terrain">Enabling Terrain</a></h2>
<p>Terrain requires the <code>terrain</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "terrain"] }
</code></pre>
<h2 id="basic-terrain"><a class="header" href="#basic-terrain">Basic Terrain</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::terrain::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let config = TerrainConfig::default();
    spawn_terrain(world, config, Vec3::zeros());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-configuration"><a class="header" href="#terrain-configuration">Terrain Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TerrainConfig {
    pub chunk_size: f32,         // Size of each terrain chunk
    pub view_distance: u32,      // How many chunks to render
    pub patches_per_chunk: u32,  // Subdivision level
    pub max_tessellation: u32,   // Maximum tessellation level
    pub min_tessellation: u32,   // Minimum tessellation level
    pub height_scale: f32,       // Vertical scale
    pub noise_frequency: f32,    // Noise detail frequency
    pub noise_octaves: u32,      // Noise layers
    pub lod_distances: [f32; 5], // LOD transition distances
}

impl Default for TerrainConfig {
    fn default() -&gt; Self {
        Self {
            chunk_size: 64.0,
            view_distance: 8,
            patches_per_chunk: 8,
            max_tessellation: 16,
            min_tessellation: 1,
            height_scale: 50.0,
            noise_frequency: 0.01,
            noise_octaves: 6,
            lod_distances: [50.0, 150.0, 400.0, 800.0, 1600.0],
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-with-custom-material"><a class="header" href="#terrain-with-custom-material">Terrain with Custom Material</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let snow_material = Material {
    base_color: [0.95, 0.97, 1.0, 1.0],
    roughness: 0.85,
    metallic: 0.0,
    ..Default::default()
};

spawn_terrain_with_material(world, config, Vec3::zeros(), snow_material);
<span class="boring">}</span></code></pre></pre>
<h2 id="sampling-terrain-height"><a class="header" href="#sampling-terrain-height">Sampling Terrain Height</a></h2>
<p>Get the terrain height at any position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_ground_height(config: &amp;TerrainConfig, x: f32, z: f32) -&gt; f32 {
    sample_terrain_height(x, z, config)
}

// Place object on terrain
fn place_on_terrain(world: &amp;mut World, entity: Entity, x: f32, z: f32, config: &amp;TerrainConfig) {
    let y = sample_terrain_height(x, z, config);

    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.translation = Vec3::new(x, y, z);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-physics"><a class="header" href="#terrain-physics">Terrain Physics</a></h2>
<p>Add collision to terrain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_terrain_collision(world: &amp;mut World, config: &amp;TerrainConfig) {
    // Generate heightfield data
    let resolution = 64;
    let mut heights = Vec::new();

    for z in 0..resolution {
        let mut row = Vec::new();
        for x in 0..resolution {
            let world_x = (x as f32 / resolution as f32) * config.chunk_size;
            let world_z = (z as f32 / resolution as f32) * config.chunk_size;
            row.push(sample_terrain_height(world_x, world_z, config));
        }
        heights.push(row);
    }

    // Create heightfield collider
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | COLLIDER_COMPONENT,
        1
    )[0];

    world.set_collider(entity, ColliderComponent {
        shape: ColliderShape::Heightfield {
            heights,
            scale: Vec3::new(config.chunk_size, 1.0, config.chunk_size),
        },
        handle: None,
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-terrain-pass"><a class="header" href="#custom-terrain-pass">Custom Terrain Pass</a></h2>
<p>For advanced terrain rendering:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for TerrainDemo {
    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) {
        let terrain_pass = TerrainPass::new(
            device,
            self.config.clone(),
            wgpu::TextureFormat::Rgba16Float,
        );

        graph
            .pass(Box::new(terrain_pass))
            .slot("color", resources.scene_color)
            .slot("depth", resources.depth);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chunk-management"><a class="header" href="#chunk-management">Chunk Management</a></h2>
<p>Terrain chunks load/unload based on camera position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChunkManager {
    loaded_chunks: HashMap&lt;(i32, i32), Entity&gt;,
    config: TerrainConfig,
}

impl ChunkManager {
    fn update(&amp;mut self, world: &amp;mut World, camera_pos: Vec3) {
        let chunk_x = (camera_pos.x / self.config.chunk_size) as i32;
        let chunk_z = (camera_pos.z / self.config.chunk_size) as i32;

        // Load nearby chunks
        for dz in -self.config.view_distance as i32..=self.config.view_distance as i32 {
            for dx in -self.config.view_distance as i32..=self.config.view_distance as i32 {
                let key = (chunk_x + dx, chunk_z + dz);
                if !self.loaded_chunks.contains_key(&amp;key) {
                    self.load_chunk(world, key);
                }
            }
        }

        // Unload distant chunks
        self.loaded_chunks.retain(|&amp;(cx, cz), entity| {
            let dist = ((cx - chunk_x).abs().max((cz - chunk_z).abs())) as u32;
            if dist &gt; self.config.view_distance + 1 {
                world.despawn(*entity);
                false
            } else {
                true
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lod-system"><a class="header" href="#lod-system">LOD System</a></h2>
<p>Terrain automatically adjusts detail based on distance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LOD levels are determined by distance from camera
// lod_distances[0] = highest detail
// lod_distances[4] = lowest detail

let config = TerrainConfig {
    lod_distances: [50.0, 150.0, 400.0, 800.0, 1600.0],
    max_tessellation: 16,
    min_tessellation: 1,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="wireframe-toggle"><a class="header" href="#wireframe-toggle">Wireframe Toggle</a></h2>
<p>Debug terrain with wireframe:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicBool, Ordering};

static WIREFRAME: AtomicBool = AtomicBool::new(false);

fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
    if state == KeyState::Pressed &amp;&amp; key == KeyCode::KeyT {
        let current = WIREFRAME.load(Ordering::Relaxed);
        WIREFRAME.store(!current, Ordering::Relaxed);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-systems"><a class="header" href="#particle-systems">Particle Systems</a></h1>
<p>GPU-accelerated particle systems for fire, smoke, snow, and other effects.</p>
<h2 id="creating-a-particle-emitter"><a class="header" href="#creating-a-particle-emitter">Creating a Particle Emitter</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::particles::components::*;

let entity = world.spawn_entities(PARTICLE_EMITTER, 1)[0];

world.set_particle_emitter(entity, ParticleEmitter {
    emitter_type: EmitterType::Fire,
    shape: EmitterShape::Point,
    position: Vec3::new(0.0, 0.0, 0.0),
    direction: Vec3::new(0.0, 1.0, 0.0),
    spawn_rate: 50.0,
    particle_lifetime_min: 0.5,
    particle_lifetime_max: 1.5,
    initial_velocity_min: 1.0,
    initial_velocity_max: 3.0,
    velocity_spread: 0.3,
    gravity: Vec3::new(0.0, -1.0, 0.0),
    size_start: 0.2,
    size_end: 0.05,
    color_gradient: fire_gradient(),
    enabled: true,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="emitter-types"><a class="header" href="#emitter-types">Emitter Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Fire</code></td><td>Additive blending, upward motion</td></tr>
<tr><td><code>Smoke</code></td><td>Alpha blending, slow rise</td></tr>
<tr><td><code>Sparks</code></td><td>Point sprites, fast motion</td></tr>
<tr><td><code>Snow</code></td><td>Falling particles, drift</td></tr>
<tr><td><code>Dust</code></td><td>Ground-level particles</td></tr>
</tbody></table>
</div>
<h2 id="emitter-shapes"><a class="header" href="#emitter-shapes">Emitter Shapes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single point
EmitterShape::Point

// Emit from sphere surface
EmitterShape::Sphere { radius: 0.5 }

// Emit from box volume
EmitterShape::Box { half_extents: Vec3::new(1.0, 0.1, 1.0) }

// Emit from cone
EmitterShape::Cone { radius: 0.5, height: 1.0 }
<span class="boring">}</span></code></pre></pre>
<h2 id="color-gradients"><a class="header" href="#color-gradients">Color Gradients</a></h2>
<p>Define how particles change color over their lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fire_gradient() -&gt; ColorGradient {
    ColorGradient {
        colors: vec![
            (0.0, Vec4::new(1.0, 1.0, 0.9, 0.0)),    // Start: white, transparent
            (0.1, Vec4::new(1.0, 0.95, 0.7, 1.0)),   // Bright yellow
            (0.3, Vec4::new(1.0, 0.8, 0.4, 0.9)),    // Orange-yellow
            (0.6, Vec4::new(1.0, 0.5, 0.1, 0.6)),    // Orange
            (0.85, Vec4::new(0.9, 0.2, 0.02, 0.2)),  // Red
            (1.0, Vec4::new(0.5, 0.05, 0.0, 0.0)),   // Dark red, fade out
        ],
    }
}

fn smoke_gradient() -&gt; ColorGradient {
    ColorGradient {
        colors: vec![
            (0.0, Vec4::new(0.15, 0.12, 0.1, 0.0)),
            (0.15, Vec4::new(0.3, 0.28, 0.25, 0.4)),
            (0.7, Vec4::new(0.5, 0.49, 0.47, 0.2)),
            (1.0, Vec4::new(0.65, 0.63, 0.6, 0.0)),
        ],
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fire-effect"><a class="header" href="#fire-effect">Fire Effect</a></h2>
<p>Complete campfire with multiple emitters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_campfire(world: &amp;mut World, position: Vec3) {
    // Fire core (bright, fast)
    let core = world.spawn_entities(PARTICLE_EMITTER, 1)[0];
    world.set_particle_emitter(core, ParticleEmitter {
        emitter_type: EmitterType::Fire,
        shape: EmitterShape::Sphere { radius: 0.04 },
        position,
        direction: Vec3::new(0.0, 1.0, 0.0),
        spawn_rate: 50.0,
        particle_lifetime_min: 0.25,
        particle_lifetime_max: 0.5,
        initial_velocity_min: 0.8,
        initial_velocity_max: 1.5,
        velocity_spread: 0.12,
        gravity: Vec3::new(0.0, 2.5, 0.0),
        size_start: 0.12,
        size_end: 0.04,
        color_gradient: fire_gradient(),
        emissive_strength: 18.0,
        turbulence_strength: 1.2,
        turbulence_frequency: 4.5,
        ..Default::default()
    });

    // Smoke (slow, expanding)
    let smoke = world.spawn_entities(PARTICLE_EMITTER, 1)[0];
    world.set_particle_emitter(smoke, ParticleEmitter {
        emitter_type: EmitterType::Smoke,
        shape: EmitterShape::Sphere { radius: 0.1 },
        position: position + Vec3::new(0.0, 0.5, 0.0),
        direction: Vec3::new(0.1, 1.0, 0.05).normalize(),
        spawn_rate: 25.0,
        particle_lifetime_min: 5.0,
        particle_lifetime_max: 10.0,
        initial_velocity_min: 0.3,
        initial_velocity_max: 0.7,
        gravity: Vec3::new(0.05, 0.2, 0.02),
        drag: 0.05,
        size_start: 0.2,
        size_end: 2.5,
        color_gradient: smoke_gradient(),
        turbulence_strength: 0.6,
        turbulence_frequency: 0.2,
        ..Default::default()
    });

    // Embers (sparks)
    let embers = world.spawn_entities(PARTICLE_EMITTER, 1)[0];
    world.set_particle_emitter(embers, ParticleEmitter {
        emitter_type: EmitterType::Sparks,
        shape: EmitterShape::Sphere { radius: 0.15 },
        position: position + Vec3::new(0.0, 0.1, 0.0),
        spawn_rate: 8.0,
        particle_lifetime_min: 2.0,
        particle_lifetime_max: 4.0,
        initial_velocity_min: 0.5,
        initial_velocity_max: 2.0,
        gravity: Vec3::new(0.0, -0.3, 0.0),
        size_start: 0.02,
        size_end: 0.01,
        emissive_strength: 25.0,
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="snowweather-effect"><a class="header" href="#snowweather-effect">Snow/Weather Effect</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_snow_blizzard(world: &amp;mut World) {
    let snow = world.spawn_entities(PARTICLE_EMITTER, 1)[0];

    world.set_particle_emitter(snow, ParticleEmitter {
        emitter_type: EmitterType::Snow,
        shape: EmitterShape::Box {
            half_extents: Vec3::new(50.0, 0.1, 50.0),
        },
        position: Vec3::new(0.0, 30.0, 0.0),
        direction: Vec3::new(-0.1, -1.0, -0.05).normalize(),
        spawn_rate: 500.0,
        particle_lifetime_min: 8.0,
        particle_lifetime_max: 15.0,
        initial_velocity_min: 0.5,
        initial_velocity_max: 2.0,
        velocity_spread: 0.3,
        gravity: Vec3::new(-0.1, -0.5, -0.05),
        drag: 0.02,
        size_start: 0.03,
        size_end: 0.02,
        turbulence_strength: 0.8,
        turbulence_frequency: 0.5,
        ..Default::default()
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="controlling-emitters"><a class="header" href="#controlling-emitters">Controlling Emitters</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable/disable
if let Some(emitter) = world.get_particle_emitter_mut(entity) {
    emitter.enabled = false;
}

// Burst spawn
if let Some(emitter) = world.get_particle_emitter_mut(entity) {
    emitter.burst_count = 50;  // Spawn 50 particles immediately
}

// Change position
if let Some(emitter) = world.get_particle_emitter_mut(entity) {
    emitter.position = new_position;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="particle-properties"><a class="header" href="#particle-properties">Particle Properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spawn_rate</code></td><td>Particles per second</td></tr>
<tr><td><code>burst_count</code></td><td>One-time particle spawn</td></tr>
<tr><td><code>particle_lifetime_min/max</code></td><td>Random lifetime range</td></tr>
<tr><td><code>initial_velocity_min/max</code></td><td>Random speed range</td></tr>
<tr><td><code>velocity_spread</code></td><td>Direction randomization</td></tr>
<tr><td><code>gravity</code></td><td>Constant acceleration</td></tr>
<tr><td><code>drag</code></td><td>Air resistance</td></tr>
<tr><td><code>size_start/end</code></td><td>Size over lifetime</td></tr>
<tr><td><code>emissive_strength</code></td><td>Glow intensity</td></tr>
<tr><td><code>turbulence_strength</code></td><td>Noise movement</td></tr>
<tr><td><code>turbulence_frequency</code></td><td>Noise frequency</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="navigation-mesh"><a class="header" href="#navigation-mesh">Navigation Mesh</a></h1>
<p>AI pathfinding using Recast navigation mesh generation.</p>
<h2 id="enabling-navmesh"><a class="header" href="#enabling-navmesh">Enabling NavMesh</a></h2>
<p>NavMesh requires the <code>navmesh</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "navmesh"] }
</code></pre>
<h2 id="generating-a-navmesh"><a class="header" href="#generating-a-navmesh">Generating a NavMesh</a></h2>
<p>Generate a navigation mesh from geometry:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::navmesh::*;

fn setup_navmesh(world: &amp;mut World) {
    // Get terrain or level geometry
    let vertices: Vec&lt;Vec3&gt; = get_level_vertices();
    let indices: Vec&lt;[u32; 3]&gt; = get_level_indices();

    let config = RecastNavMeshConfig {
        cell_size: 0.15,
        cell_height: 0.1,
        agent_height: 1.0,
        agent_radius: 0.4,
        agent_max_climb: 0.3,
        agent_max_slope: 45.0,
        region_min_size: 8,
        region_merge_size: 20,
        edge_max_len: 12.0,
        edge_max_error: 1.3,
        detail_sample_dist: 6.0,
        detail_sample_max_error: 1.0,
    };

    generate_navmesh_recast(world, &amp;vertices, &amp;indices, &amp;config);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navmesh-configuration"><a class="header" href="#navmesh-configuration">NavMesh Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cell_size</code></td><td>Horizontal voxel resolution</td></tr>
<tr><td><code>cell_height</code></td><td>Vertical voxel resolution</td></tr>
<tr><td><code>agent_height</code></td><td>Agent height for walkability</td></tr>
<tr><td><code>agent_radius</code></td><td>Agent radius for clearance</td></tr>
<tr><td><code>agent_max_climb</code></td><td>Maximum step height</td></tr>
<tr><td><code>agent_max_slope</code></td><td>Maximum walkable slope (degrees)</td></tr>
</tbody></table>
</div>
<h2 id="creating-navmesh-agents"><a class="header" href="#creating-navmesh-agents">Creating NavMesh Agents</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_npc(world: &amp;mut World, position: Vec3) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | NAV_MESH_AGENT,
        1
    )[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        ..Default::default()
    });

    world.set_nav_mesh_agent(entity, NavMeshAgent {
        speed: 3.0,
        acceleration: 10.0,
        turning_speed: 8.0,
        stopping_distance: 0.5,
        target: None,
        path: Vec::new(),
        path_index: 0,
    });

    entity
}
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-agent-destination"><a class="header" href="#setting-agent-destination">Setting Agent Destination</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_npc_destination(world: &amp;mut World, agent: Entity, target: Vec3) {
    set_agent_destination(world, agent, target);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-agents"><a class="header" href="#updating-agents">Updating Agents</a></h2>
<p>Call the navigation system each frame:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    update_navmesh_agents(world);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-path-status"><a class="header" href="#checking-path-status">Checking Path Status</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_reached_destination(world: &amp;World, agent: Entity) -&gt; bool {
    if let Some(nav_agent) = world.get_nav_mesh_agent(agent) {
        nav_agent.target.is_none() || nav_agent.path.is_empty()
    } else {
        true
    }
}

fn get_remaining_distance(world: &amp;World, agent: Entity) -&gt; f32 {
    if let Some(nav_agent) = world.get_nav_mesh_agent(agent) {
        if let Some(agent_pos) = world.get_local_transform(agent).map(|t| t.translation) {
            if let Some(target) = nav_agent.target {
                return (target - agent_pos).magnitude();
            }
        }
    }
    0.0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pathfinding-queries"><a class="header" href="#pathfinding-queries">Pathfinding Queries</a></h2>
<p>Find paths without agents:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_path(world: &amp;World, start: Vec3, end: Vec3) -&gt; Option&lt;Vec&lt;Vec3&gt;&gt; {
    query_path(world, start, end)
}

fn is_point_walkable(world: &amp;World, point: Vec3) -&gt; bool {
    is_on_navmesh(world, point)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="patrol-behavior"><a class="header" href="#patrol-behavior">Patrol Behavior</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PatrolBehavior {
    waypoints: Vec&lt;Vec3&gt;,
    current_waypoint: usize,
}

fn update_patrol(world: &amp;mut World, agent: Entity, patrol: &amp;mut PatrolBehavior) {
    if has_reached_destination(world, agent) {
        patrol.current_waypoint = (patrol.current_waypoint + 1) % patrol.waypoints.len();
        let target = patrol.waypoints[patrol.current_waypoint];
        set_agent_destination(world, agent, target);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chase-behavior"><a class="header" href="#chase-behavior">Chase Behavior</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_chase(world: &amp;mut World, agent: Entity, target_entity: Entity) {
    if let Some(target_pos) = world.get_local_transform(target_entity).map(|t| t.translation) {
        // Only update path periodically to avoid constant recalculation
        set_agent_destination(world, agent, target_pos);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navmesh-areas"><a class="header" href="#navmesh-areas">NavMesh Areas</a></h2>
<p>Define different terrain costs:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = RecastNavMeshConfig {
    // Base configuration...
    ..Default::default()
};

// Areas can be marked during navmesh generation
// Higher cost = agents avoid this area
// Area 0: Ground (cost 1.0)
// Area 1: Road (cost 0.5 - preferred)
// Area 2: Mud (cost 3.0 - avoided)
<span class="boring">}</span></code></pre></pre>
<h2 id="off-mesh-connections"><a class="header" href="#off-mesh-connections">Off-Mesh Connections</a></h2>
<p>Link disconnected navmesh regions (ladders, teleports):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_ladder_connection(world: &amp;mut World, start: Vec3, end: Vec3) {
    add_offmesh_connection(world, start, end, true);  // bidirectional = true
}

fn add_one_way_jump(world: &amp;mut World, start: Vec3, end: Vec3) {
    add_offmesh_connection(world, start, end, false);  // one-way
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization-1"><a class="header" href="#debug-visualization-1">Debug Visualization</a></h2>
<p>Draw the navmesh for debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_navmesh_debug(world: &amp;mut World) {
    if let Some(navmesh) = &amp;world.resources.navmesh_world.navmesh {
        for triangle in navmesh.triangles() {
            // Draw triangle edges as lines
            draw_debug_line(world, triangle.v0, triangle.v1, Vec4::new(0.0, 1.0, 0.0, 1.0));
            draw_debug_line(world, triangle.v1, triangle.v2, Vec4::new(0.0, 1.0, 0.0, 1.0));
            draw_debug_line(world, triangle.v2, triangle.v0, Vec4::new(0.0, 1.0, 0.0, 1.0));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grass-system"><a class="header" href="#grass-system">Grass System</a></h1>
<p>GPU-accelerated grass rendering with wind, interaction, and LOD support.</p>
<h2 id="enabling-grass"><a class="header" href="#enabling-grass">Enabling Grass</a></h2>
<p>Grass requires the <code>grass</code> feature:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "grass"] }
</code></pre>
<h2 id="basic-grass-region"><a class="header" href="#basic-grass-region">Basic Grass Region</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::grass::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let config = GrassConfig::default();
    spawn_grass_region(world, config);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-configuration"><a class="header" href="#grass-configuration">Grass Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GrassConfig {
    pub blades_per_patch: u32,        // Grass density (default: 64)
    pub patch_size: f32,              // Size of each patch (default: 8.0)
    pub stream_radius: f32,           // Radius around camera to render (default: 200.0)
    pub unload_radius: f32,           // Distance to unload patches (default: 220.0)
    pub max_loaded_patches: usize,    // Maximum loaded patches (default: 4096)
    pub wind_strength: f32,           // Wind intensity (default: 1.0)
    pub wind_frequency: f32,          // Wind oscillation speed (default: 1.0)
    pub wind_direction: [f32; 2],     // Wind XZ direction (default: [1.0, 0.0])
    pub interaction_radius: f32,      // Player interaction radius (default: 1.0)
    pub interaction_strength: f32,    // Bending strength (default: 1.0)
    pub interactors_enabled: bool,    // Enable grass bending (default: true)
    pub cast_shadows: bool,           // Cast shadows (default: true)
    pub receive_shadows: bool,        // Receive shadows (default: true)
    pub lod_distances: [f32; 4],      // LOD transition distances
    pub lod_density_scales: [f32; 4], // Density at each LOD level
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-builder"><a class="header" href="#configuration-builder">Configuration Builder</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = GrassConfig::default()
    .with_density(128)
    .with_wind(1.5, 2.0)
    .with_wind_direction(1.0, 0.5)
    .with_shadows(true, true)
    .with_stream_radius(250.0);

spawn_grass_region(world, config);
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-species"><a class="header" href="#grass-species">Grass Species</a></h2>
<p>Define visual characteristics of grass types:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GrassSpecies {
    pub name: String,
    pub blade_width: f32,
    pub blade_height_min: f32,
    pub blade_height_max: f32,
    pub blade_curvature: f32,
    pub base_color: [f32; 4],
    pub tip_color: [f32; 4],
    pub sss_color: [f32; 4],         // Subsurface scattering
    pub sss_intensity: f32,
    pub specular_power: f32,
    pub specular_strength: f32,
    pub density_scale: f32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preset-species"><a class="header" href="#preset-species">Preset Species</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Short, dense lawn grass
let meadow = GrassSpecies::meadow();

// Tall field grass
let tall = GrassSpecies::tall();

// Very short grass
let short = GrassSpecies::short();

// Colorful flowers mixed with grass
let flowers = GrassSpecies::flowers();
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-species-grass"><a class="header" href="#multi-species-grass">Multi-Species Grass</a></h2>
<p>Mix multiple grass types:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = spawn_grass_region(world, config);

add_grass_species(world, entity, GrassSpecies::meadow(), 0.6);
add_grass_species(world, entity, GrassSpecies::flowers(), 0.4);
<span class="boring">}</span></code></pre></pre>
<p>Or set all at once:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_grass_species(
    world,
    entity,
    vec![GrassSpecies::meadow(), GrassSpecies::tall(), GrassSpecies::flowers()],
    vec![0.5, 0.3, 0.2],
);
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-region-builder"><a class="header" href="#grass-region-builder">Grass Region Builder</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let region = GrassRegion::new()
    .with_config(config)
    .with_species(GrassSpecies::meadow(), 0.6)
    .with_species(GrassSpecies::flowers(), 0.4)
    .with_bounds(
        Vec3::new(-500.0, -10.0, -500.0),
        Vec3::new(500.0, 100.0, 500.0)
    )
    .with_terrain(terrain_config);

let entity = world.spawn_entities(GRASS_REGION, 1)[0];
world.set_grass_region(entity, region);
<span class="boring">}</span></code></pre></pre>
<h2 id="wind-control"><a class="header" href="#wind-control">Wind Control</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set wind strength and frequency
set_grass_wind(world, entity, 1.5, 2.0);

// Set wind direction (XZ plane)
set_grass_wind_direction(world, entity, 1.0, 0.5);
<span class="boring">}</span></code></pre></pre>
<h2 id="grass-interaction"><a class="header" href="#grass-interaction">Grass Interaction</a></h2>
<p>Entities can bend grass when walking through it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn a dedicated interactor
let interactor = spawn_grass_interactor(world, 1.0, 1.0);

// Or attach to an existing entity (like the player)
attach_grass_interactor(world, player_entity, 1.0, 1.0);
<span class="boring">}</span></code></pre></pre>
<h3 id="grassinteractor-component"><a class="header" href="#grassinteractor-component">GrassInteractor Component</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GrassInteractor {
    pub radius: f32,    // Area of effect
    pub strength: f32,  // Bending intensity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="enabledisable-interaction"><a class="header" href="#enabledisable-interaction">Enable/Disable Interaction</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enable_grass_interactors(world, grass_entity, false);
<span class="boring">}</span></code></pre></pre>
<h2 id="terrain-integration"><a class="header" href="#terrain-integration">Terrain Integration</a></h2>
<p>Integrate grass with procedural terrain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let terrain_config = TerrainConfig {
    height_scale: 50.0,
    noise_frequency: 0.01,
    ..Default::default()
};

let region = GrassRegion::new()
    .with_config(GrassConfig::default())
    .with_terrain(terrain_config);
<span class="boring">}</span></code></pre></pre>
<h2 id="lod-system-1"><a class="header" href="#lod-system-1">LOD System</a></h2>
<p>Grass automatically reduces density at distance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = GrassConfig {
    lod_distances: [20.0, 50.0, 100.0, 200.0],
    lod_density_scales: [1.0, 0.6, 0.3, 0.1],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>LOD Level</th><th>Distance</th><th>Density</th></tr></thead><tbody>
<tr><td>0</td><td>0-20m</td><td>100%</td></tr>
<tr><td>1</td><td>20-50m</td><td>60%</td></tr>
<tr><td>2</td><td>50-100m</td><td>30%</td></tr>
<tr><td>3</td><td>100-200m</td><td>10%</td></tr>
</tbody></table>
</div>
<h2 id="controlling-grass"><a class="header" href="#controlling-grass">Controlling Grass</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable/disable
enable_grass(world, entity, false);

// Change density
set_grass_density(world, entity, 256);

// Toggle shadows
set_grass_shadows(world, entity, false, true);
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-species"><a class="header" href="#custom-species">Custom Species</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wheat = GrassSpecies {
    name: "Wheat".to_string(),
    blade_width: 0.03,
    blade_height_min: 0.8,
    blade_height_max: 1.2,
    blade_curvature: 0.6,
    base_color: [0.76, 0.70, 0.50, 1.0],
    tip_color: [0.85, 0.78, 0.55, 1.0],
    sss_color: [1.0, 0.9, 0.7, 1.0],
    sss_intensity: 0.3,
    specular_power: 32.0,
    specular_strength: 0.2,
    density_scale: 0.8,
};

add_grass_species(world, entity, wheat, 1.0);
<span class="boring">}</span></code></pre></pre>
<h2 id="rendering-details"><a class="header" href="#rendering-details">Rendering Details</a></h2>
<p>The grass system uses:</p>
<ul>
<li><strong>GPU Instancing</strong>: Up to 500,000 grass blades</li>
<li><strong>Compute Culling</strong>: GPU frustum culling for visibility</li>
<li><strong>Indirect Rendering</strong>: Dynamic draw calls based on visibility</li>
<li><strong>7-Vertex Blades</strong>: Triangle strips for curved grass shapes</li>
<li><strong>Bend Mapping</strong>: 128x128 texture tracks interaction bending</li>
<li><strong>Subsurface Scattering</strong>: Light transmission through blades</li>
<li><strong>Kajiya-Kay Specular</strong>: Anisotropic hair-like specularity</li>
</ul>
<h2 id="performance-tips-2"><a class="header" href="#performance-tips-2">Performance Tips</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Performance Impact</th></tr></thead><tbody>
<tr><td><code>blades_per_patch</code></td><td>High - reduce for better FPS</td></tr>
<tr><td><code>stream_radius</code></td><td>High - smaller = less grass</td></tr>
<tr><td><code>lod_density_scales</code></td><td>Medium - aggressive LOD helps</td></tr>
<tr><td><code>cast_shadows</code></td><td>Medium - disable if not needed</td></tr>
<tr><td><code>interactors_enabled</code></td><td>Low - compute shader cost</td></tr>
</tbody></table>
</div>
<h2 id="example-meadow-scene"><a class="header" href="#example-meadow-scene">Example: Meadow Scene</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_meadow(world: &amp;mut World) {
    let config = GrassConfig::default()
        .with_density(96)
        .with_wind(0.8, 1.2)
        .with_stream_radius(150.0);

    let entity = spawn_grass_region(world, config);

    add_grass_species(world, entity, GrassSpecies::meadow(), 0.5);
    add_grass_species(world, entity, GrassSpecies::short(), 0.3);
    add_grass_species(world, entity, GrassSpecies::flowers(), 0.2);

    attach_grass_interactor(world, player, 1.2, 0.8);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hud-text"><a class="header" href="#hud-text">HUD Text</a></h1>
<p>Screen-space text rendering for UI, scores, and debug information.</p>
<h2 id="creating-hud-text"><a class="header" href="#creating-hud-text">Creating HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::text::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_hud_text(world, "Score: 0", HudAnchor::TopLeft, Vec2::new(20.0, 20.0));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hud-anchors"><a class="header" href="#hud-anchors">HUD Anchors</a></h2>
<p>Text can be anchored to any screen position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HudAnchor {
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="anchor-examples"><a class="header" href="#anchor-examples">Anchor Examples</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Score in top-left corner
spawn_hud_text(world, "Score: 0", HudAnchor::TopLeft, Vec2::new(20.0, 20.0));

// Centered title
spawn_hud_text(world, "GAME OVER", HudAnchor::Center, Vec2::zeros());

// Health bar label bottom-left
spawn_hud_text(world, "HP", HudAnchor::BottomLeft, Vec2::new(20.0, -60.0));

// Timer top-center
spawn_hud_text(world, "3:00", HudAnchor::TopCenter, Vec2::new(0.0, 30.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="text-properties"><a class="header" href="#text-properties">Text Properties</a></h2>
<p>Customize text appearance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    font_size: 32.0,
    color: [1.0, 1.0, 1.0, 1.0],
    text_alignment: TextAlignment::Left,
    vertical_alignment: VerticalAlignment::Top,
    line_height: 1.2,
    letter_spacing: 0.0,
    outline_width: 0.0,
    outline_color: [0.0, 0.0, 0.0, 1.0],
    smoothing: 0.003,
    monospace_width: None,
    anchor_character: None,
};

spawn_hud_text_with_properties(
    world,
    "Custom Text",
    HudAnchor::TopLeft,
    Vec2::new(20.0, 20.0),
    properties,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="text-alignment"><a class="header" href="#text-alignment">Text Alignment</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Left aligned (default)
TextAlignment::Left

// Center aligned
TextAlignment::Center

// Right aligned
TextAlignment::Right
<span class="boring">}</span></code></pre></pre>
<h3 id="vertical-alignment"><a class="header" href="#vertical-alignment">Vertical Alignment</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>VerticalAlignment::Top      // Align to top
VerticalAlignment::Middle   // Center vertically
VerticalAlignment::Bottom   // Align to bottom
VerticalAlignment::Baseline // Align to text baseline
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-text"><a class="header" href="#updating-text">Updating Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(text_entity) = self.score_text {
        if let Some(hud_text) = world.get_hud_text_mut(text_entity) {
            let text = format!("Score: {}", self.score);
            world.resources.text_cache.set_text(hud_text.text_index, &amp;text);
            hud_text.dirty = true;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-outlines"><a class="header" href="#text-outlines">Text Outlines</a></h2>
<p>Add outlines for better visibility:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    font_size: 24.0,
    color: [1.0, 1.0, 1.0, 1.0],
    outline_width: 2.0,
    outline_color: [0.0, 0.0, 0.0, 1.0],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-custom-fonts"><a class="header" href="#loading-custom-fonts">Loading Custom Fonts</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    let font_bytes = include_bytes!("assets/fonts/custom.ttf");
    let font_index = load_font_from_bytes(world, font_bytes);

    self.custom_font = Some(font_index);
}

fn spawn_custom_text(&amp;self, world: &amp;mut World) {
    let entity = world.spawn_entities(HUD_TEXT, 1)[0];

    let text_index = world.resources.text_cache.add_text("Custom Font Text");

    world.set_hud_text(entity, HudText {
        text_index,
        properties: TextProperties::default(),
        font_index: self.custom_font.unwrap(),
        position: Vec2::new(100.0, 100.0),
        anchor: HudAnchor::TopLeft,
        cached_mesh: None,
        dirty: true,
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hudtext-component"><a class="header" href="#hudtext-component">HudText Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HudText {
    pub text_index: usize,              // Index in TextCache
    pub properties: TextProperties,     // Visual properties
    pub font_index: usize,              // Which font to use
    pub position: Vec2,                 // Offset from anchor
    pub anchor: HudAnchor,              // Screen anchor point
    pub cached_mesh: Option&lt;TextMesh&gt;,  // Pre-generated mesh
    pub dirty: bool,                    // Needs regeneration
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-line-text"><a class="header" href="#multi-line-text">Multi-line Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let multiline = "Line 1\nLine 2\nLine 3";
spawn_hud_text(world, multiline, HudAnchor::TopLeft, Vec2::new(20.0, 20.0));
<span class="boring">}</span></code></pre></pre>
<p>Line height is controlled by <code>TextProperties::line_height</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let properties = TextProperties {
    line_height: 1.5,  // 150% of font size
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="colored-text-spans"><a class="header" href="#colored-text-spans">Colored Text Spans</a></h2>
<p>For per-character coloring, modify the text cache:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.text_cache.set_character_colors(
    text_index,
    vec![
        [1.0, 0.0, 0.0, 1.0],  // Red
        [0.0, 1.0, 0.0, 1.0],  // Green
        [0.0, 0.0, 1.0, 1.0],  // Blue
    ],
);
<span class="boring">}</span></code></pre></pre>
<h2 id="3d-world-space-text"><a class="header" href="#3d-world-space-text">3D World-Space Text</a></h2>
<p>For text in 3D space (billboards, signs):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = world.spawn_entities(
    LOCAL_TRANSFORM | GLOBAL_TRANSFORM | TEXT_COMPONENT,
    1
)[0];

world.set_local_transform(entity, LocalTransform {
    translation: Vec3::new(0.0, 2.0, 0.0),
    ..Default::default()
});

let text_index = world.resources.text_cache.add_text("Hello World");

world.set_text(entity, Text {
    text_index,
    properties: TextProperties {
        font_size: 0.5,  // World units
        ..Default::default()
    },
    billboard: true,  // Face camera
    dirty: true,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-ui-patterns"><a class="header" href="#common-ui-patterns">Common UI Patterns</a></h2>
<h3 id="score-display"><a class="header" href="#score-display">Score Display</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameState {
    score: u32,
    score_text: Option&lt;Entity&gt;,
}

impl State for GameState {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.score_text = Some(spawn_hud_text(
            world,
            "Score: 0",
            HudAnchor::TopRight,
            Vec2::new(-20.0, 20.0),
        ));
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        if let Some(entity) = self.score_text {
            update_hud_text(world, entity, &amp;format!("Score: {}", self.score));
        }
    }
}

fn update_hud_text(world: &amp;mut World, entity: Entity, text: &amp;str) {
    if let Some(hud_text) = world.get_hud_text_mut(entity) {
        world.resources.text_cache.set_text(hud_text.text_index, text);
        hud_text.dirty = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fps-counter"><a class="header" href="#fps-counter">FPS Counter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FpsCounter {
    text_entity: Option&lt;Entity&gt;,
    frame_times: Vec&lt;f32&gt;,
}

impl FpsCounter {
    fn update(&amp;mut self, world: &amp;mut World, dt: f32) {
        self.frame_times.push(dt);
        if self.frame_times.len() &gt; 60 {
            self.frame_times.remove(0);
        }

        let avg_dt: f32 = self.frame_times.iter().sum::&lt;f32&gt;() / self.frame_times.len() as f32;
        let fps = (1.0 / avg_dt) as u32;

        if let Some(entity) = self.text_entity {
            update_hud_text(world, entity, &amp;format!("FPS: {}", fps));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-bar-label"><a class="header" href="#health-bar-label">Health Bar Label</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_health_ui(world: &amp;mut World) -&gt; Entity {
    let properties = TextProperties {
        font_size: 18.0,
        color: [1.0, 0.2, 0.2, 1.0],
        outline_width: 1.0,
        outline_color: [0.0, 0.0, 0.0, 1.0],
        ..Default::default()
    };

    spawn_hud_text_with_properties(
        world,
        "100 / 100",
        HudAnchor::BottomLeft,
        Vec2::new(80.0, -30.0),
        properties,
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="centered-message"><a class="header" href="#centered-message">Centered Message</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_game_over(world: &amp;mut World) -&gt; Entity {
    let properties = TextProperties {
        font_size: 64.0,
        color: [1.0, 0.0, 0.0, 1.0],
        text_alignment: TextAlignment::Center,
        outline_width: 3.0,
        outline_color: [0.0, 0.0, 0.0, 1.0],
        ..Default::default()
    };

    spawn_hud_text_with_properties(
        world,
        "GAME OVER\nPress R to Restart",
        HudAnchor::Center,
        Vec2::zeros(),
        properties,
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="removing-hud-text"><a class="header" href="#removing-hud-text">Removing HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_text(world: &amp;mut World, entity: Entity) {
    world.despawn(entity);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visibility-control"><a class="header" href="#visibility-control">Visibility Control</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(visible) = world.get_visible_mut(text_entity) {
    visible.0 = false;  // Hide text
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lines-rendering"><a class="header" href="#lines-rendering">Lines Rendering</a></h1>
<p>Debug line drawing for visualization, gizmos, and wireframes.</p>
<h2 id="basic-line-drawing"><a class="header" href="#basic-line-drawing">Basic Line Drawing</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::lines::*;

fn initialize(&amp;mut self, world: &amp;mut World) {
    let entity = world.spawn_entities(LINES_COMPONENT, 1)[0];

    let mut lines = Lines::new();
    lines.add(
        Vec3::new(0.0, 0.0, 0.0),
        Vec3::new(1.0, 1.0, 1.0),
        Vec4::new(1.0, 0.0, 0.0, 1.0),
    );

    world.set_lines(entity, lines);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lines-component"><a class="header" href="#lines-component">Lines Component</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lines {
    pub lines: Vec&lt;Line&gt;,
    pub version: u64,
}

pub struct Line {
    pub start: Vec3,
    pub end: Vec3,
    pub color: Vec4,  // RGBA, linear color space
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-lines"><a class="header" href="#adding-lines">Adding Lines</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut lines = Lines::new();

// Single line
lines.add(start, end, color);

// Multiple lines
lines.add(Vec3::zeros(), Vec3::x(), Vec4::new(1.0, 0.0, 0.0, 1.0));
lines.add(Vec3::zeros(), Vec3::y(), Vec4::new(0.0, 1.0, 0.0, 1.0));
lines.add(Vec3::zeros(), Vec3::z(), Vec4::new(0.0, 0.0, 1.0, 1.0));
<span class="boring">}</span></code></pre></pre>
<h2 id="drawing-shapes"><a class="header" href="#drawing-shapes">Drawing Shapes</a></h2>
<h3 id="coordinate-axes"><a class="header" href="#coordinate-axes">Coordinate Axes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_axes(lines: &amp;mut Lines, origin: Vec3, scale: f32) {
    let red = Vec4::new(1.0, 0.0, 0.0, 1.0);
    let green = Vec4::new(0.0, 1.0, 0.0, 1.0);
    let blue = Vec4::new(0.0, 0.0, 1.0, 1.0);

    lines.add(origin, origin + Vec3::x() * scale, red);
    lines.add(origin, origin + Vec3::y() * scale, green);
    lines.add(origin, origin + Vec3::z() * scale, blue);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wireframe-box"><a class="header" href="#wireframe-box">Wireframe Box</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_box(lines: &amp;mut Lines, center: Vec3, half_extents: Vec3, color: Vec4) {
    let min = center - half_extents;
    let max = center + half_extents;

    // Bottom face
    lines.add(Vec3::new(min.x, min.y, min.z), Vec3::new(max.x, min.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, min.z), Vec3::new(max.x, min.y, max.z), color);
    lines.add(Vec3::new(max.x, min.y, max.z), Vec3::new(min.x, min.y, max.z), color);
    lines.add(Vec3::new(min.x, min.y, max.z), Vec3::new(min.x, min.y, min.z), color);

    // Top face
    lines.add(Vec3::new(min.x, max.y, min.z), Vec3::new(max.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, max.y, min.z), Vec3::new(max.x, max.y, max.z), color);
    lines.add(Vec3::new(max.x, max.y, max.z), Vec3::new(min.x, max.y, max.z), color);
    lines.add(Vec3::new(min.x, max.y, max.z), Vec3::new(min.x, max.y, min.z), color);

    // Vertical edges
    lines.add(Vec3::new(min.x, min.y, min.z), Vec3::new(min.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, min.z), Vec3::new(max.x, max.y, min.z), color);
    lines.add(Vec3::new(max.x, min.y, max.z), Vec3::new(max.x, max.y, max.z), color);
    lines.add(Vec3::new(min.x, min.y, max.z), Vec3::new(min.x, max.y, max.z), color);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wireframe-sphere"><a class="header" href="#wireframe-sphere">Wireframe Sphere</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sphere(lines: &amp;mut Lines, center: Vec3, radius: f32, color: Vec4, segments: u32) {
    let step = std::f32::consts::TAU / segments as f32;

    // XY circle
    for index in 0..segments {
        let angle1 = index as f32 * step;
        let angle2 = (index + 1) as f32 * step;

        let p1 = center + Vec3::new(angle1.cos() * radius, angle1.sin() * radius, 0.0);
        let p2 = center + Vec3::new(angle2.cos() * radius, angle2.sin() * radius, 0.0);
        lines.add(p1, p2, color);
    }

    // XZ circle
    for index in 0..segments {
        let angle1 = index as f32 * step;
        let angle2 = (index + 1) as f32 * step;

        let p1 = center + Vec3::new(angle1.cos() * radius, 0.0, angle1.sin() * radius);
        let p2 = center + Vec3::new(angle2.cos() * radius, 0.0, angle2.sin() * radius);
        lines.add(p1, p2, color);
    }

    // YZ circle
    for index in 0..segments {
        let angle1 = index as f32 * step;
        let angle2 = (index + 1) as f32 * step;

        let p1 = center + Vec3::new(0.0, angle1.cos() * radius, angle1.sin() * radius);
        let p2 = center + Vec3::new(0.0, angle2.cos() * radius, angle2.sin() * radius);
        lines.add(p1, p2, color);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_grid(lines: &amp;mut Lines, size: f32, divisions: u32, color: Vec4) {
    let step = size / divisions as f32;
    let half = size / 2.0;

    for index in 0..=divisions {
        let offset = -half + index as f32 * step;

        // X-axis lines
        lines.add(
            Vec3::new(-half, 0.0, offset),
            Vec3::new(half, 0.0, offset),
            color,
        );

        // Z-axis lines
        lines.add(
            Vec3::new(offset, 0.0, -half),
            Vec3::new(offset, 0.0, half),
            color,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="arrow"><a class="header" href="#arrow">Arrow</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_arrow(lines: &amp;mut Lines, start: Vec3, end: Vec3, color: Vec4, head_size: f32) {
    lines.add(start, end, color);

    let direction = (end - start).normalize();
    let perpendicular = if direction.y.abs() &lt; 0.9 {
        direction.cross(&amp;Vec3::y()).normalize()
    } else {
        direction.cross(&amp;Vec3::x()).normalize()
    };

    let head_base = end - direction * head_size;
    let offset = perpendicular * head_size * 0.5;

    lines.add(end, head_base + offset, color);
    lines.add(end, head_base - offset, color);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="updating-lines"><a class="header" href="#updating-lines">Updating Lines</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(lines) = world.get_lines_mut(self.debug_lines) {
        lines.clear();

        // Draw velocity vectors for all physics bodies
        for entity in world.query(RIGID_BODY_COMPONENT | LOCAL_TRANSFORM) {
            if let (Some(body), Some(transform)) = (
                world.get_rigid_body(entity),
                world.get_local_transform(entity),
            ) {
                let start = transform.translation;
                let end = start + body.velocity;
                lines.add(start, end, Vec4::new(1.0, 1.0, 0.0, 1.0));
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-debug-visualization"><a class="header" href="#built-in-debug-visualization">Built-in Debug Visualization</a></h2>
<h3 id="bounding-volumes"><a class="header" href="#bounding-volumes">Bounding Volumes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_bounding_volumes = true;
<span class="boring">}</span></code></pre></pre>
<h3 id="selected-entity-bounds"><a class="header" href="#selected-entity-bounds">Selected Entity Bounds</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_selected_bounding_volume = true;
world.resources.graphics.bounding_volume_selected_entity = Some(entity);
<span class="boring">}</span></code></pre></pre>
<h3 id="surface-normals"><a class="header" href="#surface-normals">Surface Normals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.show_normals = true;
world.resources.graphics.normal_line_length = 0.2;
world.resources.graphics.normal_line_color = [0.0, 1.0, 0.0, 1.0];
<span class="boring">}</span></code></pre></pre>
<h2 id="gpu-culling"><a class="header" href="#gpu-culling">GPU Culling</a></h2>
<p>Lines are frustum-culled on the GPU for performance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.gpu_culling_enabled = true;
<span class="boring">}</span></code></pre></pre>
<h2 id="line-limits"><a class="header" href="#line-limits">Line Limits</a></h2>
<p>The system supports up to 1,000,000 lines per component:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_LINES: u32 = 1_000_000;
<span class="boring">}</span></code></pre></pre>
<h2 id="transform-gizmos"><a class="header" href="#transform-gizmos">Transform Gizmos</a></h2>
<p>Built-in gizmos for entity manipulation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::ecs::gizmos::*;

// Translation gizmo (XYZ arrows)
create_translation_gizmo(world, entity);

// Rotation gizmo (rings)
create_rotation_gizmo(world, entity);

// Scale gizmo (cubes with cylinders)
create_scale_gizmo(world, entity);
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-helpers"><a class="header" href="#debug-helpers">Debug Helpers</a></h2>
<h3 id="draw-physics-colliders"><a class="header" href="#draw-physics-colliders">Draw Physics Colliders</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_colliders(world: &amp;mut World, lines_entity: Entity) {
    if let Some(lines) = world.get_lines_mut(lines_entity) {
        lines.clear();

        for entity in world.query(COLLIDER_COMPONENT | GLOBAL_TRANSFORM) {
            if let (Some(collider), Some(transform)) = (
                world.get_collider(entity),
                world.get_global_transform(entity),
            ) {
                match &amp;collider.shape {
                    ColliderShape::Sphere { radius } =&gt; {
                        draw_sphere(lines, transform.translation, *radius, Vec4::new(0.0, 1.0, 0.0, 1.0), 16);
                    }
                    ColliderShape::Box { half_extents } =&gt; {
                        draw_box(lines, transform.translation, *half_extents, Vec4::new(0.0, 1.0, 0.0, 1.0));
                    }
                    _ =&gt; {}
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="draw-navigation-path"><a class="header" href="#draw-navigation-path">Draw Navigation Path</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_navmesh_path(lines: &amp;mut Lines, path: &amp;[Vec3], color: Vec4) {
    for index in 0..path.len().saturating_sub(1) {
        lines.add(path[index], path[index + 1], color);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="draw-ray"><a class="header" href="#draw-ray">Draw Ray</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_ray(lines: &amp;mut Lines, origin: Vec3, direction: Vec3, length: f32, color: Vec4) {
    let end = origin + direction.normalize() * length;
    draw_arrow(lines, origin, end, color, 0.1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips-3"><a class="header" href="#performance-tips-3">Performance Tips</a></h2>
<ul>
<li>Clear and rebuild lines each frame for dynamic visualization</li>
<li>Use GPU culling for large numbers of lines</li>
<li>Batch related lines in a single Lines component</li>
<li>Disable debug visualization in release builds</li>
</ul>
<h2 id="example-debug-overlay"><a class="header" href="#example-debug-overlay">Example: Debug Overlay</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DebugOverlay {
    lines_entity: Entity,
    show_colliders: bool,
    show_velocities: bool,
    show_paths: bool,
}

impl DebugOverlay {
    fn update(&amp;self, world: &amp;mut World) {
        if let Some(lines) = world.get_lines_mut(self.lines_entity) {
            lines.clear();

            if self.show_colliders {
                self.draw_all_colliders(world, lines);
            }

            if self.show_velocities {
                self.draw_all_velocities(world, lines);
            }

            if self.show_paths {
                self.draw_all_paths(world, lines);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-analyzer"><a class="header" href="#audio-analyzer">Audio Analyzer</a></h1>
<p>The AudioAnalyzer provides real-time FFT-based spectral analysis for music-reactive applications. It extracts frequency bands, detects beats, estimates tempo, and identifies musical structure changes like buildups, drops, and breakdowns.</p>
<h2 id="enabling-the-feature"><a class="header" href="#enabling-the-feature">Enabling the Feature</a></h2>
<p>The AudioAnalyzer requires the <code>fft</code> feature flag:</p>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "audio", "fft"] }
</code></pre>
<h2 id="creating-an-analyzer"><a class="header" href="#creating-an-analyzer">Creating an Analyzer</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;

let mut analyzer = AudioAnalyzer::new();

// Optional: configure sample rate and FFT size
let analyzer = AudioAnalyzer::new()
    .with_sample_rate(44100)
    .with_fft_size(4096);
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-audio-samples"><a class="header" href="#loading-audio-samples">Loading Audio Samples</a></h2>
<p>Load audio samples before analysis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// samples: Vec&lt;f32&gt; of audio data (mono, normalized to -1.0..1.0)
// sample_rate: typically 44100 or 48000
analyzer.load_samples(samples, sample_rate);

// Check if samples are loaded
if analyzer.has_samples() {
    let duration = analyzer.total_duration();
    let rate = analyzer.sample_rate();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="analyzing-audio"><a class="header" href="#analyzing-audio">Analyzing Audio</a></h2>
<p>Call <code>analyze_at_time</code> each frame with the current playback position:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    let current_time = self.playback_time; // seconds
    self.analyzer.analyze_at_time(current_time);

    // Now use analysis results
    let bass_level = self.analyzer.smoothed_bass;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="frequency-bands"><a class="header" href="#frequency-bands">Frequency Bands</a></h2>
<p>The analyzer splits the spectrum into six frequency bands:</p>
<div class="table-wrapper"><table><thead><tr><th>Band</th><th>Frequency Range</th><th>Use Cases</th></tr></thead><tbody>
<tr><td><code>sub_bass</code></td><td>20-60 Hz</td><td>Deep rumble, sub drops</td></tr>
<tr><td><code>bass</code></td><td>60-250 Hz</td><td>Kick drums, bass lines</td></tr>
<tr><td><code>low_mids</code></td><td>250-500 Hz</td><td>Guitar body, warmth</td></tr>
<tr><td><code>mids</code></td><td>500-2000 Hz</td><td>Vocals, melody</td></tr>
<tr><td><code>high_mids</code></td><td>2000-4000 Hz</td><td>Presence, clarity</td></tr>
<tr><td><code>highs</code></td><td>4000-12000 Hz</td><td>Hi-hats, cymbals, air</td></tr>
</tbody></table>
</div>
<p>Each band has raw and smoothed variants:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Raw values (instant, can be jumpy)
analyzer.sub_bass
analyzer.bass
analyzer.low_mids
analyzer.mids
analyzer.high_mids
analyzer.highs

// Smoothed values (attack/release filtered)
analyzer.smoothed_sub_bass
analyzer.smoothed_bass
analyzer.smoothed_low_mids
analyzer.smoothed_mids
analyzer.smoothed_high_mids
analyzer.smoothed_highs
<span class="boring">}</span></code></pre></pre>
<p>Values are normalized to 0.0-1.0 range using dB scaling.</p>
<h2 id="beat-detection"><a class="header" href="#beat-detection">Beat Detection</a></h2>
<p>The analyzer detects different drum elements:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// General onset detection
if analyzer.onset_detected {
    // Any significant transient occurred
}
analyzer.onset_decay  // 0.0-1.0, decays after onset

// Drum-specific detection
analyzer.kick_decay   // Triggers on kick drums (low frequency transients)
analyzer.snare_decay  // Triggers on snares (mid frequency transients)
analyzer.hat_decay    // Triggers on hi-hats (high frequency transients)
<span class="boring">}</span></code></pre></pre>
<p>Decay values start at 1.0 when triggered and decay over time.</p>
<h3 id="example-reactive-visuals"><a class="header" href="#example-reactive-visuals">Example: Reactive Visuals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    self.analyzer.analyze_at_time(self.time);

    // Scale objects on kick
    if let Some(transform) = world.get_local_transform_mut(self.cube) {
        let scale = 1.0 + self.analyzer.kick_decay * 0.5;
        transform.scale = Vec3::new(scale, scale, scale);
    }

    // Flash lights on snare
    if let Some(light) = world.get_point_light_mut(self.light) {
        light.intensity = 5.0 + self.analyzer.snare_decay * 20.0;
    }

    // Particle burst on onset
    if self.analyzer.onset_detected {
        self.spawn_burst_particles(world);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="tempo-and-beat-phase"><a class="header" href="#tempo-and-beat-phase">Tempo and Beat Phase</a></h2>
<p>The analyzer estimates BPM from onset timing patterns:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>analyzer.estimated_bpm    // Estimated beats per minute (60-200 range)
analyzer.beat_confidence  // 0.0-1.0, confidence in BPM estimate
analyzer.beat_phase       // 0.0-1.0, position within current beat
analyzer.time_since_last_beat  // Seconds since last detected kick
<span class="boring">}</span></code></pre></pre>
<h3 id="example-beat-synced-animation"><a class="header" href="#example-beat-synced-animation">Example: Beat-Synced Animation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    self.analyzer.analyze_at_time(self.time);

    // Pulse on beat (phase goes 0-&gt;1 each beat)
    let phase = self.analyzer.beat_phase;
    let pulse = 1.0 - phase; // High at beat start, low at end

    // Or use groove_sync for smooth beat alignment
    let sync = self.analyzer.groove_sync; // 1.0 at beat, 0.0 between
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spectral-features"><a class="header" href="#spectral-features">Spectral Features</a></h2>
<p>Advanced spectral descriptors for music analysis:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spectral centroid: "brightness" of sound (0.0-1.0, normalized)
analyzer.spectral_centroid
analyzer.smoothed_centroid

// Spectral flatness: noise vs tonal (0.0=tonal, 1.0=noise)
analyzer.spectral_flatness
analyzer.smoothed_flatness

// Spectral rolloff: frequency below which 85% of energy lies
analyzer.spectral_rolloff
analyzer.smoothed_rolloff

// Spectral flux: rate of spectral change
analyzer.spectral_flux

// Brightness change between frames
analyzer.brightness_delta

// Harmonic content change
analyzer.harmonic_change
<span class="boring">}</span></code></pre></pre>
<h3 id="example-color-based-on-brightness"><a class="header" href="#example-color-based-on-brightness">Example: Color Based on Brightness</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_material(&amp;self, world: &amp;mut World) {
    let brightness = self.analyzer.smoothed_centroid;

    // Interpolate from red (dark sound) to blue (bright sound)
    let color = [
        1.0 - brightness,
        0.2,
        brightness,
        1.0
    ];

    if let Some(material) = world.get_material_mut(self.entity) {
        material.base_color = color;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="energy-and-intensity"><a class="header" href="#energy-and-intensity">Energy and Intensity</a></h2>
<p>Track overall loudness and dynamics:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current energy level
analyzer.average_energy     // Short-term average
analyzer.long_term_energy   // Long-term average (for normalization)

// Intensity: current energy relative to long-term (can exceed 1.0)
analyzer.intensity

// Transient vs sustained balance
analyzer.transient_energy   // How "punchy" the sound is
analyzer.sustained_energy   // How "smooth" the sound is
analyzer.transient_ratio    // transient/sustained (0.0-2.0)

// Per-band transients
analyzer.low_transient      // Sudden low frequency increase
analyzer.mid_transient      // Sudden mid frequency increase
analyzer.high_transient     // Sudden high frequency increase
<span class="boring">}</span></code></pre></pre>
<h2 id="music-structure-detection"><a class="header" href="#music-structure-detection">Music Structure Detection</a></h2>
<p>Detect musical sections automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Building up (energy increasing, pre-drop)
analyzer.is_building
analyzer.build_intensity  // 0.0-1.0, increases during buildup

// Drop (sudden energy increase with kick)
analyzer.is_dropping
analyzer.drop_intensity   // Starts at 1.0, decays

// Breakdown (low energy section)
analyzer.is_breakdown
analyzer.breakdown_intensity
<span class="boring">}</span></code></pre></pre>
<h3 id="example-reactive-scene"><a class="header" href="#example-reactive-scene">Example: Reactive Scene</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    self.analyzer.analyze_at_time(self.time);

    // Dim lights during breakdown
    if self.analyzer.is_breakdown {
        world.resources.graphics.ambient_intensity =
            0.1 + 0.1 * self.analyzer.breakdown_intensity;
    }

    // Camera shake on drop
    if self.analyzer.is_dropping {
        self.camera_shake = self.analyzer.drop_intensity * 0.5;
    }

    // Speed up particles during buildup
    if self.analyzer.is_building {
        self.particle_speed = 1.0 + self.analyzer.build_intensity * 3.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="groove-analysis"><a class="header" href="#groove-analysis">Groove Analysis</a></h2>
<p>For tight rhythm synchronization:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// How well current timing aligns with detected beat grid
analyzer.groove_sync      // 1.0 at beat positions, 0.0 between

// Consistency of beat timing
analyzer.pocket_tightness // 0.0-1.0, higher = more consistent tempo
<span class="boring">}</span></code></pre></pre>
<h2 id="song-progress"><a class="header" href="#song-progress">Song Progress</a></h2>
<p>Track position within the loaded audio:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let progress = analyzer.song_progress(current_time); // 0.0-1.0
<span class="boring">}</span></code></pre></pre>
<h2 id="resetting-state"><a class="header" href="#resetting-state">Resetting State</a></h2>
<p>Reset all analysis state (useful when seeking or changing songs):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>analyzer.reset();
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct MusicVisualizer {
    analyzer: AudioAnalyzer,
    playback_time: f32,
    cube: Option&lt;Entity&gt;,
    light: Option&lt;Entity&gt;,
}

impl Default for MusicVisualizer {
    fn default() -&gt; Self {
        Self {
            analyzer: AudioAnalyzer::new(),
            playback_time: 0.0,
            cube: None,
            light: None,
        }
    }
}

impl State for MusicVisualizer {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Load audio samples from a file (implementation depends on audio loading)
        let (samples, sample_rate) = load_audio_file("assets/audio/track.wav");
        self.analyzer.load_samples(samples, sample_rate);

        // Create scene
        self.cube = Some(spawn_primitive(world, Primitive::Cube));
        self.light = Some(spawn_point_light(
            world,
            Vec3::new(0.0, 3.0, 0.0),
            Vec3::new(1.0, 1.0, 1.0),
            10.0,
            20.0
        ));

        spawn_fly_camera(world);
        spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;
        self.playback_time += dt;

        // Analyze current audio position
        self.analyzer.analyze_at_time(self.playback_time);

        // React to bass
        if let Some(cube) = self.cube {
            if let Some(transform) = world.get_local_transform_mut(cube) {
                let bass_scale = 1.0 + self.analyzer.smoothed_bass * 0.5;
                transform.scale = Vec3::new(bass_scale, bass_scale, bass_scale);
            }

            // Color based on spectral content
            if let Some(material) = world.get_material_mut(cube) {
                material.emissive = [
                    self.analyzer.smoothed_bass,
                    self.analyzer.smoothed_mids,
                    self.analyzer.smoothed_highs,
                ];
                material.emissive_strength = self.analyzer.intensity * 2.0;
            }
        }

        // Flash light on kick
        if let Some(light) = self.light {
            if let Some(point_light) = world.get_point_light_mut(light) {
                point_light.intensity = 5.0 + self.analyzer.kick_decay * 30.0;
            }
        }

        // Adjust ambient based on structure
        if self.analyzer.is_breakdown {
            world.resources.graphics.ambient_intensity = 0.05;
        } else if self.analyzer.is_dropping {
            world.resources.graphics.ambient_intensity = 0.3;
        } else {
            world.resources.graphics.ambient_intensity = 0.15;
        }
    }
}

fn main() {
    nightshade::run(MusicVisualizer::default());
}</code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Internal analysis parameters:</p>
<div class="table-wrapper"><table><thead><tr><th>Constant</th><th>Value</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>FFT_SIZE</code></td><td>4096</td><td>FFT window size</td></tr>
<tr><td><code>SPECTRUM_BINS</code></td><td>256</td><td>Number of spectrum display bins</td></tr>
<tr><td><code>ENERGY_HISTORY_SIZE</code></td><td>90</td><td>Frames of energy history</td></tr>
<tr><td><code>FLUX_HISTORY_SIZE</code></td><td>20</td><td>Frames of spectral flux history</td></tr>
<tr><td><code>ONSET_HISTORY_SIZE</code></td><td>512</td><td>Onset times stored for tempo estimation</td></tr>
</tbody></table>
</div>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li>FFT analysis runs at most every 8ms to avoid redundant computation</li>
<li>The analyzer is designed for pre-loaded audio, not real-time microphone input</li>
<li>For best results, use uncompressed or high-quality audio (WAV, FLAC)</li>
<li>Tempo estimation improves over time as more onsets are detected</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects-pass"><a class="header" href="#effects-pass">Effects Pass</a></h1>
<p>The EffectsPass is a configurable post-processing system with 38 shader parameters for visual effects. It includes distortions, color grading, raymarched overlays, retro effects, and more.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The EffectsPass operates as a render graph node that processes the rendered scene through a fullscreen shader. Effects can be combined and animated for music visualizers, stylized games, or creative applications.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Create and configure the effects state, then add the pass to your render graph:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::wgpu::passes::postprocess::effects::*;

fn configure_render_graph(
    &amp;mut self,
    graph: &amp;mut RenderGraph&lt;World&gt;,
    device: &amp;wgpu::Device,
    surface_format: wgpu::TextureFormat,
    resources: RenderResources,
) {
    // Create shared state handle
    let effects_state = create_effects_state();
    self.effects_state = Some(effects_state.clone());

    // Create and add the pass
    let effects_pass = EffectsPass::new(device, surface_format, effects_state);
    graph.add_pass(Box::new(effects_pass));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="modifying-effects"><a class="header" href="#modifying-effects">Modifying Effects</a></h2>
<p>Access the state handle to modify effect parameters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    if let Some(state_handle) = &amp;self.effects_state {
        if let Ok(mut state) = state_handle.write() {
            // Modify uniforms
            state.uniforms.chromatic_aberration = 0.02;
            state.uniforms.vignette = 0.3;

            // Enable/disable the entire pass
            state.enabled = true;

            // Auto-animate hue rotation
            state.animate_hue = false;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="effect-parameters"><a class="header" href="#effect-parameters">Effect Parameters</a></h2>
<h3 id="distortion-effects"><a class="header" href="#distortion-effects">Distortion Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chromatic aberration: RGB channel separation (0.0-0.1 typical)
uniforms.chromatic_aberration = 0.02;

// Wave distortion: sinusoidal screen warping
uniforms.wave_distortion = 0.5;

// Glitch intensity: digital glitch artifacts
uniforms.glitch_intensity = 0.3;

// VHS distortion: analog tape wobble and noise
uniforms.vhs_distortion = 0.4;

// Heat distortion: rising heat shimmer effect
uniforms.heat_distortion = 0.2;

// Screen shake: camera shake offset
uniforms.screen_shake = 0.1;

// Warp speed: hyperspace stretch effect
uniforms.warp_speed = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="color-effects"><a class="header" href="#color-effects">Color Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hue rotation: shift all colors around the wheel (0.0-1.0)
uniforms.hue_rotation = 0.5;

// Saturation: color intensity (0.0=grayscale, 1.0=normal, 2.0=oversaturated)
uniforms.saturation = 1.0;

// Color shift: global color offset
uniforms.color_shift = 0.1;

// Invert: color inversion (0.0=normal, 1.0=inverted)
uniforms.invert = 1.0;

// Color posterize: reduce color depth (0.0=off, higher=fewer colors)
uniforms.color_posterize = 4.0;

// Color cycle speed: rate of automatic color animation
uniforms.color_cycle_speed = 1.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="color-grading-1"><a class="header" href="#color-grading-1">Color Grading</a></h3>
<p>Apply preset color grades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
<span class="boring">}</span></code></pre></pre>
<p>Available modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>None</code></td><td>0</td><td>No color grading</td></tr>
<tr><td><code>Cyberpunk</code></td><td>1</td><td>Teal and magenta, high contrast</td></tr>
<tr><td><code>Sunset</code></td><td>2</td><td>Warm orange and purple tones</td></tr>
<tr><td><code>Grayscale</code></td><td>3</td><td>Black and white</td></tr>
<tr><td><code>Sepia</code></td><td>4</td><td>Vintage brown tones</td></tr>
<tr><td><code>Matrix</code></td><td>5</td><td>Green tinted, digital look</td></tr>
<tr><td><code>HotMetal</code></td><td>6</td><td>Heat map colors</td></tr>
</tbody></table>
</div>
<h3 id="geometric-effects"><a class="header" href="#geometric-effects">Geometric Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Kaleidoscope: mirror segments (0=off, 6-12 typical)
uniforms.kaleidoscope_segments = 6.0;

// Mirror mode: horizontal/vertical mirroring
uniforms.mirror_mode = 1.0;

// Zoom pulse: rhythmic zoom in/out
uniforms.zoom_pulse = 0.5;

// Radial blur: motion blur from center
uniforms.radial_blur = 0.2;

// Pixelate: reduce resolution (0=off, higher=larger pixels)
uniforms.pixelate = 8.0;
<span class="boring">}</span></code></pre></pre>
<h3 id="raymarched-overlays"><a class="header" href="#raymarched-overlays">Raymarched Overlays</a></h3>
<p>Blend raymarched 3D effects over the scene:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
uniforms.raymarch_blend = 0.5; // 0.0-1.0 blend with scene
uniforms.tunnel_speed = 1.0;   // Animation speed
uniforms.fractal_iterations = 4.0;
<span class="boring">}</span></code></pre></pre>
<p>Available raymarch modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Off</code></td><td>0</td><td>No raymarching</td></tr>
<tr><td><code>Tunnel</code></td><td>1</td><td>Infinite tunnel flythrough</td></tr>
<tr><td><code>Fractal</code></td><td>2</td><td>2D fractal pattern</td></tr>
<tr><td><code>Mandelbulb</code></td><td>3</td><td>3D mandelbulb fractal</td></tr>
<tr><td><code>PlasmaVortex</code></td><td>4</td><td>Swirling plasma effect</td></tr>
<tr><td><code>Geometric</code></td><td>5</td><td>Repeating geometric shapes</td></tr>
</tbody></table>
</div>
<h3 id="retro-effects"><a class="header" href="#retro-effects">Retro Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CRT scanlines: horizontal line overlay
uniforms.crt_scanlines = 0.5;

// Film grain: random noise overlay
uniforms.film_grain = 0.1;

// ASCII mode: convert to ASCII art characters
uniforms.ascii_mode = 1.0;

// Digital rain: Matrix-style falling characters
uniforms.digital_rain = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="glow-and-light-effects"><a class="header" href="#glow-and-light-effects">Glow and Light Effects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vignette: darken screen edges (0.0-1.0)
uniforms.vignette = 0.3;

// Glow intensity: bloom-like glow
uniforms.glow_intensity = 0.5;

// Lens flare: bright light artifacts
uniforms.lens_flare = 0.3;

// Edge glow: outline bright edges
uniforms.edge_glow = 0.2;

// Strobe: flashing white overlay
uniforms.strobe = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="plasma-and-patterns"><a class="header" href="#plasma-and-patterns">Plasma and Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Plasma intensity: colorful plasma overlay
uniforms.plasma_intensity = 0.5;

// Pulse rings: expanding circular rings
uniforms.pulse_rings = 0.3;

// Speed lines: motion/action lines
uniforms.speed_lines = 0.5;
<span class="boring">}</span></code></pre></pre>
<h3 id="image-processing"><a class="header" href="#image-processing">Image Processing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sharpen: edge enhancement (0.0-1.0)
uniforms.sharpen = 0.5;

// Feedback amount: recursive frame blending
uniforms.feedback_amount = 0.3;
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-effects"><a class="header" href="#combining-effects">Combining Effects</a></h2>
<p>Effects can be layered for complex looks:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cyberpunk aesthetic
state.uniforms.chromatic_aberration = 0.015;
state.uniforms.crt_scanlines = 0.2;
state.uniforms.vignette = 0.4;
state.uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
state.uniforms.glow_intensity = 0.3;

// VHS tape look
state.uniforms.vhs_distortion = 0.4;
state.uniforms.crt_scanlines = 0.3;
state.uniforms.film_grain = 0.15;
state.uniforms.chromatic_aberration = 0.01;
state.uniforms.saturation = 0.8;

// Psychedelic visualizer
state.uniforms.kaleidoscope_segments = 8.0;
state.uniforms.plasma_intensity = 0.3;
state.uniforms.hue_rotation = time * 0.1;
state.uniforms.wave_distortion = 0.2;
<span class="boring">}</span></code></pre></pre>
<h2 id="music-reactive-effects"><a class="header" href="#music-reactive-effects">Music-Reactive Effects</a></h2>
<p>Combine with AudioAnalyzer for reactive visuals:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    self.analyzer.analyze_at_time(self.time);

    if let Some(state_handle) = &amp;self.effects_state {
        if let Ok(mut state) = state_handle.write() {
            // Chromatic aberration on bass
            state.uniforms.chromatic_aberration =
                self.analyzer.smoothed_bass * 0.05;

            // Glitch on snare hits
            state.uniforms.glitch_intensity =
                self.analyzer.snare_decay * 0.5;

            // Zoom pulse on kick
            state.uniforms.zoom_pulse =
                self.analyzer.kick_decay * 0.3;

            // Color cycling based on energy
            state.uniforms.hue_rotation =
                self.time * self.analyzer.intensity * 0.2;

            // Screen shake on drops
            if self.analyzer.is_dropping {
                state.uniforms.screen_shake =
                    self.analyzer.drop_intensity * 0.1;
            } else {
                state.uniforms.screen_shake *= 0.9;
            }

            // Switch to tunnel during breakdown
            if self.analyzer.is_breakdown {
                state.uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
                state.uniforms.raymarch_blend =
                    self.analyzer.breakdown_intensity * 0.5;
            } else {
                state.uniforms.raymarch_blend *= 0.95;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-inputoutput-slots"><a class="header" href="#custom-inputoutput-slots">Custom Input/Output Slots</a></h2>
<p>By default, the EffectsPass reads from "input" and writes to "output". Configure custom slots:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let effects_pass = EffectsPass::with_slots(
    device,
    surface_format,
    effects_state,
    "post_bloom",    // Input slot name
    "final_output"   // Output slot name
);
<span class="boring">}</span></code></pre></pre>
<h2 id="disabling-the-pass"><a class="header" href="#disabling-the-pass">Disabling the Pass</a></h2>
<p>Temporarily bypass all effects:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(mut state) = state_handle.write() {
    state.enabled = false; // Pass through without processing
}
<span class="boring">}</span></code></pre></pre>
<p>When disabled, the pass performs a simple blit operation with no effects applied.</p>
<h2 id="auto-animate-hue"><a class="header" href="#auto-animate-hue">Auto-Animate Hue</a></h2>
<p>Enable automatic hue rotation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(mut state) = state_handle.write() {
    state.animate_hue = true; // Continuously rotate hue based on time
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;
use nightshade::render::wgpu::passes::postprocess::effects::*;

struct VisualDemo {
    effects_state: Option&lt;EffectsStateHandle&gt;,
    analyzer: AudioAnalyzer,
    time: f32,
}

impl Default for VisualDemo {
    fn default() -&gt; Self {
        Self {
            effects_state: None,
            analyzer: AudioAnalyzer::new(),
            time: 0.0,
        }
    }
}

impl State for VisualDemo {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        spawn_fly_camera(world);
        spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));

        // Load some geometry
        load_gltf(world, "assets/models/scene.glb");

        // Load audio for reactive effects
        let (samples, sample_rate) = load_audio_file("assets/audio/music.wav");
        self.analyzer.load_samples(samples, sample_rate);
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;
        self.time += dt;

        // Analyze audio
        self.analyzer.analyze_at_time(self.time);

        // Update effects based on audio
        if let Some(state_handle) = &amp;self.effects_state {
            if let Ok(mut state) = state_handle.write() {
                // Base effects
                state.uniforms.vignette = 0.3;
                state.uniforms.crt_scanlines = 0.15;

                // Audio-reactive
                state.uniforms.chromatic_aberration =
                    self.analyzer.smoothed_bass * 0.04;
                state.uniforms.glow_intensity =
                    self.analyzer.intensity * 0.5;
                state.uniforms.zoom_pulse =
                    self.analyzer.kick_decay * 0.2;

                // Structure-based
                if self.analyzer.is_dropping {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::Cyberpunk as f32;
                    state.uniforms.strobe =
                        self.analyzer.drop_intensity * 0.3;
                } else if self.analyzer.is_breakdown {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::Grayscale as f32;
                } else {
                    state.uniforms.color_grade_mode =
                        ColorGradeMode::None as f32;
                    state.uniforms.strobe = 0.0;
                }
            }
        }
    }

    fn configure_render_graph(
        &amp;mut self,
        graph: &amp;mut RenderGraph&lt;World&gt;,
        device: &amp;wgpu::Device,
        surface_format: wgpu::TextureFormat,
        resources: RenderResources,
    ) {
        // Add standard passes first...

        // Create effects pass
        let effects_state = create_effects_state();
        self.effects_state = Some(effects_state.clone());

        let effects_pass = EffectsPass::new(device, surface_format, effects_state);
        graph.add_pass(Box::new(effects_pass));
    }
}

fn main() {
    nightshade::run(VisualDemo::default());
}</code></pre></pre>
<h2 id="parameter-reference"><a class="header" href="#parameter-reference">Parameter Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Range</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>time</code></td><td>0.0+</td><td>0.0</td><td>Elapsed time (auto-updated)</td></tr>
<tr><td><code>chromatic_aberration</code></td><td>0.0-0.1</td><td>0.0</td><td>RGB channel offset</td></tr>
<tr><td><code>wave_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>Sinusoidal screen warp</td></tr>
<tr><td><code>color_shift</code></td><td>0.0-1.0</td><td>0.0</td><td>Global color offset</td></tr>
<tr><td><code>kaleidoscope_segments</code></td><td>0-16</td><td>0.0</td><td>Mirror segment count</td></tr>
<tr><td><code>crt_scanlines</code></td><td>0.0-1.0</td><td>0.0</td><td>Scanline intensity</td></tr>
<tr><td><code>vignette</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge darkening</td></tr>
<tr><td><code>plasma_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Plasma overlay strength</td></tr>
<tr><td><code>glitch_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Digital glitch amount</td></tr>
<tr><td><code>mirror_mode</code></td><td>0.0-1.0</td><td>0.0</td><td>Screen mirroring</td></tr>
<tr><td><code>invert</code></td><td>0.0-1.0</td><td>0.0</td><td>Color inversion</td></tr>
<tr><td><code>hue_rotation</code></td><td>0.0-1.0</td><td>0.0</td><td>Hue shift amount</td></tr>
<tr><td><code>raymarch_mode</code></td><td>0-5</td><td>0.0</td><td>Raymarch effect type</td></tr>
<tr><td><code>raymarch_blend</code></td><td>0.0-1.0</td><td>0.0</td><td>Raymarch overlay blend</td></tr>
<tr><td><code>film_grain</code></td><td>0.0-1.0</td><td>0.0</td><td>Noise grain intensity</td></tr>
<tr><td><code>sharpen</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge sharpening</td></tr>
<tr><td><code>pixelate</code></td><td>0-64</td><td>0.0</td><td>Pixel size (0=off)</td></tr>
<tr><td><code>color_posterize</code></td><td>0-16</td><td>0.0</td><td>Color quantization</td></tr>
<tr><td><code>radial_blur</code></td><td>0.0-1.0</td><td>0.0</td><td>Center blur amount</td></tr>
<tr><td><code>tunnel_speed</code></td><td>0.0-5.0</td><td>1.0</td><td>Tunnel animation speed</td></tr>
<tr><td><code>fractal_iterations</code></td><td>1-8</td><td>4.0</td><td>Fractal detail level</td></tr>
<tr><td><code>glow_intensity</code></td><td>0.0-1.0</td><td>0.0</td><td>Bloom-like glow</td></tr>
<tr><td><code>screen_shake</code></td><td>0.0-0.5</td><td>0.0</td><td>Camera shake offset</td></tr>
<tr><td><code>zoom_pulse</code></td><td>0.0-1.0</td><td>0.0</td><td>Rhythmic zoom amount</td></tr>
<tr><td><code>speed_lines</code></td><td>0.0-1.0</td><td>0.0</td><td>Motion line intensity</td></tr>
<tr><td><code>color_grade_mode</code></td><td>0-6</td><td>0.0</td><td>Color grading preset</td></tr>
<tr><td><code>vhs_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>VHS tape wobble</td></tr>
<tr><td><code>lens_flare</code></td><td>0.0-1.0</td><td>0.0</td><td>Light flare intensity</td></tr>
<tr><td><code>edge_glow</code></td><td>0.0-1.0</td><td>0.0</td><td>Edge highlight amount</td></tr>
<tr><td><code>saturation</code></td><td>0.0-2.0</td><td>1.0</td><td>Color saturation</td></tr>
<tr><td><code>warp_speed</code></td><td>0.0-1.0</td><td>0.0</td><td>Hyperspace stretch</td></tr>
<tr><td><code>pulse_rings</code></td><td>0.0-1.0</td><td>0.0</td><td>Expanding ring effect</td></tr>
<tr><td><code>heat_distortion</code></td><td>0.0-1.0</td><td>0.0</td><td>Heat shimmer amount</td></tr>
<tr><td><code>digital_rain</code></td><td>0.0-1.0</td><td>0.0</td><td>Matrix rain effect</td></tr>
<tr><td><code>strobe</code></td><td>0.0-1.0</td><td>0.0</td><td>Flash intensity</td></tr>
<tr><td><code>color_cycle_speed</code></td><td>0.0-5.0</td><td>1.0</td><td>Auto color animation rate</td></tr>
<tr><td><code>feedback_amount</code></td><td>0.0-1.0</td><td>0.0</td><td>Frame feedback blend</td></tr>
<tr><td><code>ascii_mode</code></td><td>0.0-1.0</td><td>0.0</td><td>ASCII art conversion</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h1>
<p>The simplest possible Nightshade application.</p>
<h2 id="complete-code"><a class="header" href="#complete-code">Complete Code</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct MinimalGame;

impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        spawn_fly_camera(world);

        let cube = spawn_primitive(world, Primitive::Cube);
        world.set_local_transform(cube, LocalTransform {
            translation: Vec3::new(0.0, 0.0, -5.0),
            ..Default::default()
        });

        spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
    }
}

fn main() {
    nightshade::run(MinimalGame);
}</code></pre></pre>
<h2 id="step-by-step-breakdown"><a class="header" href="#step-by-step-breakdown">Step-by-Step Breakdown</a></h2>
<h3 id="1-import-the-prelude"><a class="header" href="#1-import-the-prelude">1. Import the Prelude</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>The prelude exports all commonly used types:</p>
<ul>
<li><code>State</code> trait</li>
<li><code>World</code> struct</li>
<li><code>Entity</code> type</li>
<li>Math types (<code>Vec3</code>, <code>Vec4</code>, <code>Mat4</code>, etc.)</li>
<li>Component flags (<code>LOCAL_TRANSFORM</code>, <code>MESH_COMPONENT</code>, etc.)</li>
<li>Common functions (<code>spawn_primitive</code>, <code>spawn_fly_camera</code>, etc.)</li>
</ul>
<h3 id="2-define-your-game-state"><a class="header" href="#2-define-your-game-state">2. Define Your Game State</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame;
<span class="boring">}</span></code></pre></pre>
<p>Your game state struct holds all game-specific data. It can be empty for simple demos or contain complex game logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame {
    score: u32,
    player: Option&lt;Entity&gt;,
    enemies: Vec&lt;Entity&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-implement-the-state-trait"><a class="header" href="#3-implement-the-state-trait">3. Implement the State Trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        // Called once at startup
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>State</code> trait has many optional methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>initialize</code></td><td>Setup at startup</td></tr>
<tr><td><code>run_systems</code></td><td>Game logic each frame</td></tr>
<tr><td><code>on_keyboard_input</code></td><td>Key press/release</td></tr>
<tr><td><code>on_mouse_input</code></td><td>Mouse button events</td></tr>
<tr><td><code>on_mouse_motion</code></td><td>Mouse movement</td></tr>
<tr><td><code>on_window_resize</code></td><td>Window size changes</td></tr>
<tr><td><code>configure_render_graph</code></td><td>Custom rendering</td></tr>
</tbody></table>
</div>
<h3 id="4-set-up-the-scene"><a class="header" href="#4-set-up-the-scene">4. Set Up the Scene</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    // Camera (required to see anything)
    spawn_fly_camera(world);

    // A visible object
    let cube = spawn_primitive(world, Primitive::Cube);
    world.set_local_transform(cube, LocalTransform {
        translation: Vec3::new(0.0, 0.0, -5.0),
        ..Default::default()
    });

    // Light (required for PBR materials)
    spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-run-the-application"><a class="header" href="#5-run-the-application">5. Run the Application</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    nightshade::run(MinimalGame);
}</code></pre></pre>
<p>The <code>run</code> function:</p>
<ol>
<li>Creates the window</li>
<li>Initializes the renderer</li>
<li>Calls <code>initialize</code> on your state</li>
<li>Runs the game loop</li>
<li>Handles input events</li>
<li>Calls <code>run_systems</code> each frame</li>
</ol>
<h2 id="adding-cargotoml"><a class="header" href="#adding-cargotoml">Adding Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "minimal-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "https://github.com/user/nightshade", features = ["engine"] }
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>Release mode is recommended for better performance.</p>
<h2 id="controls-1"><a class="header" href="#controls-1">Controls</a></h2>
<p>The fly camera uses standard controls:</p>
<ul>
<li><strong>WASD</strong> - Move horizontally</li>
<li><strong>Space/Shift</strong> - Move up/down</li>
<li><strong>Mouse</strong> - Look around</li>
<li><strong>Escape</strong> - Release cursor</li>
</ul>
<h2 id="extending-the-example"><a class="header" href="#extending-the-example">Extending the Example</a></h2>
<h3 id="add-more-objects"><a class="header" href="#add-more-objects">Add More Objects</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_fly_camera(world);

    // Ground plane
    let ground = spawn_primitive(world, Primitive::Plane);
    world.set_local_transform(ground, LocalTransform {
        scale: Vec3::new(10.0, 1.0, 10.0),
        ..Default::default()
    });

    // Multiple cubes
    for index in 0..5 {
        let cube = spawn_primitive(world, Primitive::Cube);
        world.set_local_transform(cube, LocalTransform {
            translation: Vec3::new(index as f32 * 2.0 - 4.0, 0.5, -5.0),
            ..Default::default()
        });
    }

    spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-animation"><a class="header" href="#add-animation">Add Animation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MinimalGame {
    cube: Option&lt;Entity&gt;,
    time: f32,
}

impl State for MinimalGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        spawn_fly_camera(world);

        self.cube = Some(spawn_primitive(world, Primitive::Cube));
        world.set_local_transform(self.cube.unwrap(), LocalTransform {
            translation: Vec3::new(0.0, 0.0, -5.0),
            ..Default::default()
        });

        spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;
        self.time += dt;

        if let Some(cube) = self.cube {
            if let Some(transform) = world.get_local_transform_mut(cube) {
                transform.rotation = nalgebra_glm::quat_angle_axis(
                    self.time,
                    &amp;Vec3::y(),
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-input-handling"><a class="header" href="#add-input-handling">Add Input Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MinimalGame {
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
        if state == KeyState::Pressed {
            match key {
                KeyCode::Escape =&gt; std::process::exit(0),
                KeyCode::Space =&gt; self.spawn_cube(world),
                _ =&gt; {}
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>From this foundation, you can:</p>
<ul>
<li>Add physics with rigid bodies and colliders</li>
<li>Load 3D models with <code>load_gltf</code></li>
<li>Add skeletal animation</li>
<li>Implement game logic in <code>run_systems</code></li>
<li>Create UI with egui</li>
<li>Add audio with Kira</li>
</ul>
<p>See the other examples for complete implementations of these features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-game"><a class="header" href="#first-person-game">First Person Game</a></h1>
<p>A complete first-person shooter/exploration template with physics, audio, and weapons.</p>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct FirstPersonGame {
    player: Option&lt;Entity&gt;,
    weapon: Option&lt;Entity&gt;,
    health: f32,
    ammo: u32,
    score: u32,
    footstep_timer: f32,
}

impl Default for FirstPersonGame {
    fn default() -&gt; Self {
        Self {
            player: None,
            weapon: None,
            health: 100.0,
            ammo: 30,
            score: 0,
            footstep_timer: 0.0,
        }
    }
}

impl State for FirstPersonGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.setup_player(world);
        self.setup_level(world);
        self.setup_lighting(world);
        self.setup_ui(world);
        self.setup_audio(world);

        world.resources.input.cursor_locked = true;
        world.resources.input.cursor_visible = false;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;

        self.update_player_movement(world, dt);
        self.update_weapon_sway(world, dt);
        self.update_footsteps(world, dt);
        self.update_ui(world);

        update_physics(world, dt);
        update_character_controller(world);
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
        if state == KeyState::Pressed {
            match key {
                KeyCode::Escape =&gt; self.toggle_pause(world),
                KeyCode::KeyR =&gt; self.reload_weapon(),
                _ =&gt; {}
            }
        }
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {
        if button == MouseButton::Left &amp;&amp; state == ElementState::Pressed {
            self.fire_weapon(world);
        }
    }
}

impl FirstPersonGame {
    fn setup_player(&amp;mut self, world: &amp;mut World) {
        let player = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM |
            CHARACTER_CONTROLLER | COLLIDER_COMPONENT |
            AUDIO_LISTENER,
            1
        )[0];

        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, 1.8, 0.0),
            ..Default::default()
        });

        world.set_character_controller(player, CharacterController {
            height: 1.8,
            radius: 0.3,
            step_height: 0.3,
            max_slope: 45.0,
            move_speed: 5.0,
            jump_speed: 7.0,
            gravity: 20.0,
            grounded: false,
            velocity: Vec3::zeros(),
        });

        world.set_collider(player, ColliderComponent {
            shape: ColliderShape::Capsule {
                half_height: 0.6,
                radius: 0.3,
            },
            handle: None,
        });

        let camera = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA | PARENT,
            1
        )[0];

        world.set_local_transform(camera, LocalTransform {
            translation: Vec3::new(0.0, 0.7, 0.0),
            ..Default::default()
        });

        world.set_camera(camera, Camera {
            fov: 75.0_f32.to_radians(),
            near: 0.1,
            far: 1000.0,
            active: true,
            ..Default::default()
        });

        world.set_parent(camera, Parent(player));
        world.resources.active_camera = Some(camera);

        self.setup_weapon(world, camera);
        self.player = Some(player);
    }

    fn setup_weapon(&amp;mut self, world: &amp;mut World, camera: Entity) {
        let weapon = load_gltf(world, "assets/models/pistol.glb")[0];

        world.set_local_transform(weapon, LocalTransform {
            translation: Vec3::new(0.3, -0.2, -0.5),
            rotation: nalgebra_glm::quat_angle_axis(
                std::f32::consts::PI,
                &amp;Vec3::y(),
            ),
            scale: Vec3::new(0.1, 0.1, 0.1),
        });

        world.set_parent(weapon, Parent(camera));
        self.weapon = Some(weapon);
    }

    fn setup_level(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_primitive(world, Primitive::Plane);
        world.set_local_transform(floor, LocalTransform {
            scale: Vec3::new(50.0, 1.0, 50.0),
            ..Default::default()
        });
        world.set_material(floor, Material {
            base_color: [0.3, 0.3, 0.3, 1.0],
            roughness: 0.9,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Box {
            half_extents: Vec3::new(50.0, 0.1, 50.0),
        });

        for index in 0..10 {
            let wall = spawn_primitive(world, Primitive::Cube);
            let angle = index as f32 * std::f32::consts::TAU / 10.0;
            let distance = 20.0;

            world.set_local_transform(wall, LocalTransform {
                translation: Vec3::new(
                    angle.cos() * distance,
                    2.0,
                    angle.sin() * distance,
                ),
                scale: Vec3::new(5.0, 4.0, 0.5),
                rotation: nalgebra_glm::quat_angle_axis(angle, &amp;Vec3::y()),
            });

            add_collider(world, wall, ColliderShape::Box {
                half_extents: Vec3::new(5.0, 4.0, 0.5),
            });
        }

        for index in 0..5 {
            let crate_entity = spawn_primitive(world, Primitive::Cube);
            world.set_local_transform(crate_entity, LocalTransform {
                translation: Vec3::new(
                    (index as f32 - 2.0) * 3.0,
                    0.5,
                    -10.0,
                ),
                ..Default::default()
            });
            world.set_material(crate_entity, Material {
                base_color: [0.6, 0.4, 0.2, 1.0],
                roughness: 0.8,
                ..Default::default()
            });

            add_rigid_body(world, crate_entity, RigidBodyType::Dynamic, 10.0);
            add_collider(world, crate_entity, ColliderShape::Box {
                half_extents: Vec3::new(0.5, 0.5, 0.5),
            });
        }
    }

    fn setup_lighting(&amp;mut self, world: &amp;mut World) {
        spawn_directional_light(world, Vec3::new(-0.5, -1.0, -0.3));

        world.resources.graphics.ambient_intensity = 0.1;
    }

    fn setup_ui(&amp;mut self, world: &amp;mut World) {
        spawn_hud_text(
            world,
            &amp;format!("Health: {}", self.health as u32),
            HudAnchor::BottomLeft,
            Vec2::new(20.0, -30.0),
        );

        spawn_hud_text(
            world,
            &amp;format!("Ammo: {}", self.ammo),
            HudAnchor::BottomRight,
            Vec2::new(-20.0, -30.0),
        );

        let crosshair = spawn_hud_text(
            world,
            "+",
            HudAnchor::Center,
            Vec2::zeros(),
        );

        if let Some(hud_text) = world.get_hud_text_mut(crosshair) {
            hud_text.properties.font_size = 24.0;
            hud_text.properties.color = [1.0, 1.0, 1.0, 0.8];
        }
    }

    fn setup_audio(&amp;mut self, world: &amp;mut World) {
        load_sound(world, "footstep", "assets/audio/footstep.wav");
        load_sound(world, "gunshot", "assets/audio/gunshot.wav");
        load_sound(world, "reload", "assets/audio/reload.wav");
    }

    fn update_player_movement(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;
        let mouse_delta = world.resources.input.mouse.delta;

        let mut move_input = Vec3::zeros();
        if keyboard.is_key_pressed(KeyCode::KeyW) { move_input.z -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyS) { move_input.z += 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyA) { move_input.x -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyD) { move_input.x += 1.0; }

        if move_input.magnitude() &gt; 0.0 {
            move_input = move_input.normalize();
        }

        let sprint = keyboard.is_key_pressed(KeyCode::ShiftLeft);
        let speed = if sprint { 8.0 } else { 5.0 };

        if let Some(controller) = world.get_character_controller_mut(player) {
            if let Some(transform) = world.get_local_transform(player) {
                let forward = transform.rotation * Vec3::new(0.0, 0.0, -1.0);
                let right = transform.rotation * Vec3::new(1.0, 0.0, 0.0);

                let forward_flat = Vec3::new(forward.x, 0.0, forward.z).normalize();
                let right_flat = Vec3::new(right.x, 0.0, right.z).normalize();

                let world_move = forward_flat * -move_input.z + right_flat * move_input.x;
                controller.velocity.x = world_move.x * speed;
                controller.velocity.z = world_move.z * speed;

                if keyboard.is_key_just_pressed(KeyCode::Space) &amp;&amp; controller.grounded {
                    controller.velocity.y = controller.jump_speed;
                }
            }
        }

        if let Some(transform) = world.get_local_transform_mut(player) {
            let sensitivity = 0.002;
            let yaw = nalgebra_glm::quat_angle_axis(
                -mouse_delta.x * sensitivity,
                &amp;Vec3::y(),
            );
            transform.rotation = yaw * transform.rotation;
        }

        if let Some(camera) = world.resources.active_camera {
            if let Some(transform) = world.get_local_transform_mut(camera) {
                let sensitivity = 0.002;
                let pitch = nalgebra_glm::quat_angle_axis(
                    -mouse_delta.y * sensitivity,
                    &amp;Vec3::x(),
                );
                transform.rotation = transform.rotation * pitch;
            }
        }
    }

    fn update_weapon_sway(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(weapon) = self.weapon else { return };

        let mouse_delta = world.resources.input.mouse.delta;

        if let Some(transform) = world.get_local_transform_mut(weapon) {
            let target_x = 0.3 - mouse_delta.x * 0.001;
            let target_y = -0.2 - mouse_delta.y * 0.001;

            transform.translation.x += (target_x - transform.translation.x) * dt * 10.0;
            transform.translation.y += (target_y - transform.translation.y) * dt * 10.0;
        }
    }

    fn update_footsteps(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;
        let moving = keyboard.is_key_pressed(KeyCode::KeyW) ||
                     keyboard.is_key_pressed(KeyCode::KeyS) ||
                     keyboard.is_key_pressed(KeyCode::KeyA) ||
                     keyboard.is_key_pressed(KeyCode::KeyD);

        if let Some(controller) = world.get_character_controller(player) {
            if moving &amp;&amp; controller.grounded {
                self.footstep_timer -= dt;
                if self.footstep_timer &lt;= 0.0 {
                    play_sound(world, "footstep");
                    self.footstep_timer = 0.4;
                }
            }
        }
    }

    fn update_ui(&amp;mut self, world: &amp;mut World) {
    }

    fn fire_weapon(&amp;mut self, world: &amp;mut World) {
        if self.ammo == 0 {
            return;
        }

        self.ammo -= 1;
        play_sound(world, "gunshot");

        if let Some(camera) = world.resources.active_camera {
            if let Some(transform) = world.get_global_transform(camera) {
                let origin = transform.translation;
                let direction = transform.rotation * Vec3::new(0.0, 0.0, -1.0);

                if let Some(hit) = raycast(world, origin, direction, 100.0) {
                    if let Some(body) = world.get_rigid_body_mut(hit.entity) {
                        if body.body_type == RigidBodyType::Dynamic {
                            body.velocity += direction * 10.0;
                        }
                    }

                    self.spawn_impact_effect(world, hit.position, hit.normal);
                }
            }
        }
    }

    fn spawn_impact_effect(&amp;self, world: &amp;mut World, position: Vec3, normal: Vec3) {
        let sparks = world.spawn_entities(PARTICLE_EMITTER, 1)[0];

        world.set_particle_emitter(sparks, ParticleEmitter {
            emitter_type: EmitterType::Sparks,
            shape: EmitterShape::Point,
            position,
            direction: normal,
            spawn_rate: 0.0,
            burst_count: 20,
            particle_lifetime_min: 0.1,
            particle_lifetime_max: 0.3,
            initial_velocity_min: 3.0,
            initial_velocity_max: 8.0,
            velocity_spread: 0.5,
            gravity: Vec3::new(0.0, -10.0, 0.0),
            size_start: 0.02,
            size_end: 0.01,
            emissive_strength: 10.0,
            enabled: true,
            ..Default::default()
        });
    }

    fn reload_weapon(&amp;mut self) {
        self.ammo = 30;
    }

    fn toggle_pause(&amp;mut self, world: &amp;mut World) {
        world.resources.input.cursor_locked = !world.resources.input.cursor_locked;
        world.resources.input.cursor_visible = !world.resources.input.cursor_visible;
    }
}

fn main() {
    nightshade::run(FirstPersonGame::default());
}</code></pre></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="character-controller"><a class="header" href="#character-controller">Character Controller</a></h3>
<p>The character controller handles physics-based movement:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CharacterController {
    height: 1.8,        // Player height
    radius: 0.3,        // Collision radius
    step_height: 0.3,   // Max step up height
    max_slope: 45.0,    // Walkable slope angle
    move_speed: 5.0,    // Base move speed
    jump_speed: 7.0,    // Jump velocity
    gravity: 20.0,      // Gravity strength
    grounded: false,    // On ground?
    velocity: Vec3::zeros(),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="camera-setup"><a class="header" href="#camera-setup">Camera Setup</a></h3>
<p>First-person camera is parented to the player:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(camera, Parent(player));
<span class="boring">}</span></code></pre></pre>
<p>This makes the camera follow the player automatically.</p>
<h3 id="weapon-attachment"><a class="header" href="#weapon-attachment">Weapon Attachment</a></h3>
<p>The weapon is parented to the camera so it stays in view:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.set_parent(weapon, Parent(camera));
<span class="boring">}</span></code></pre></pre>
<h3 id="mouse-look"><a class="header" href="#mouse-look">Mouse Look</a></h3>
<p>Horizontal rotation (yaw) goes on the player body, vertical rotation (pitch) goes on the camera:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Yaw on player
transform.rotation = yaw * transform.rotation;

// Pitch on camera
transform.rotation = transform.rotation * pitch;
<span class="boring">}</span></code></pre></pre>
<p>This prevents gimbal lock and feels natural.</p>
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "fps-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "physics", "audio"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-person-game"><a class="header" href="#third-person-game">Third Person Game</a></h1>
<p>A complete third-person action game template with character animation, combat, and camera control.</p>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct ThirdPersonGame {
    player: Option&lt;Entity&gt;,
    camera: Option&lt;Entity&gt;,
    camera_target: Vec3,
    camera_distance: f32,
    camera_pitch: f32,
    camera_yaw: f32,

    player_state: PlayerState,
    attack_timer: f32,
    dodge_timer: f32,
    health: f32,
}

#[derive(Default, PartialEq)]
enum PlayerState {
    #[default]
    Idle,
    Walking,
    Running,
    Attacking,
    Dodging,
}

impl Default for ThirdPersonGame {
    fn default() -&gt; Self {
        Self {
            player: None,
            camera: None,
            camera_target: Vec3::zeros(),
            camera_distance: 5.0,
            camera_pitch: 0.3,
            camera_yaw: 0.0,
            player_state: PlayerState::Idle,
            attack_timer: 0.0,
            dodge_timer: 0.0,
            health: 100.0,
        }
    }
}

impl State for ThirdPersonGame {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        self.setup_player(world);
        self.setup_camera(world);
        self.setup_level(world);
        self.setup_lighting(world);
        self.setup_enemies(world);

        world.resources.input.cursor_locked = true;
        world.resources.input.cursor_visible = false;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;

        self.update_camera_input(world);
        self.update_player_movement(world, dt);
        self.update_player_state(world, dt);
        self.update_camera_position(world, dt);
        self.update_animations(world);

        update_physics(world, dt);
        update_character_controller(world);
        update_animation_players(world, dt);
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {
        if state == ElementState::Pressed {
            match button {
                MouseButton::Left =&gt; self.attack(world),
                MouseButton::Right =&gt; self.dodge(world),
                _ =&gt; {}
            }
        }
    }
}

impl ThirdPersonGame {
    fn setup_player(&amp;mut self, world: &amp;mut World) {
        let entities = load_gltf(world, "assets/models/character.glb");
        let player = entities[0];

        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, 0.0, 0.0),
            scale: Vec3::new(1.0, 1.0, 1.0),
            ..Default::default()
        });

        let controller_entity = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CHARACTER_CONTROLLER | COLLIDER_COMPONENT,
            1
        )[0];

        world.set_character_controller(controller_entity, CharacterController {
            height: 1.8,
            radius: 0.4,
            step_height: 0.3,
            max_slope: 45.0,
            move_speed: 4.0,
            jump_speed: 8.0,
            gravity: 20.0,
            grounded: false,
            velocity: Vec3::zeros(),
        });

        world.set_collider(controller_entity, ColliderComponent {
            shape: ColliderShape::Capsule {
                half_height: 0.6,
                radius: 0.4,
            },
            handle: None,
        });

        world.set_parent(player, Parent(controller_entity));
        world.set_local_transform(player, LocalTransform {
            translation: Vec3::new(0.0, -0.9, 0.0),
            ..Default::default()
        });

        if let Some(animation_player) = world.get_animation_player_mut(player) {
            animation_player.play("idle");
            animation_player.set_looping(true);
        }

        self.player = Some(controller_entity);
    }

    fn setup_camera(&amp;mut self, world: &amp;mut World) {
        let camera = world.spawn_entities(
            LOCAL_TRANSFORM | GLOBAL_TRANSFORM | CAMERA,
            1
        )[0];

        world.set_camera(camera, Camera {
            fov: 60.0_f32.to_radians(),
            near: 0.1,
            far: 1000.0,
            active: true,
            ..Default::default()
        });

        world.resources.active_camera = Some(camera);
        self.camera = Some(camera);
    }

    fn setup_level(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_primitive(world, Primitive::Plane);
        world.set_local_transform(floor, LocalTransform {
            scale: Vec3::new(100.0, 1.0, 100.0),
            ..Default::default()
        });
        world.set_material(floor, Material {
            base_color: [0.2, 0.5, 0.2, 1.0],
            roughness: 0.9,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Box {
            half_extents: Vec3::new(100.0, 0.1, 100.0),
        });

        for index in 0..20 {
            let rock = spawn_primitive(world, Primitive::Sphere);
            let x = (index % 5) as f32 * 15.0 - 30.0 + rand_range(-2.0, 2.0);
            let z = (index / 5) as f32 * 15.0 - 30.0 + rand_range(-2.0, 2.0);
            let scale = rand_range(0.5, 2.0);

            world.set_local_transform(rock, LocalTransform {
                translation: Vec3::new(x, scale * 0.5, z),
                scale: Vec3::new(scale, scale, scale),
                ..Default::default()
            });

            world.set_material(rock, Material {
                base_color: [0.4, 0.4, 0.4, 1.0],
                roughness: 0.95,
                ..Default::default()
            });

            add_collider(rock, ColliderShape::Sphere { radius: scale });
        }
    }

    fn setup_lighting(&amp;mut self, world: &amp;mut World) {
        spawn_directional_light(world, Vec3::new(-0.3, -1.0, -0.5));

        world.resources.graphics.ambient_intensity = 0.2;
    }

    fn setup_enemies(&amp;mut self, world: &amp;mut World) {
        for index in 0..5 {
            let angle = index as f32 * std::f32::consts::TAU / 5.0;
            let distance = 15.0;

            let enemy = load_gltf(world, "assets/models/enemy.glb")[0];
            world.set_local_transform(enemy, LocalTransform {
                translation: Vec3::new(
                    angle.cos() * distance,
                    0.0,
                    angle.sin() * distance,
                ),
                ..Default::default()
            });
        }
    }

    fn update_camera_input(&amp;mut self, world: &amp;mut World) {
        let mouse_delta = world.resources.input.mouse.delta;
        let scroll = world.resources.input.mouse.scroll_delta;

        let sensitivity = 0.003;
        self.camera_yaw -= mouse_delta.x * sensitivity;
        self.camera_pitch -= mouse_delta.y * sensitivity;

        self.camera_pitch = self.camera_pitch.clamp(-1.2, 1.2);

        self.camera_distance -= scroll.y * 0.5;
        self.camera_distance = self.camera_distance.clamp(2.0, 15.0);
    }

    fn update_player_movement(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        let Some(player) = self.player else { return };

        let keyboard = &amp;world.resources.input.keyboard;

        let mut move_input = Vec2::zeros();
        if keyboard.is_key_pressed(KeyCode::KeyW) { move_input.y -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyS) { move_input.y += 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyA) { move_input.x -= 1.0; }
        if keyboard.is_key_pressed(KeyCode::KeyD) { move_input.x += 1.0; }

        let running = keyboard.is_key_pressed(KeyCode::ShiftLeft);

        if move_input.magnitude() &gt; 0.0 {
            move_input = move_input.normalize();

            let camera_forward = Vec3::new(
                self.camera_yaw.sin(),
                0.0,
                self.camera_yaw.cos(),
            );
            let camera_right = Vec3::new(
                self.camera_yaw.cos(),
                0.0,
                -self.camera_yaw.sin(),
            );

            let world_direction = camera_forward * -move_input.y + camera_right * move_input.x;

            if let Some(transform) = world.get_local_transform_mut(player) {
                let target_rotation = nalgebra_glm::quat_angle_axis(
                    world_direction.x.atan2(world_direction.z),
                    &amp;Vec3::y(),
                );
                transform.rotation = nalgebra_glm::quat_slerp(
                    &amp;transform.rotation,
                    &amp;target_rotation,
                    dt * 10.0,
                );
            }

            let speed = if running { 8.0 } else { 4.0 };
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = world_direction.x * speed;
                controller.velocity.z = world_direction.z * speed;
            }

            self.player_state = if running { PlayerState::Running } else { PlayerState::Walking };
        } else {
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = 0.0;
                controller.velocity.z = 0.0;
            }
            self.player_state = PlayerState::Idle;
        }

        if keyboard.is_key_just_pressed(KeyCode::Space) {
            if let Some(controller) = world.get_character_controller_mut(player) {
                if controller.grounded {
                    controller.velocity.y = controller.jump_speed;
                }
            }
        }
    }

    fn update_player_state(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.attack_timer &gt; 0.0 {
            self.attack_timer -= dt;
            if self.attack_timer &lt;= 0.0 {
                self.player_state = PlayerState::Idle;
            }
        }

        if self.dodge_timer &gt; 0.0 {
            self.dodge_timer -= dt;
            if self.dodge_timer &lt;= 0.0 {
                self.player_state = PlayerState::Idle;
            }
        }
    }

    fn update_camera_position(&amp;mut self, world: &amp;mut World, dt: f32) {
        let Some(player) = self.player else { return };
        let Some(camera) = self.camera else { return };

        if let Some(player_transform) = world.get_global_transform(player) {
            let target = player_transform.translation + Vec3::new(0.0, 1.5, 0.0);
            self.camera_target = nalgebra_glm::lerp(
                &amp;self.camera_target,
                &amp;target,
                dt * 8.0,
            );
        }

        let offset = Vec3::new(
            self.camera_yaw.sin() * self.camera_pitch.cos(),
            self.camera_pitch.sin(),
            self.camera_yaw.cos() * self.camera_pitch.cos(),
        ) * self.camera_distance;

        let camera_position = self.camera_target + offset;

        if let Some(transform) = world.get_local_transform_mut(camera) {
            transform.translation = camera_position;

            let direction = (self.camera_target - camera_position).normalize();
            let pitch = (-direction.y).asin();
            let yaw = direction.x.atan2(direction.z);

            transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
                * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
        }
    }

    fn update_animations(&amp;mut self, world: &amp;mut World) {
        let Some(player) = self.player else { return };

        for child in world.get_children(player) {
            if let Some(animation_player) = world.get_animation_player_mut(child) {
                let animation_name = match self.player_state {
                    PlayerState::Idle =&gt; "idle",
                    PlayerState::Walking =&gt; "walk",
                    PlayerState::Running =&gt; "run",
                    PlayerState::Attacking =&gt; "attack",
                    PlayerState::Dodging =&gt; "dodge",
                };

                if animation_player.current_animation() != Some(animation_name) {
                    animation_player.blend_to(animation_name, 0.2);
                }
            }
        }
    }

    fn attack(&amp;mut self, world: &amp;mut World) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        self.player_state = PlayerState::Attacking;
        self.attack_timer = 0.6;

        self.check_attack_hits(world);
    }

    fn check_attack_hits(&amp;self, world: &amp;mut World) {
        let Some(player) = self.player else { return };

        if let Some(transform) = world.get_global_transform(player) {
            let attack_origin = transform.translation + Vec3::new(0.0, 1.0, 0.0);
            let forward = transform.rotation * Vec3::new(0.0, 0.0, 1.0);
            let attack_range = 2.0;

            for entity in world.query(GLOBAL_TRANSFORM) {
                if entity == player { continue; }

                if let Some(target_transform) = world.get_global_transform(entity) {
                    let to_target = target_transform.translation - attack_origin;
                    let distance = to_target.magnitude();
                    let dot = forward.dot(&amp;to_target.normalize());

                    if distance &lt; attack_range &amp;&amp; dot &gt; 0.5 {
                        self.apply_damage(world, entity, 25.0);
                    }
                }
            }
        }
    }

    fn apply_damage(&amp;self, world: &amp;mut World, entity: Entity, damage: f32) {
    }

    fn dodge(&amp;mut self, world: &amp;mut World) {
        if self.player_state == PlayerState::Attacking ||
           self.player_state == PlayerState::Dodging {
            return;
        }

        let Some(player) = self.player else { return };

        self.player_state = PlayerState::Dodging;
        self.dodge_timer = 0.5;

        if let Some(transform) = world.get_local_transform(player) {
            let forward = transform.rotation * Vec3::new(0.0, 0.0, -1.0);
            if let Some(controller) = world.get_character_controller_mut(player) {
                controller.velocity.x = forward.x * 12.0;
                controller.velocity.z = forward.z * 12.0;
            }
        }
    }
}

fn rand_range(min: f32, max: f32) -&gt; f32 {
    min + (max - min) * 0.5
}

fn main() {
    nightshade::run(ThirdPersonGame::default());
}</code></pre></pre>
<h2 id="key-systems"><a class="header" href="#key-systems">Key Systems</a></h2>
<h3 id="orbit-camera"><a class="header" href="#orbit-camera">Orbit Camera</a></h3>
<p>The camera orbits around the player using spherical coordinates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let offset = Vec3::new(
    self.camera_yaw.sin() * self.camera_pitch.cos(),
    self.camera_pitch.sin(),
    self.camera_yaw.cos() * self.camera_pitch.cos(),
) * self.camera_distance;
<span class="boring">}</span></code></pre></pre>
<p>Mouse X controls yaw, mouse Y controls pitch, scroll controls distance.</p>
<h3 id="camera-relative-movement"><a class="header" href="#camera-relative-movement">Camera-Relative Movement</a></h3>
<p>Player moves relative to where the camera is looking:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera_forward = Vec3::new(
    self.camera_yaw.sin(),
    0.0,
    self.camera_yaw.cos(),
);

let world_direction = camera_forward * -move_input.y + camera_right * move_input.x;
<span class="boring">}</span></code></pre></pre>
<h3 id="character-rotation"><a class="header" href="#character-rotation">Character Rotation</a></h3>
<p>The character smoothly rotates to face movement direction:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>transform.rotation = nalgebra_glm::quat_slerp(
    &amp;transform.rotation,
    &amp;target_rotation,
    dt * 10.0,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-blending"><a class="header" href="#animation-blending">Animation Blending</a></h3>
<p>Animations blend smoothly when state changes:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>animation_player.blend_to(animation_name, 0.2);  // 0.2 second blend
<span class="boring">}</span></code></pre></pre>
<h3 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h3>
<p>Simple state machine prevents conflicting actions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.player_state == PlayerState::Attacking ||
   self.player_state == PlayerState::Dodging {
    return;  // Can't move while attacking/dodging
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cargotoml-2"><a class="header" href="#cargotoml-2">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "third-person-game"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "physics"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-playground"><a class="header" href="#physics-playground">Physics Playground</a></h1>
<p>An interactive physics sandbox demonstrating rigid bodies, colliders, joints, and forces.</p>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use nightshade::prelude::*;

struct PhysicsPlayground {
    spawn_mode: SpawnMode,
    selected_entity: Option&lt;Entity&gt;,
    holding_entity: Option&lt;Entity&gt;,
    grab_distance: f32,
}

#[derive(Default, Clone, Copy)]
enum SpawnMode {
    #[default]
    Cube,
    Sphere,
    Capsule,
    Chain,
    Ragdoll,
}

impl Default for PhysicsPlayground {
    fn default() -&gt; Self {
        Self {
            spawn_mode: SpawnMode::Cube,
            selected_entity: None,
            holding_entity: None,
            grab_distance: 5.0,
        }
    }
}

impl State for PhysicsPlayground {
    fn initialize(&amp;mut self, world: &amp;mut World) {
        spawn_fly_camera(world);
        self.setup_environment(world);
        self.setup_ui(world);

        world.resources.input.cursor_locked = true;
    }

    fn run_systems(&amp;mut self, world: &amp;mut World) {
        let dt = world.resources.timing.delta_time;

        self.update_held_object(world);
        self.update_ui(world);

        update_physics(world, dt);
    }

    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {
        if state == KeyState::Pressed {
            match key {
                KeyCode::Digit1 =&gt; self.spawn_mode = SpawnMode::Cube,
                KeyCode::Digit2 =&gt; self.spawn_mode = SpawnMode::Sphere,
                KeyCode::Digit3 =&gt; self.spawn_mode = SpawnMode::Capsule,
                KeyCode::Digit4 =&gt; self.spawn_mode = SpawnMode::Chain,
                KeyCode::Digit5 =&gt; self.spawn_mode = SpawnMode::Ragdoll,
                KeyCode::KeyR =&gt; self.reset_scene(world),
                KeyCode::KeyF =&gt; self.apply_explosion(world),
                KeyCode::KeyG =&gt; self.toggle_gravity(world),
                _ =&gt; {}
            }
        }
    }

    fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {
        match (button, state) {
            (MouseButton::Left, ElementState::Pressed) =&gt; {
                self.spawn_object(world);
            }
            (MouseButton::Right, ElementState::Pressed) =&gt; {
                self.grab_object(world);
            }
            (MouseButton::Right, ElementState::Released) =&gt; {
                self.release_object(world);
            }
            (MouseButton::Middle, ElementState::Pressed) =&gt; {
                self.delete_at_cursor(world);
            }
            _ =&gt; {}
        }
    }
}

impl PhysicsPlayground {
    fn setup_environment(&amp;mut self, world: &amp;mut World) {
        let floor = spawn_primitive(world, Primitive::Plane);
        world.set_local_transform(floor, LocalTransform {
            scale: Vec3::new(50.0, 1.0, 50.0),
            ..Default::default()
        });
        world.set_material(floor, Material {
            base_color: [0.3, 0.3, 0.35, 1.0],
            roughness: 0.8,
            ..Default::default()
        });
        add_collider(world, floor, ColliderShape::Box {
            half_extents: Vec3::new(50.0, 0.1, 50.0),
        });

        self.spawn_walls(world);

        spawn_directional_light(world, Vec3::new(-0.5, -1.0, -0.3));
        world.resources.graphics.ambient_intensity = 0.2;
    }

    fn spawn_walls(&amp;mut self, world: &amp;mut World) {
        let wall_positions = [
            (Vec3::new(25.0, 2.5, 0.0), Vec3::new(0.5, 5.0, 50.0)),
            (Vec3::new(-25.0, 2.5, 0.0), Vec3::new(0.5, 5.0, 50.0)),
            (Vec3::new(0.0, 2.5, 25.0), Vec3::new(50.0, 5.0, 0.5)),
            (Vec3::new(0.0, 2.5, -25.0), Vec3::new(50.0, 5.0, 0.5)),
        ];

        for (position, half_extents) in wall_positions {
            let wall = spawn_primitive(world, Primitive::Cube);
            world.set_local_transform(wall, LocalTransform {
                translation: position,
                scale: half_extents * 2.0,
                ..Default::default()
            });
            world.set_material(wall, Material {
                base_color: [0.4, 0.4, 0.45, 1.0],
                roughness: 0.9,
                ..Default::default()
            });
            add_collider(world, wall, ColliderShape::Box { half_extents });
        }
    }

    fn setup_ui(&amp;mut self, world: &amp;mut World) {
        let help_text = "Controls:\n\
            1-5: Select spawn mode\n\
            Left Click: Spawn object\n\
            Right Click: Grab/throw\n\
            Middle Click: Delete\n\
            R: Reset scene\n\
            F: Explosion\n\
            G: Toggle gravity";

        spawn_hud_text(world, help_text, HudAnchor::TopLeft, Vec2::new(20.0, 20.0));

        spawn_hud_text(world, "Mode: Cube", HudAnchor::TopRight, Vec2::new(-20.0, 20.0));
    }

    fn update_ui(&amp;mut self, world: &amp;mut World) {
    }

    fn spawn_object(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let spawn_position = transform.translation +
            transform.rotation * Vec3::new(0.0, 0.0, -5.0);

        match self.spawn_mode {
            SpawnMode::Cube =&gt; self.spawn_cube(world, spawn_position),
            SpawnMode::Sphere =&gt; self.spawn_sphere(world, spawn_position),
            SpawnMode::Capsule =&gt; self.spawn_capsule(world, spawn_position),
            SpawnMode::Chain =&gt; self.spawn_chain(world, spawn_position),
            SpawnMode::Ragdoll =&gt; self.spawn_ragdoll(world, spawn_position),
        }
    }

    fn spawn_cube(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let cube = spawn_primitive(world, Primitive::Cube);

        world.set_local_transform(cube, LocalTransform {
            translation: position,
            rotation: random_rotation(),
            ..Default::default()
        });

        world.set_material(cube, Material {
            base_color: random_color(),
            roughness: 0.7,
            metallic: 0.1,
            ..Default::default()
        });

        add_rigid_body(world, cube, RigidBodyType::Dynamic, 1.0);
        add_collider(world, cube, ColliderShape::Box {
            half_extents: Vec3::new(0.5, 0.5, 0.5),
        });

        cube
    }

    fn spawn_sphere(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let sphere = spawn_primitive(world, Primitive::Sphere);

        world.set_local_transform(sphere, LocalTransform {
            translation: position,
            ..Default::default()
        });

        world.set_material(sphere, Material {
            base_color: random_color(),
            roughness: 0.3,
            metallic: 0.8,
            ..Default::default()
        });

        add_rigid_body(world, sphere, RigidBodyType::Dynamic, 1.0);
        add_collider(world, sphere, ColliderShape::Sphere { radius: 0.5 });

        sphere
    }

    fn spawn_capsule(&amp;self, world: &amp;mut World, position: Vec3) -&gt; Entity {
        let capsule = spawn_primitive(world, Primitive::Capsule);

        world.set_local_transform(capsule, LocalTransform {
            translation: position,
            rotation: random_rotation(),
            ..Default::default()
        });

        world.set_material(capsule, Material {
            base_color: random_color(),
            roughness: 0.5,
            metallic: 0.3,
            ..Default::default()
        });

        add_rigid_body(world, capsule, RigidBodyType::Dynamic, 1.0);
        add_collider(world, capsule, ColliderShape::Capsule {
            half_height: 0.5,
            radius: 0.3,
        });

        capsule
    }

    fn spawn_chain(&amp;self, world: &amp;mut World, start_position: Vec3) {
        let link_count = 10;
        let link_spacing = 0.8;
        let mut previous_link: Option&lt;Entity&gt; = None;

        for index in 0..link_count {
            let position = start_position + Vec3::new(0.0, -(index as f32 * link_spacing), 0.0);

            let link = spawn_primitive(world, Primitive::Capsule);
            world.set_local_transform(link, LocalTransform {
                translation: position,
                scale: Vec3::new(0.2, 0.3, 0.2),
                ..Default::default()
            });

            world.set_material(link, Material {
                base_color: [0.7, 0.7, 0.75, 1.0],
                roughness: 0.3,
                metallic: 0.9,
                ..Default::default()
            });

            if index == 0 {
                add_rigid_body(world, link, RigidBodyType::Static, 0.0);
            } else {
                add_rigid_body(world, link, RigidBodyType::Dynamic, 0.5);
            }

            add_collider(world, link, ColliderShape::Capsule {
                half_height: 0.15,
                radius: 0.1,
            });

            if let Some(prev) = previous_link {
                create_spherical_joint(
                    world,
                    prev,
                    Vec3::new(0.0, -link_spacing / 2.0, 0.0),
                    link,
                    Vec3::new(0.0, link_spacing / 2.0, 0.0),
                );
            }

            previous_link = Some(link);
        }
    }

    fn spawn_ragdoll(&amp;self, world: &amp;mut World, position: Vec3) {
        let torso = self.spawn_body_part(world, position, Vec3::new(0.3, 0.4, 0.2), [0.8, 0.6, 0.5, 1.0]);

        let head = self.spawn_body_part(
            world,
            position + Vec3::new(0.0, 0.6, 0.0),
            Vec3::new(0.15, 0.15, 0.15),
            [0.9, 0.7, 0.6, 1.0],
        );

        let left_arm = self.spawn_body_part(
            world,
            position + Vec3::new(-0.5, 0.2, 0.0),
            Vec3::new(0.25, 0.08, 0.08),
            [0.8, 0.6, 0.5, 1.0],
        );

        let right_arm = self.spawn_body_part(
            world,
            position + Vec3::new(0.5, 0.2, 0.0),
            Vec3::new(0.25, 0.08, 0.08),
            [0.8, 0.6, 0.5, 1.0],
        );

        let left_leg = self.spawn_body_part(
            world,
            position + Vec3::new(-0.15, -0.6, 0.0),
            Vec3::new(0.1, 0.3, 0.1),
            [0.3, 0.3, 0.5, 1.0],
        );

        let right_leg = self.spawn_body_part(
            world,
            position + Vec3::new(0.15, -0.6, 0.0),
            Vec3::new(0.1, 0.3, 0.1),
            [0.3, 0.3, 0.5, 1.0],
        );

        create_spherical_joint(world, torso, Vec3::new(0.0, 0.4, 0.0), head, Vec3::new(0.0, -0.15, 0.0));
        create_spherical_joint(world, torso, Vec3::new(-0.3, 0.2, 0.0), left_arm, Vec3::new(0.25, 0.0, 0.0));
        create_spherical_joint(world, torso, Vec3::new(0.3, 0.2, 0.0), right_arm, Vec3::new(-0.25, 0.0, 0.0));
        create_spherical_joint(world, torso, Vec3::new(-0.15, -0.4, 0.0), left_leg, Vec3::new(0.0, 0.3, 0.0));
        create_spherical_joint(world, torso, Vec3::new(0.15, -0.4, 0.0), right_leg, Vec3::new(0.0, 0.3, 0.0));
    }

    fn spawn_body_part(&amp;self, world: &amp;mut World, position: Vec3, half_extents: Vec3, color: [f32; 4]) -&gt; Entity {
        let part = spawn_primitive(world, Primitive::Cube);

        world.set_local_transform(part, LocalTransform {
            translation: position,
            scale: half_extents * 2.0,
            ..Default::default()
        });

        world.set_material(part, Material {
            base_color: color,
            roughness: 0.8,
            ..Default::default()
        });

        add_rigid_body(world, part, RigidBodyType::Dynamic, half_extents.x * half_extents.y * half_extents.z * 8.0);
        add_collider(world, part, ColliderShape::Box { half_extents });

        part
    }

    fn grab_object(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let origin = transform.translation;
        let direction = transform.rotation * Vec3::new(0.0, 0.0, -1.0);

        if let Some(hit) = raycast(world, origin, direction, 20.0) {
            if world.get_rigid_body(hit.entity).is_some() {
                self.holding_entity = Some(hit.entity);
                self.grab_distance = hit.distance;

                if let Some(body) = world.get_rigid_body_mut(hit.entity) {
                    body.linear_damping = 10.0;
                    body.angular_damping = 10.0;
                }
            }
        }
    }

    fn release_object(&amp;mut self, world: &amp;mut World) {
        if let Some(entity) = self.holding_entity.take() {
            if let Some(body) = world.get_rigid_body_mut(entity) {
                body.linear_damping = 0.0;
                body.angular_damping = 0.0;

                let Some(camera) = world.resources.active_camera else { return };
                let Some(transform) = world.get_global_transform(camera) else { return };

                let throw_direction = transform.rotation * Vec3::new(0.0, 0.0, -1.0);
                body.velocity = throw_direction * 20.0;
            }
        }
    }

    fn update_held_object(&amp;mut self, world: &amp;mut World) {
        let Some(entity) = self.holding_entity else { return };
        let Some(camera) = world.resources.active_camera else { return };
        let Some(camera_transform) = world.get_global_transform(camera) else { return };

        let target = camera_transform.translation +
            camera_transform.rotation * Vec3::new(0.0, 0.0, -self.grab_distance);

        if let Some(transform) = world.get_local_transform(entity) {
            let to_target = target - transform.translation;
            if let Some(body) = world.get_rigid_body_mut(entity) {
                body.velocity = to_target * 20.0;
            }
        }
    }

    fn delete_at_cursor(&amp;mut self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let origin = transform.translation;
        let direction = transform.rotation * Vec3::new(0.0, 0.0, -1.0);

        if let Some(hit) = raycast(world, origin, direction, 50.0) {
            world.despawn(hit.entity);
        }
    }

    fn apply_explosion(&amp;self, world: &amp;mut World) {
        let Some(camera) = world.resources.active_camera else { return };
        let Some(transform) = world.get_global_transform(camera) else { return };

        let explosion_center = transform.translation +
            transform.rotation * Vec3::new(0.0, 0.0, -5.0);
        let explosion_radius = 10.0;
        let explosion_force = 50.0;

        for entity in world.query(RIGID_BODY_COMPONENT | GLOBAL_TRANSFORM) {
            if let (Some(body), Some(entity_transform)) = (
                world.get_rigid_body_mut(entity),
                world.get_global_transform(entity),
            ) {
                let to_entity = entity_transform.translation - explosion_center;
                let distance = to_entity.magnitude();

                if distance &lt; explosion_radius &amp;&amp; distance &gt; 0.1 {
                    let falloff = 1.0 - (distance / explosion_radius);
                    let force = to_entity.normalize() * explosion_force * falloff;
                    body.velocity += force;
                }
            }
        }
    }

    fn toggle_gravity(&amp;self, world: &amp;mut World) {
        let gravity = &amp;mut world.resources.physics.gravity;
        if gravity.y &lt; 0.0 {
            *gravity = Vec3::zeros();
        } else {
            *gravity = Vec3::new(0.0, -9.81, 0.0);
        }
    }

    fn reset_scene(&amp;mut self, world: &amp;mut World) {
        let entities_to_remove: Vec&lt;Entity&gt; = world
            .query(RIGID_BODY_COMPONENT)
            .filter(|e| {
                world.get_rigid_body(*e)
                    .map(|b| b.body_type == RigidBodyType::Dynamic)
                    .unwrap_or(false)
            })
            .collect();

        for entity in entities_to_remove {
            world.despawn(entity);
        }

        self.holding_entity = None;
        self.selected_entity = None;
    }
}

fn random_color() -&gt; [f32; 4] {
    [
        0.3 + 0.7 * pseudo_random(),
        0.3 + 0.7 * pseudo_random(),
        0.3 + 0.7 * pseudo_random(),
        1.0,
    ]
}

fn random_rotation() -&gt; nalgebra_glm::Quat {
    nalgebra_glm::quat_angle_axis(
        pseudo_random() * std::f32::consts::TAU,
        &amp;Vec3::new(
            pseudo_random() - 0.5,
            pseudo_random() - 0.5,
            pseudo_random() - 0.5,
        ).normalize(),
    )
}

fn pseudo_random() -&gt; f32 {
    static mut SEED: u32 = 12345;
    unsafe {
        SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
        (SEED as f32 / u32::MAX as f32)
    }
}

fn main() {
    nightshade::run(PhysicsPlayground::default());
}</code></pre></pre>
<h2 id="features-demonstrated"><a class="header" href="#features-demonstrated">Features Demonstrated</a></h2>
<h3 id="object-spawning"><a class="header" href="#object-spawning">Object Spawning</a></h3>
<p>Spawn various physics primitives with random colors:</p>
<ul>
<li>Cubes</li>
<li>Spheres</li>
<li>Capsules</li>
</ul>
<h3 id="joint-systems"><a class="header" href="#joint-systems">Joint Systems</a></h3>
<p><strong>Chain</strong>: A series of capsules connected by spherical joints, anchored at the top.</p>
<p><strong>Ragdoll</strong>: A humanoid figure made of box body parts connected by joints:</p>
<ul>
<li>Head connected to torso</li>
<li>Arms connected to torso</li>
<li>Legs connected to torso</li>
</ul>
<h3 id="object-manipulation"><a class="header" href="#object-manipulation">Object Manipulation</a></h3>
<p><strong>Grab</strong>: Right-click to grab objects and move them with the camera.</p>
<p><strong>Throw</strong>: Release right-click to throw grabbed objects.</p>
<p><strong>Delete</strong>: Middle-click to delete objects.</p>
<h3 id="physics-effects"><a class="header" href="#physics-effects">Physics Effects</a></h3>
<p><strong>Explosion</strong>: Press F to apply radial force to nearby objects.</p>
<p><strong>Gravity Toggle</strong>: Press G to toggle between normal gravity and zero gravity.</p>
<h3 id="raycasting-1"><a class="header" href="#raycasting-1">Raycasting</a></h3>
<p>Used for:</p>
<ul>
<li>Selecting objects to grab</li>
<li>Deleting objects</li>
<li>Hit detection</li>
</ul>
<h2 id="cargotoml-3"><a class="header" href="#cargotoml-3">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "physics-playground"
version = "0.1.0"
edition = "2024"

[dependencies]
nightshade = { git = "...", features = ["engine", "physics"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h1>
<p>Nightshade uses Cargo feature flags to enable optional functionality. This allows you to include only the features you need, reducing compile times and binary size.</p>
<h2 id="core-features"><a class="header" href="#core-features">Core Features</a></h2>
<h3 id="engine"><a class="header" href="#engine"><code>engine</code></a></h3>
<p>The main engine feature. Required for all applications.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Window creation and event loop</li>
<li>wgpu rendering backend</li>
<li>ECS (freecs)</li>
<li>Transform hierarchy</li>
<li>Camera systems</li>
<li>Mesh rendering</li>
<li>Material system</li>
<li>Lighting (directional, point, spot)</li>
<li>Post-processing (bloom, tonemapping)</li>
<li>glTF/GLB model loading</li>
<li>Input handling (keyboard, mouse)</li>
<li>Timing system</li>
</ul>
<h3 id="physics-1"><a class="header" href="#physics-1"><code>physics</code></a></h3>
<p>Rapier3D physics integration.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "physics"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Rigid body simulation (dynamic, kinematic, static)</li>
<li>Collider shapes (box, sphere, capsule, cylinder, cone, convex hull, trimesh, heightfield)</li>
<li>Collision detection and callbacks</li>
<li>Physics joints (fixed, revolute, prismatic, spherical, rope, spring)</li>
<li>Character controllers</li>
<li>Raycasting</li>
<li>Continuous collision detection (CCD)</li>
</ul>
<p><strong>Additional Dependencies:</strong> rapier3d</p>
<h3 id="audio-1"><a class="header" href="#audio-1"><code>audio</code></a></h3>
<p>Kira audio engine integration.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "audio"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Sound loading (WAV, OGG, MP3, FLAC)</li>
<li>Sound playback with volume, pitch, panning</li>
<li>Spatial/3D audio</li>
<li>Audio listener component</li>
<li>Sound emitter components</li>
<li>Looping and one-shot sounds</li>
<li>Sound pooling</li>
</ul>
<p><strong>Additional Dependencies:</strong> kira</p>
<h3 id="gamepad"><a class="header" href="#gamepad"><code>gamepad</code></a></h3>
<p>Gamepad/controller support via gilrs.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "gamepad"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Gamepad detection and hot-plugging</li>
<li>Button input (face buttons, triggers, bumpers, D-pad)</li>
<li>Analog stick input with deadzone handling</li>
<li>Trigger pressure (0.0 - 1.0)</li>
<li>Rumble/vibration</li>
<li>Multiple gamepad support</li>
</ul>
<p><strong>Additional Dependencies:</strong> gilrs</p>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="terrain-1"><a class="header" href="#terrain-1"><code>terrain</code></a></h3>
<p>Procedural terrain generation with LOD.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "terrain"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Procedural noise-based terrain</li>
<li>GPU tessellation</li>
<li>Level-of-detail (LOD) system</li>
<li>Chunk streaming</li>
<li>Terrain height sampling</li>
<li>Custom terrain materials</li>
</ul>
<h3 id="grass"><a class="header" href="#grass"><code>grass</code></a></h3>
<p>GPU-accelerated grass rendering.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "grass"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Instanced grass blades (up to 500,000)</li>
<li>Wind animation</li>
<li>Grass interaction/bending</li>
<li>Multiple grass species</li>
<li>LOD-based density</li>
<li>Terrain integration</li>
<li>Subsurface scattering</li>
<li>Anisotropic specular</li>
</ul>
<p><strong>Requires:</strong> <code>terrain</code> feature for terrain integration</p>
<h3 id="navmesh"><a class="header" href="#navmesh"><code>navmesh</code></a></h3>
<p>AI navigation mesh generation via Recast.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "navmesh"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Navigation mesh generation from geometry</li>
<li>Pathfinding queries</li>
<li>NavMesh agent component</li>
<li>Off-mesh connections (ladders, teleports)</li>
<li>Area costs/weights</li>
<li>Dynamic obstacle avoidance</li>
</ul>
<p><strong>Additional Dependencies:</strong> recast-rs</p>
<h3 id="screenshot"><a class="header" href="#screenshot"><code>screenshot</code></a></h3>
<p>Screenshot capture functionality.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "screenshot"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Frame capture to PNG</li>
<li>Custom resolution screenshots</li>
<li>HDR capture</li>
</ul>
<h2 id="rendering-features"><a class="header" href="#rendering-features">Rendering Features</a></h2>
<h3 id="psx"><a class="header" href="#psx"><code>psx</code></a></h3>
<p>PlayStation 1-style retro rendering.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "psx"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Vertex snapping (wobbly vertices)</li>
<li>Affine texture mapping</li>
<li>Low-resolution rendering</li>
<li>Dithering</li>
<li>Limited color palette</li>
</ul>
<h3 id="ssao"><a class="header" href="#ssao"><code>ssao</code></a></h3>
<p>Screen-space ambient occlusion.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "ssao"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>SSAO render pass</li>
<li>Configurable radius and intensity</li>
<li>Blur pass for soft shadows</li>
</ul>
<h3 id="fft"><a class="header" href="#fft"><code>fft</code></a></h3>
<p>FFT-based audio analysis for music-reactive applications.</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "audio", "fft"] }
</code></pre>
<p><strong>Includes:</strong></p>
<ul>
<li>Real-time FFT spectral analysis</li>
<li>Six-band frequency decomposition (sub-bass to highs)</li>
<li>Beat detection (kick, snare, hi-hat)</li>
<li>BPM estimation and beat phase tracking</li>
<li>Music structure detection (buildups, drops, breakdowns)</li>
<li>Spectral features (centroid, flatness, rolloff, flux)</li>
<li>Onset detection with adaptive thresholding</li>
</ul>
<p><strong>Additional Dependencies:</strong> rustfft</p>
<p><strong>Requires:</strong> <code>audio</code> feature</p>
<h2 id="feature-combinations"><a class="header" href="#feature-combinations">Feature Combinations</a></h2>
<h3 id="minimal-game"><a class="header" href="#minimal-game">Minimal Game</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine"] }
</code></pre>
<p>Just rendering and input. Good for simple visualizations.</p>
<h3 id="standard-game"><a class="header" href="#standard-game">Standard Game</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "physics", "audio", "gamepad"] }
</code></pre>
<p>Full game features without terrain/grass.</p>
<h3 id="open-world-game"><a class="header" href="#open-world-game">Open World Game</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = [
    "engine",
    "physics",
    "audio",
    "gamepad",
    "terrain",
    "grass",
    "navmesh",
] }
</code></pre>
<p>Everything for large outdoor environments.</p>
<h3 id="retro-game"><a class="header" href="#retro-game">Retro Game</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "physics", "psx"] }
</code></pre>
<p>PlayStation 1-style rendering with physics.</p>
<h3 id="music-visualizer"><a class="header" href="#music-visualizer">Music Visualizer</a></h3>
<pre><code class="language-toml">[dependencies]
nightshade = { git = "...", features = ["engine", "audio", "fft"] }
</code></pre>
<p>Audio-reactive visualizations with FFT analysis.</p>
<h2 id="feature-dependencies"><a class="header" href="#feature-dependencies">Feature Dependencies</a></h2>
<p>Some features have implicit dependencies:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Depends On</th></tr></thead><tbody>
<tr><td><code>grass</code></td><td>Optionally uses <code>terrain</code></td></tr>
<tr><td><code>navmesh</code></td><td>None</td></tr>
<tr><td><code>terrain</code></td><td>None</td></tr>
<tr><td><code>psx</code></td><td>None</td></tr>
<tr><td><code>ssao</code></td><td>None</td></tr>
<tr><td><code>audio</code></td><td>None</td></tr>
<tr><td><code>physics</code></td><td>None</td></tr>
<tr><td><code>gamepad</code></td><td>None</td></tr>
<tr><td><code>fft</code></td><td>Requires <code>audio</code></td></tr>
</tbody></table>
</div>
<h2 id="compile-time-impact"><a class="header" href="#compile-time-impact">Compile-Time Impact</a></h2>
<p>Features affect compile times and binary sizes:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Compile Time</th><th>Binary Size</th></tr></thead><tbody>
<tr><td><code>engine</code></td><td>Base</td><td>Base</td></tr>
<tr><td><code>physics</code></td><td>+15-20%</td><td>+2-3 MB</td></tr>
<tr><td><code>audio</code></td><td>+10-15%</td><td>+1-2 MB</td></tr>
<tr><td><code>gamepad</code></td><td>+5-10%</td><td>+0.5 MB</td></tr>
<tr><td><code>terrain</code></td><td>+5%</td><td>+0.5 MB</td></tr>
<tr><td><code>grass</code></td><td>+5%</td><td>+0.5 MB</td></tr>
<tr><td><code>navmesh</code></td><td>+10-15%</td><td>+1-2 MB</td></tr>
<tr><td><code>screenshot</code></td><td>+2%</td><td>+0.2 MB</td></tr>
<tr><td><code>psx</code></td><td>+2%</td><td>+0.1 MB</td></tr>
<tr><td><code>ssao</code></td><td>+2%</td><td>+0.1 MB</td></tr>
<tr><td><code>fft</code></td><td>+5%</td><td>+0.5 MB</td></tr>
</tbody></table>
</div>
<h2 id="checking-enabled-features"><a class="header" href="#checking-enabled-features">Checking Enabled Features</a></h2>
<p>At runtime, check if features are enabled:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "physics")]
fn setup_physics(world: &amp;mut World) {
    // Physics-specific code
}

#[cfg(feature = "audio")]
fn setup_audio(world: &amp;mut World) {
    // Audio-specific code
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h2>
<p>Write code that works with or without features:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    spawn_fly_camera(world);
    spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));

    #[cfg(feature = "physics")]
    {
        let cube = spawn_primitive(world, Primitive::Cube);
        add_rigid_body(world, cube, RigidBodyType::Dynamic, 1.0);
        add_collider(world, cube, ColliderShape::Box {
            half_extents: Vec3::new(0.5, 0.5, 0.5),
        });
    }

    #[cfg(feature = "audio")]
    {
        load_sound(world, "music", "assets/audio/background.ogg");
        play_sound(world, "music");
    }

    #[cfg(feature = "terrain")]
    {
        spawn_terrain(world, TerrainConfig::default(), Vec3::zeros());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="default-features"><a class="header" href="#default-features">Default Features</a></h2>
<p>Nightshade has no default features. You must explicitly enable what you need:</p>
<pre><code class="language-toml"># This won't compile - no features enabled
nightshade = { git = "..." }

# This works - engine feature enabled
nightshade = { git = "...", features = ["engine"] }
</code></pre>
<h2 id="all-features"><a class="header" href="#all-features">All Features</a></h2>
<p>Enable everything:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = [
    "engine",
    "physics",
    "audio",
    "gamepad",
    "terrain",
    "grass",
    "navmesh",
    "screenshot",
    "psx",
    "ssao",
    "fft",
] }
</code></pre>
<p>This is only recommended for development/experimentation. For release builds, enable only what you need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<p>Nightshade supports multiple platforms through wgpu's cross-platform abstractions.</p>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Status</th><th>Backend</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows 10/11</td><td>Full Support</td><td>Vulkan, DX12</td><td>Primary development platform</td></tr>
<tr><td>Linux</td><td>Full Support</td><td>Vulkan</td><td>X11 and Wayland</td></tr>
<tr><td>macOS</td><td>Full Support</td><td>Metal</td><td>Requires macOS 10.13+</td></tr>
<tr><td>Web (WASM)</td><td>Experimental</td><td>WebGPU</td><td>Modern browsers only</td></tr>
</tbody></table>
</div>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>Windows 10 version 1903 or later (for DX12)</li>
<li>Windows 10 version 1607 or later (for Vulkan)</li>
<li>GPU with Vulkan 1.1 or DirectX 12 support</li>
</ul>
<h3 id="graphics-backends"><a class="header" href="#graphics-backends">Graphics Backends</a></h3>
<p>Windows supports multiple backends in order of preference:</p>
<ol>
<li><strong>Vulkan</strong> - Best performance and feature support</li>
<li><strong>DirectX 12</strong> - Native Windows API, good compatibility</li>
<li><strong>DirectX 11</strong> - Fallback for older hardware</li>
</ol>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="distribution"><a class="header" href="#distribution">Distribution</a></h3>
<p>The executable is self-contained. Include your <code>assets</code> folder alongside the executable.</p>
<pre><code>game/
├── game.exe
└── assets/
    ├── models/
    ├── textures/
    └── audio/
</code></pre>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<h3 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h3>
<ul>
<li>X11 or Wayland display server</li>
<li>Vulkan 1.1 compatible GPU and drivers</li>
<li>Common distributions: Ubuntu 20.04+, Fedora 33+, Arch Linux</li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Install Vulkan development packages:</p>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt install libvulkan1 vulkan-tools libvulkan-dev
sudo apt install libasound2-dev  # For audio feature
</code></pre>
<p><strong>Fedora:</strong></p>
<pre><code class="language-bash">sudo dnf install vulkan-loader vulkan-tools vulkan-headers
sudo dnf install alsa-lib-devel  # For audio feature
</code></pre>
<p><strong>Arch Linux:</strong></p>
<pre><code class="language-bash">sudo pacman -S vulkan-icd-loader vulkan-tools vulkan-headers
sudo pacman -S alsa-lib  # For audio feature
</code></pre>
<h3 id="building-1"><a class="header" href="#building-1">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="wayland-support"><a class="header" href="#wayland-support">Wayland Support</a></h3>
<p>Nightshade uses winit which supports both X11 and Wayland. The backend is selected automatically based on environment:</p>
<pre><code class="language-bash"># Force X11
WINIT_UNIX_BACKEND=x11 ./game

# Force Wayland
WINIT_UNIX_BACKEND=wayland ./game
</code></pre>
<h3 id="distribution-1"><a class="header" href="#distribution-1">Distribution</a></h3>
<p>Create an AppImage or distribute with a shell script:</p>
<pre><code class="language-bash">#!/bin/bash
cd "$(dirname "$0")"
./game
</code></pre>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<h3 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h3>
<ul>
<li>macOS 10.13 (High Sierra) or later</li>
<li>Metal-capable GPU (most Macs from 2012+)</li>
</ul>
<h3 id="building-2"><a class="header" href="#building-2">Building</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="code-signing"><a class="header" href="#code-signing">Code Signing</a></h3>
<p>For distribution, sign your application:</p>
<pre><code class="language-bash">codesign --deep --force --sign "Developer ID Application: Your Name" target/release/game
</code></pre>
<h3 id="app-bundle"><a class="header" href="#app-bundle">App Bundle</a></h3>
<p>Create a macOS app bundle:</p>
<pre><code>Game.app/
└── Contents/
    ├── Info.plist
    ├── MacOS/
    │   └── game
    └── Resources/
        └── assets/
</code></pre>
<p><strong>Info.plist:</strong></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;CFBundleExecutable&lt;/key&gt;
    &lt;string&gt;game&lt;/string&gt;
    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
    &lt;string&gt;com.yourcompany.game&lt;/string&gt;
    &lt;key&gt;CFBundleName&lt;/key&gt;
    &lt;string&gt;Game&lt;/string&gt;
    &lt;key&gt;CFBundleVersion&lt;/key&gt;
    &lt;string&gt;1.0&lt;/string&gt;
    &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
    &lt;string&gt;1.0&lt;/string&gt;
    &lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;
    &lt;string&gt;10.13&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<h2 id="web-webassembly"><a class="header" href="#web-webassembly">Web (WebAssembly)</a></h2>
<h3 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h3>
<ul>
<li>Modern browser with WebGPU support</li>
<li>Chrome 113+, Edge 113+, Firefox (Nightly with flag)</li>
</ul>
<h3 id="building-3"><a class="header" href="#building-3">Building</a></h3>
<p>Install wasm-pack:</p>
<pre><code class="language-bash">cargo install wasm-pack
</code></pre>
<p>Build for web:</p>
<pre><code class="language-bash">wasm-pack build --target web
</code></pre>
<h3 id="html-template"><a class="header" href="#html-template">HTML Template</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Game&lt;/title&gt;
    &lt;style&gt;
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
    &lt;script type="module"&gt;
        import init from './pkg/game.js';
        init();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Web builds have some limitations:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th></tr></thead><tbody>
<tr><td>Rendering</td><td>Supported</td></tr>
<tr><td>Input</td><td>Supported</td></tr>
<tr><td>Audio</td><td>Supported (Web Audio)</td></tr>
<tr><td>Gamepad</td><td>Supported (Gamepad API)</td></tr>
<tr><td>Physics</td><td>Supported</td></tr>
<tr><td>File System</td><td>Limited (no direct access)</td></tr>
<tr><td>Threads</td><td>Limited (requires SharedArrayBuffer)</td></tr>
</tbody></table>
</div>
<h3 id="asset-loading"><a class="header" href="#asset-loading">Asset Loading</a></h3>
<p>Assets must be served over HTTP. Use fetch API for loading:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
async fn load_assets() {
    // Assets loaded via HTTP fetch
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h2>
<h3 id="windows-from-linux"><a class="header" href="#windows-from-linux">Windows from Linux</a></h3>
<p>Install the MinGW toolchain:</p>
<pre><code class="language-bash">sudo apt install mingw-w64
rustup target add x86_64-pc-windows-gnu
cargo build --release --target x86_64-pc-windows-gnu
</code></pre>
<h3 id="linux-from-windows"><a class="header" href="#linux-from-windows">Linux from Windows</a></h3>
<p>Use WSL2 or Docker:</p>
<pre><code class="language-bash"># In WSL2
cargo build --release --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="macos-cross-compilation"><a class="header" href="#macos-cross-compilation">macOS Cross-Compilation</a></h3>
<p>Cross-compiling to macOS is complex due to SDK requirements. Consider using CI/CD services like GitHub Actions with macOS runners.</p>
<h2 id="gpu-requirements"><a class="header" href="#gpu-requirements">GPU Requirements</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Requirement</th></tr></thead><tbody>
<tr><td>API</td><td>Vulkan 1.1 / DX12 / Metal</td></tr>
<tr><td>VRAM</td><td>2 GB</td></tr>
<tr><td>Shader Model</td><td>5.0</td></tr>
</tbody></table>
</div>
<h3 id="recommended-requirements"><a class="header" href="#recommended-requirements">Recommended Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Requirement</th></tr></thead><tbody>
<tr><td>API</td><td>Vulkan 1.2+</td></tr>
<tr><td>VRAM</td><td>4+ GB</td></tr>
<tr><td>Shader Model</td><td>6.0</td></tr>
</tbody></table>
</div>
<h3 id="feature-support-by-gpu-generation"><a class="header" href="#feature-support-by-gpu-generation">Feature Support by GPU Generation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>GPU</th><th>Basic Rendering</th><th>Tessellation</th><th>Compute Culling</th></tr></thead><tbody>
<tr><td>Intel HD 4000+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>NVIDIA GTX 600+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>AMD GCN 1.0+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Apple M1+</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h2 id="performance-by-platform"><a class="header" href="#performance-by-platform">Performance by Platform</a></h2>
<p>Relative performance (higher is better):</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Performance</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows (Vulkan)</td><td>100%</td><td>Best overall</td></tr>
<tr><td>Windows (DX12)</td><td>95%</td><td>Slightly more overhead</td></tr>
<tr><td>Linux (Vulkan)</td><td>98%</td><td>Excellent with proper drivers</td></tr>
<tr><td>macOS (Metal)</td><td>90%</td><td>Good, but Metal has different characteristics</td></tr>
<tr><td>Web (WebGPU)</td><td>70%</td><td>JavaScript overhead</td></tr>
</tbody></table>
</div>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="windows-no-suitable-adapter-found"><a class="header" href="#windows-no-suitable-adapter-found">Windows: "No suitable adapter found"</a></h3>
<ul>
<li>Update GPU drivers</li>
<li>Install Vulkan Runtime</li>
<li>Try forcing DX12: <code>WGPU_BACKEND=dx12 ./game.exe</code></li>
</ul>
<h3 id="linux-failed-to-create-vulkan-instance"><a class="header" href="#linux-failed-to-create-vulkan-instance">Linux: "Failed to create Vulkan instance"</a></h3>
<ul>
<li>Install Vulkan drivers for your GPU</li>
<li>Check <code>vulkaninfo</code> command works</li>
<li>Verify ICD loader: <code>ls /usr/share/vulkan/icd.d/</code></li>
</ul>
<h3 id="macos-metal-not-available"><a class="header" href="#macos-metal-not-available">macOS: "Metal not available"</a></h3>
<ul>
<li>Update macOS to 10.13+</li>
<li>Check GPU supports Metal: Apple Menu &gt; About This Mac &gt; System Report &gt; Graphics</li>
</ul>
<h3 id="web-webgpu-not-supported"><a class="header" href="#web-webgpu-not-supported">Web: "WebGPU not supported"</a></h3>
<ul>
<li>Use Chrome 113+ or Edge 113+</li>
<li>Enable WebGPU flag in browser settings if needed</li>
<li>Check <code>navigator.gpu</code> exists in browser console</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-quick-reference"><a class="header" href="#api-quick-reference">API Quick Reference</a></h1>
<p>Quick lookup for common Nightshade API functions and types.</p>
<h2 id="world"><a class="header" href="#world">World</a></h2>
<h3 id="entity-management"><a class="header" href="#entity-management">Entity Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn entities with components
let entities = world.spawn_entities(flags, count);
let entity = world.spawn_entities(LOCAL_TRANSFORM | MESH_COMPONENT, 1)[0];

// Despawn entity
world.despawn(entity);

// Query entities by components
for entity in world.query(LOCAL_TRANSFORM | MESH_COMPONENT) {
    // Process entity
}
<span class="boring">}</span></code></pre></pre>
<h3 id="component-access"><a class="header" href="#component-access">Component Access</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get component (immutable)
world.get_local_transform(entity) -&gt; Option&lt;&amp;LocalTransform&gt;
world.get_global_transform(entity) -&gt; Option&lt;&amp;GlobalTransform&gt;
world.get_mesh(entity) -&gt; Option&lt;&amp;MeshComponent&gt;
world.get_material(entity) -&gt; Option&lt;&amp;Material&gt;
world.get_camera(entity) -&gt; Option&lt;&amp;Camera&gt;
world.get_rigid_body(entity) -&gt; Option&lt;&amp;RigidBodyComponent&gt;
world.get_collider(entity) -&gt; Option&lt;&amp;ColliderComponent&gt;
world.get_animation_player(entity) -&gt; Option&lt;&amp;AnimationPlayer&gt;
world.get_parent(entity) -&gt; Option&lt;&amp;Parent&gt;
world.get_children(entity) -&gt; &amp;[Entity]
world.get_visible(entity) -&gt; Option&lt;&amp;Visible&gt;

// Get component (mutable)
world.get_local_transform_mut(entity) -&gt; Option&lt;&amp;mut LocalTransform&gt;
world.get_rigid_body_mut(entity) -&gt; Option&lt;&amp;mut RigidBodyComponent&gt;
// ... same pattern for all components

// Set component
world.set_local_transform(entity, LocalTransform { ... })
world.set_material(entity, Material { ... })
// ... same pattern for all components
<span class="boring">}</span></code></pre></pre>
<h3 id="resources-1"><a class="header" href="#resources-1">Resources</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.timing.delta_time        // Frame time in seconds
world.resources.timing.total_time        // Total elapsed time
world.resources.input.keyboard           // Keyboard state
world.resources.input.mouse              // Mouse state
world.resources.input.cursor_locked      // Lock cursor to window
world.resources.input.cursor_visible     // Show/hide cursor
world.resources.active_camera            // Current active camera entity
world.resources.graphics.ambient_intensity
world.resources.physics.gravity
<span class="boring">}</span></code></pre></pre>
<h2 id="component-flags-1"><a class="header" href="#component-flags-1">Component Flags</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LOCAL_TRANSFORM         // Position, rotation, scale
GLOBAL_TRANSFORM        // World-space transform
MESH_COMPONENT          // Renderable mesh
MATERIAL_COMPONENT      // PBR material
CAMERA                  // Camera component
RIGID_BODY_COMPONENT    // Physics rigid body
COLLIDER_COMPONENT      // Physics collider
CHARACTER_CONTROLLER    // Character movement
ANIMATION_PLAYER        // Skeletal animation
PARENT                  // Parent entity reference
CHILDREN                // Child entities
VISIBLE                 // Visibility flag
DIRECTIONAL_LIGHT       // Directional light
POINT_LIGHT             // Point light
SPOT_LIGHT              // Spot light
AUDIO_SOURCE            // Sound emitter
AUDIO_LISTENER          // Sound receiver
PARTICLE_EMITTER        // Particle system
NAV_MESH_AGENT          // Navigation agent
HUD_TEXT                // Screen-space text
TEXT_COMPONENT          // 3D world text
LINES_COMPONENT         // Debug lines
GRASS_REGION            // Grass rendering
GRASS_INTERACTOR        // Grass bending
<span class="boring">}</span></code></pre></pre>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LocalTransform {
    translation: Vec3,
    rotation: nalgebra_glm::Quat,
    scale: Vec3,
}

// Create identity transform
LocalTransform::default()

// Create with values
LocalTransform {
    translation: Vec3::new(x, y, z),
    rotation: nalgebra_glm::quat_angle_axis(angle, &amp;axis),
    scale: Vec3::new(1.0, 1.0, 1.0),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Camera {
    fov: f32,              // Field of view in radians
    near: f32,             // Near clip plane
    far: f32,              // Far clip plane
    active: bool,          // Is this the active camera
    clear_color: [f32; 4], // Background color
    exposure: f32,         // Exposure adjustment
}

// Spawn cameras
spawn_fly_camera(world) -&gt; Entity
spawn_pan_orbit_camera(world, target, distance) -&gt; Entity
spawn_follow_camera(world, target_entity, offset) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="primitives-1"><a class="header" href="#primitives-1">Primitives</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_primitive(world, Primitive::Cube) -&gt; Entity
spawn_primitive(world, Primitive::Sphere) -&gt; Entity
spawn_primitive(world, Primitive::Plane) -&gt; Entity
spawn_primitive(world, Primitive::Cylinder) -&gt; Entity
spawn_primitive(world, Primitive::Capsule) -&gt; Entity
spawn_primitive(world, Primitive::Cone) -&gt; Entity
spawn_primitive(world, Primitive::Torus) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="model-loading"><a class="header" href="#model-loading">Model Loading</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_gltf(world, "path/to/model.glb") -&gt; Vec&lt;Entity&gt;
load_gltf(world, "path/to/model.gltf") -&gt; Vec&lt;Entity&gt;

// With custom transform
let entities = load_gltf(world, "model.glb");
for entity in entities {
    if let Some(transform) = world.get_local_transform_mut(entity) {
        transform.scale = Vec3::new(0.01, 0.01, 0.01);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="materials-1"><a class="header" href="#materials-1">Materials</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Material {
    base_color: [f32; 4],        // RGBA
    roughness: f32,              // 0.0 (smooth) to 1.0 (rough)
    metallic: f32,               // 0.0 (dielectric) to 1.0 (metal)
    emissive: [f32; 3],          // RGB emission
    emissive_strength: f32,      // Emission intensity
    alpha_mode: AlphaMode,       // Opaque, Mask, Blend
    alpha_cutoff: f32,           // For Mask mode
    double_sided: bool,          // Render both faces
    base_color_texture: Option&lt;Handle&gt;,
    normal_texture: Option&lt;Handle&gt;,
    metallic_roughness_texture: Option&lt;Handle&gt;,
    emissive_texture: Option&lt;Handle&gt;,
    occlusion_texture: Option&lt;Handle&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lighting-2"><a class="header" href="#lighting-2">Lighting</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Directional light (sun)
spawn_directional_light(world, direction: Vec3) -&gt; Entity

// Point light
spawn_point_light(world, position: Vec3, color: Vec3, intensity: f32, range: f32) -&gt; Entity

// Spot light
spawn_spot_light(world, position: Vec3, direction: Vec3, color: Vec3, intensity: f32, range: f32, inner_angle: f32, outer_angle: f32) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-2"><a class="header" href="#physics-2">Physics</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rigid bodies
add_rigid_body(world, entity, RigidBodyType::Dynamic, mass: f32)
add_rigid_body(world, entity, RigidBodyType::Static, 0.0)
add_rigid_body(world, entity, RigidBodyType::Kinematic, 0.0)

// Colliders
add_collider(world, entity, ColliderShape::Box { half_extents: Vec3 })
add_collider(world, entity, ColliderShape::Sphere { radius: f32 })
add_collider(world, entity, ColliderShape::Capsule { half_height: f32, radius: f32 })
add_collider(world, entity, ColliderShape::Cylinder { half_height: f32, radius: f32 })
add_collider(world, entity, ColliderShape::Cone { half_height: f32, radius: f32 })
add_collider(world, entity, ColliderShape::ConvexHull { points: Vec&lt;Vec3&gt; })
add_collider(world, entity, ColliderShape::TriMesh { vertices: Vec&lt;Vec3&gt;, indices: Vec&lt;[u32; 3]&gt; })
add_collider(world, entity, ColliderShape::Heightfield { heights: Vec&lt;Vec&lt;f32&gt;&gt;, scale: Vec3 })

// Joints
create_fixed_joint(world, body1, anchor1, body2, anchor2)
create_revolute_joint(world, body1, anchor1, body2, anchor2, axis)
create_prismatic_joint(world, body1, anchor1, body2, anchor2, axis)
create_spherical_joint(world, body1, anchor1, body2, anchor2)
create_rope_joint(world, body1, anchor1, body2, anchor2, max_distance)
create_spring_joint(world, body1, anchor1, body2, anchor2, rest_length, stiffness, damping)

// Raycasting
raycast(world, origin: Vec3, direction: Vec3, max_distance: f32) -&gt; Option&lt;RaycastHit&gt;
raycast_all(world, origin, direction, max_distance) -&gt; Vec&lt;RaycastHit&gt;

// Update
update_physics(world, dt: f32)
update_character_controller(world)
<span class="boring">}</span></code></pre></pre>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get animation player
if let Some(player) = world.get_animation_player_mut(entity) {
    player.play("animation_name");
    player.blend_to("other_animation", blend_time: f32);
    player.stop();
    player.pause();
    player.resume();
    player.set_looping(true);
    player.set_speed(1.0);
    player.seek(time: f32);
    player.current_animation() -&gt; Option&lt;&amp;str&gt;
    player.is_playing() -&gt; bool
}

// Update all animation players
update_animation_players(world, dt: f32)
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-2"><a class="header" href="#audio-2">Audio</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load sounds
load_sound(world, "name", "path/to/sound.wav")
load_sound(world, "music", "path/to/music.ogg")

// Play sounds
play_sound(world, "name")
play_sound_with_volume(world, "name", volume: f32)
play_sound_looped(world, "name")
stop_sound(world, "name")

// Spatial audio
spawn_audio_source(world, position: Vec3, sound_name: &amp;str) -&gt; Entity
<span class="boring">}</span></code></pre></pre>
<h2 id="input-2"><a class="header" href="#input-2">Input</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keyboard
world.resources.input.keyboard.is_key_pressed(KeyCode::KeyW) -&gt; bool
world.resources.input.keyboard.is_key_just_pressed(KeyCode::Space) -&gt; bool
world.resources.input.keyboard.is_key_just_released(KeyCode::ShiftLeft) -&gt; bool

// Mouse
world.resources.input.mouse.position -&gt; Vec2
world.resources.input.mouse.delta -&gt; Vec2
world.resources.input.mouse.scroll_delta -&gt; Vec2
world.resources.input.mouse.state.contains(MouseState::LEFT_CLICKED) -&gt; bool
world.resources.input.mouse.state.contains(MouseState::RIGHT_CLICKED) -&gt; bool
world.resources.input.mouse.state.contains(MouseState::LEFT_JUST_PRESSED) -&gt; bool

// Cursor
world.resources.input.cursor_locked = true;
world.resources.input.cursor_visible = false;

// Gamepad (with feature)
query_active_gamepad(world) -&gt; Option&lt;&amp;Gamepad&gt;
gamepad.is_pressed(gilrs::Button::South) -&gt; bool
gamepad.axis_value(gilrs::Axis::LeftStickX) -&gt; f32
<span class="boring">}</span></code></pre></pre>
<h2 id="hud-text-1"><a class="header" href="#hud-text-1">HUD Text</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_hud_text(world, text: &amp;str, anchor: HudAnchor, offset: Vec2) -&gt; Entity
spawn_hud_text_with_properties(world, text, anchor, offset, properties: TextProperties) -&gt; Entity

TextProperties {
    font_size: f32,
    color: [f32; 4],
    text_alignment: TextAlignment,      // Left, Center, Right
    vertical_alignment: VerticalAlignment,
    line_height: f32,
    letter_spacing: f32,
    outline_width: f32,
    outline_color: [f32; 4],
}

HudAnchor::TopLeft | TopCenter | TopRight
HudAnchor::CenterLeft | Center | CenterRight
HudAnchor::BottomLeft | BottomCenter | BottomRight
<span class="boring">}</span></code></pre></pre>
<h2 id="particles"><a class="header" href="#particles">Particles</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParticleEmitter {
    emitter_type: EmitterType,     // Fire, Smoke, Sparks, Snow, Dust
    shape: EmitterShape,           // Point, Sphere, Box, Cone
    position: Vec3,
    direction: Vec3,
    spawn_rate: f32,
    burst_count: u32,
    particle_lifetime_min: f32,
    particle_lifetime_max: f32,
    initial_velocity_min: f32,
    initial_velocity_max: f32,
    velocity_spread: f32,
    gravity: Vec3,
    drag: f32,
    size_start: f32,
    size_end: f32,
    color_gradient: ColorGradient,
    emissive_strength: f32,
    turbulence_strength: f32,
    turbulence_frequency: f32,
    enabled: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>generate_navmesh_recast(world, vertices: &amp;[Vec3], indices: &amp;[[u32; 3]], config: &amp;RecastNavMeshConfig)
set_agent_destination(world, agent: Entity, target: Vec3)
query_path(world, start: Vec3, end: Vec3) -&gt; Option&lt;Vec&lt;Vec3&gt;&gt;
is_on_navmesh(world, point: Vec3) -&gt; bool
add_offmesh_connection(world, start: Vec3, end: Vec3, bidirectional: bool)
update_navmesh_agents(world)
<span class="boring">}</span></code></pre></pre>
<h2 id="math-nalgebra_glm"><a class="header" href="#math-nalgebra_glm">Math (nalgebra_glm)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vectors
Vec2::new(x, y)
Vec3::new(x, y, z)
Vec4::new(x, y, z, w)
Vec3::zeros()
Vec3::x()  // Unit X
Vec3::y()  // Unit Y
Vec3::z()  // Unit Z

// Vector operations
vec.normalize()
vec.magnitude()
vec.dot(&amp;other)
vec.cross(&amp;other)

// Quaternions
nalgebra_glm::quat_identity()
nalgebra_glm::quat_angle_axis(angle: f32, axis: &amp;Vec3) -&gt; Quat
nalgebra_glm::quat_slerp(from: &amp;Quat, to: &amp;Quat, t: f32) -&gt; Quat

// Interpolation
nalgebra_glm::lerp(from: &amp;Vec3, to: &amp;Vec3, t: f32) -&gt; Vec3
<span class="boring">}</span></code></pre></pre>
<h2 id="state-trait"><a class="header" href="#state-trait">State Trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait State {
    fn initialize(&amp;mut self, world: &amp;mut World) {}
    fn run_systems(&amp;mut self, world: &amp;mut World) {}
    fn on_keyboard_input(&amp;mut self, world: &amp;mut World, key: KeyCode, state: KeyState) {}
    fn on_mouse_input(&amp;mut self, world: &amp;mut World, button: MouseButton, state: ElementState) {}
    fn on_mouse_motion(&amp;mut self, world: &amp;mut World, delta: Vec2) {}
    fn on_mouse_scroll(&amp;mut self, world: &amp;mut World, delta: Vec2) {}
    fn on_window_resize(&amp;mut self, world: &amp;mut World, width: u32, height: u32) {}
    fn on_gamepad_event(&amp;mut self, world: &amp;mut World, event: gilrs::Event) {}
    fn configure_render_graph(&amp;mut self, graph: &amp;mut RenderGraph&lt;World&gt;, device: &amp;wgpu::Device, surface_format: wgpu::TextureFormat, resources: RenderResources) {}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-analyzer-fft-feature"><a class="header" href="#audio-analyzer-fft-feature">Audio Analyzer (fft feature)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create analyzer
let mut analyzer = AudioAnalyzer::new();
analyzer.load_samples(samples, sample_rate);

// Analyze at playback position
analyzer.analyze_at_time(time_seconds);

// Frequency bands (0.0-1.0)
analyzer.sub_bass           // 20-60 Hz
analyzer.bass               // 60-250 Hz
analyzer.low_mids           // 250-500 Hz
analyzer.mids               // 500-2000 Hz
analyzer.high_mids          // 2000-4000 Hz
analyzer.highs              // 4000-12000 Hz

// Smoothed versions
analyzer.smoothed_bass
analyzer.smoothed_mids
// ... etc

// Beat detection (decay from 1.0)
analyzer.onset_detected     // bool
analyzer.kick_decay
analyzer.snare_decay
analyzer.hat_decay

// Tempo
analyzer.estimated_bpm      // 60-200
analyzer.beat_phase         // 0.0-1.0
analyzer.beat_confidence

// Structure detection
analyzer.is_building
analyzer.is_dropping
analyzer.is_breakdown
analyzer.build_intensity
analyzer.drop_intensity

// Spectral features
analyzer.spectral_centroid  // Brightness
analyzer.spectral_flatness  // Noise vs tonal
analyzer.spectral_flux      // Rate of change
analyzer.intensity          // Energy relative to average
<span class="boring">}</span></code></pre></pre>
<h2 id="effects-pass-1"><a class="header" href="#effects-pass-1">Effects Pass</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::render::wgpu::passes::postprocess::effects::*;

// Create state
let effects_state = create_effects_state();

// Modify effects
if let Ok(mut state) = effects_state.write() {
    state.uniforms.chromatic_aberration = 0.02;
    state.uniforms.vignette = 0.3;
    state.uniforms.glitch_intensity = 0.5;
    state.uniforms.wave_distortion = 0.2;
    state.uniforms.crt_scanlines = 0.3;
    state.uniforms.film_grain = 0.1;
    state.uniforms.hue_rotation = 0.5;
    state.uniforms.saturation = 1.2;
    state.uniforms.color_grade_mode = ColorGradeMode::Cyberpunk as f32;
    state.uniforms.raymarch_mode = RaymarchMode::Tunnel as f32;
    state.uniforms.raymarch_blend = 0.5;
    state.enabled = true;
}

// Color grade modes: None, Cyberpunk, Sunset, Grayscale, Sepia, Matrix, HotMetal
// Raymarch modes: Off, Tunnel, Fractal, Mandelbulb, PlasmaVortex, Geometric
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-lines"><a class="header" href="#debug-lines">Debug Lines</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn lines entity
let lines = world.spawn_entities(LOCAL_TRANSFORM | LINES_COMPONENT, 1)[0];

// Set line data
world.set_lines(lines, LinesComponent {
    lines: vec![
        Line { start: Vec3::zeros(), end: Vec3::new(1.0, 0.0, 0.0), color: [1.0, 0.0, 0.0, 1.0] },
        Line { start: Vec3::zeros(), end: Vec3::new(0.0, 1.0, 0.0), color: [0.0, 1.0, 0.0, 1.0] },
        Line { start: Vec3::zeros(), end: Vec3::new(0.0, 0.0, 1.0), color: [0.0, 0.0, 1.0, 1.0] },
    ],
});

// Gizmos
draw_gizmo_box(world, center, half_extents, color);
draw_gizmo_sphere(world, center, radius, color);
draw_gizmo_ray(world, origin, direction, length, color);
<span class="boring">}</span></code></pre></pre>
<h2 id="running-1"><a class="header" href="#running-1">Running</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    nightshade::run(MyGame::default());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<p>Common recipes and patterns for Nightshade game development.</p>
<h2 id="player-movement"><a class="header" href="#player-movement">Player Movement</a></h2>
<h3 id="basic-wasd-movement"><a class="header" href="#basic-wasd-movement">Basic WASD Movement</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_movement(world: &amp;mut World, player: Entity, speed: f32) {
    let dt = world.resources.window.timing.delta_time;
    let keyboard = &amp;world.resources.input.keyboard;

    let mut direction = Vec3::zeros();

    if keyboard.is_key_pressed(KeyCode::KeyW) { direction.z -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { direction.z += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { direction.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { direction.x += 1.0; }

    if direction.magnitude() &gt; 0.0 {
        direction = direction.normalize();

        if let Some(transform) = world.get_local_transform_mut(player) {
            transform.translation += direction * speed * dt;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="camera-relative-movement-1"><a class="header" href="#camera-relative-movement-1">Camera-Relative Movement</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn camera_relative_movement(
    world: &amp;mut World,
    player: Entity,
    camera: Entity,
    speed: f32,
) {
    let dt = world.resources.window.timing.delta_time;
    let keyboard = &amp;world.resources.input.keyboard;

    let mut input = Vec2::zeros();
    if keyboard.is_key_pressed(KeyCode::KeyW) { input.y -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyS) { input.y += 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyA) { input.x -= 1.0; }
    if keyboard.is_key_pressed(KeyCode::KeyD) { input.x += 1.0; }

    if input.magnitude() &lt; 0.01 {
        return;
    }
    input = input.normalize();

    let Some(camera_transform) = world.get_global_transform(camera) else { return };

    let forward = camera_transform.forward();
    let forward_flat = Vec3::new(forward.x, 0.0, forward.z).normalize();
    let right_flat = Vec3::new(forward.z, 0.0, -forward.x).normalize();

    let world_direction = forward_flat * -input.y + right_flat * input.x;

    if let Some(transform) = world.get_local_transform_mut(player) {
        transform.translation += world_direction * speed * dt;

        let target_yaw = world_direction.x.atan2(world_direction.z);
        let target_rotation = nalgebra_glm::quat_angle_axis(target_yaw, &amp;Vec3::y());
        transform.rotation = nalgebra_glm::quat_slerp(
            &amp;transform.rotation,
            &amp;target_rotation,
            dt * 10.0,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="jumping"><a class="header" href="#jumping">Jumping</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PlayerState {
    velocity_y: f32,
    grounded: bool,
}

fn handle_jumping(
    world: &amp;mut World,
    player: Entity,
    state: &amp;mut PlayerState,
    jump_force: f32,
    gravity: f32,
) {
    let dt = world.resources.window.timing.delta_time;
    let keyboard = &amp;world.resources.input.keyboard;

    if state.grounded &amp;&amp; keyboard.is_key_just_pressed(KeyCode::Space) {
        state.velocity_y = jump_force;
        state.grounded = false;
    }

    if !state.grounded {
        state.velocity_y -= gravity * dt;
    }

    if let Some(transform) = world.get_local_transform_mut(player) {
        transform.translation.y += state.velocity_y * dt;

        if transform.translation.y &lt;= 0.0 {
            transform.translation.y = 0.0;
            state.velocity_y = 0.0;
            state.grounded = true;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="camera-systems-1"><a class="header" href="#camera-systems-1">Camera Systems</a></h2>
<h3 id="smooth-follow-camera"><a class="header" href="#smooth-follow-camera">Smooth Follow Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FollowCamera {
    offset: Vec3,
    smoothness: f32,
}

fn follow_camera_system(
    world: &amp;mut World,
    target: Entity,
    camera: Entity,
    config: &amp;FollowCamera,
) {
    let dt = world.resources.window.timing.delta_time;

    let Some(target_transform) = world.get_global_transform(target) else { return };
    let target_pos = target_transform.translation() + config.offset;

    if let Some(cam_transform) = world.get_local_transform_mut(camera) {
        cam_transform.translation = nalgebra_glm::lerp(
            &amp;cam_transform.translation,
            &amp;target_pos,
            dt * config.smoothness,
        );

        let look_at = target_transform.translation();
        let direction = (look_at - cam_transform.translation).normalize();
        let pitch = (-direction.y).asin();
        let yaw = direction.x.atan2(direction.z);

        cam_transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
            * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="third-person-orbit-camera"><a class="header" href="#third-person-orbit-camera">Third-Person Orbit Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OrbitCamera {
    target: Entity,
    distance: f32,
    yaw: f32,
    pitch: f32,
    sensitivity: f32,
}

fn orbit_camera_system(world: &amp;mut World, camera: Entity, orbit: &amp;mut OrbitCamera) {
    let mouse_delta = world.resources.input.mouse.delta;
    let scroll = world.resources.input.mouse.scroll_delta;

    orbit.yaw -= mouse_delta.x * orbit.sensitivity;
    orbit.pitch -= mouse_delta.y * orbit.sensitivity;
    orbit.pitch = orbit.pitch.clamp(-1.4, 1.4);
    orbit.distance = (orbit.distance - scroll.y * 0.5).clamp(2.0, 20.0);

    let Some(target_transform) = world.get_global_transform(orbit.target) else { return };
    let target_pos = target_transform.translation() + Vec3::new(0.0, 1.5, 0.0);

    let offset = Vec3::new(
        orbit.yaw.sin() * orbit.pitch.cos(),
        orbit.pitch.sin(),
        orbit.yaw.cos() * orbit.pitch.cos(),
    ) * orbit.distance;

    let camera_pos = target_pos + offset;

    if let Some(transform) = world.get_local_transform_mut(camera) {
        transform.translation = camera_pos;

        let direction = (target_pos - camera_pos).normalize();
        let pitch = (-direction.y).asin();
        let yaw = direction.x.atan2(direction.z);

        transform.rotation = nalgebra_glm::quat_angle_axis(yaw, &amp;Vec3::y())
            * nalgebra_glm::quat_angle_axis(pitch, &amp;Vec3::x());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="first-person-camera-1"><a class="header" href="#first-person-camera-1">First-Person Camera</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FpsCamera {
    yaw: f32,
    pitch: f32,
    sensitivity: f32,
}

fn fps_camera_system(world: &amp;mut World, camera: Entity, fps: &amp;mut FpsCamera) {
    let mouse_delta = world.resources.input.mouse.delta;

    fps.yaw -= mouse_delta.x * fps.sensitivity;
    fps.pitch -= mouse_delta.y * fps.sensitivity;
    fps.pitch = fps.pitch.clamp(-1.5, 1.5);

    if let Some(transform) = world.get_local_transform_mut(camera) {
        transform.rotation = nalgebra_glm::quat_angle_axis(fps.yaw, &amp;Vec3::y())
            * nalgebra_glm::quat_angle_axis(fps.pitch, &amp;Vec3::x());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combat-systems"><a class="header" href="#combat-systems">Combat Systems</a></h2>
<h3 id="health-system"><a class="header" href="#health-system">Health System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Health {
    current: f32,
    maximum: f32,
    invulnerable_timer: f32,
}

impl Health {
    fn take_damage(&amp;mut self, amount: f32, dt: f32) -&gt; bool {
        if self.invulnerable_timer &gt; 0.0 {
            return false;
        }

        self.current = (self.current - amount).max(0.0);
        self.invulnerable_timer = 0.5;

        self.current &lt;= 0.0
    }

    fn heal(&amp;mut self, amount: f32) {
        self.current = (self.current + amount).min(self.maximum);
    }

    fn update(&amp;mut self, dt: f32) {
        if self.invulnerable_timer &gt; 0.0 {
            self.invulnerable_timer -= dt;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="melee-attack"><a class="header" href="#melee-attack">Melee Attack</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn melee_attack(
    world: &amp;mut World,
    attacker: Entity,
    damage: f32,
    range: f32,
    angle: f32,
) -&gt; Vec&lt;Entity&gt; {
    let Some(attacker_transform) = world.get_global_transform(attacker) else {
        return vec![];
    };

    let origin = attacker_transform.translation();
    let forward = attacker_transform.forward();

    let mut hit_entities = vec![];

    for entity in world.query(GLOBAL_TRANSFORM) {
        if entity == attacker {
            continue;
        }

        let Some(target_transform) = world.get_global_transform(entity) else {
            continue;
        };

        let to_target = target_transform.translation() - origin;
        let distance = to_target.magnitude();

        if distance &gt; range {
            continue;
        }

        let dot = forward.dot(&amp;to_target.normalize());
        if dot &lt; angle.cos() {
            continue;
        }

        hit_entities.push(entity);
    }

    hit_entities
}
<span class="boring">}</span></code></pre></pre>
<h3 id="projectile-system"><a class="header" href="#projectile-system">Projectile System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Projectile {
    velocity: Vec3,
    damage: f32,
    lifetime: f32,
    owner: Entity,
}

fn spawn_projectile(
    world: &amp;mut World,
    position: Vec3,
    direction: Vec3,
    speed: f32,
    damage: f32,
    owner: Entity,
) -&gt; Entity {
    let entity = world.spawn_entities(
        LOCAL_TRANSFORM | GLOBAL_TRANSFORM | MESH_COMPONENT,
        1
    )[0];

    world.set_local_transform(entity, LocalTransform {
        translation: position,
        scale: Vec3::new(0.1, 0.1, 0.5),
        ..Default::default()
    });

    entity
}

fn update_projectiles(
    world: &amp;mut World,
    projectiles: &amp;mut Vec&lt;(Entity, Projectile)&gt;,
) {
    let dt = world.resources.window.timing.delta_time;

    projectiles.retain_mut(|(entity, projectile)| {
        projectile.lifetime -= dt;

        if projectile.lifetime &lt;= 0.0 {
            world.despawn(*entity);
            return false;
        }

        if let Some(transform) = world.get_local_transform_mut(*entity) {
            transform.translation += projectile.velocity * dt;
        }

        true
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="object-pooling"><a class="header" href="#object-pooling">Object Pooling</a></h2>
<h3 id="entity-pool"><a class="header" href="#entity-pool">Entity Pool</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EntityPool {
    available: Vec&lt;Entity&gt;,
    active: Vec&lt;Entity&gt;,
    prefab_spawn_fn: fn(&amp;mut World) -&gt; Entity,
}

impl EntityPool {
    fn new(world: &amp;mut World, initial_size: usize, spawn_fn: fn(&amp;mut World) -&gt; Entity) -&gt; Self {
        let mut available = Vec::with_capacity(initial_size);

        for _ in 0..initial_size {
            let entity = spawn_fn(world);
            set_entity_active(world, entity, false);
            available.push(entity);
        }

        Self {
            available,
            active: Vec::new(),
            prefab_spawn_fn: spawn_fn,
        }
    }

    fn acquire(&amp;mut self, world: &amp;mut World) -&gt; Entity {
        let entity = self.available.pop().unwrap_or_else(|| {
            (self.prefab_spawn_fn)(world)
        });

        set_entity_active(world, entity, true);
        self.active.push(entity);
        entity
    }

    fn release(&amp;mut self, world: &amp;mut World, entity: Entity) {
        if let Some(index) = self.active.iter().position(|&amp;e| e == entity) {
            self.active.swap_remove(index);
            set_entity_active(world, entity, false);
            self.available.push(entity);
        }
    }
}

fn set_entity_active(world: &amp;mut World, entity: Entity, active: bool) {
    world.set_visible(entity, Visible(active));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-machines"><a class="header" href="#state-machines">State Machines</a></h2>
<h3 id="simple-state-machine"><a class="header" href="#simple-state-machine">Simple State Machine</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq)]
enum PlayerState {
    Idle,
    Walking,
    Running,
    Jumping,
    Falling,
    Attacking,
}

struct StateMachine {
    current: PlayerState,
    state_timer: f32,
}

impl StateMachine {
    fn transition(&amp;mut self, new_state: PlayerState) {
        if self.current != new_state {
            self.current = new_state;
            self.state_timer = 0.0;
        }
    }

    fn update(&amp;mut self, dt: f32) {
        self.state_timer += dt;
    }

    fn can_interrupt(&amp;self) -&gt; bool {
        match self.current {
            PlayerState::Attacking =&gt; self.state_timer &gt; 0.5,
            _ =&gt; true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ui-patterns"><a class="header" href="#ui-patterns">UI Patterns</a></h2>
<h3 id="health-bar"><a class="header" href="#health-bar">Health Bar</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_health_bar(world: &amp;mut World, health_text: Entity, current: f32, max: f32) {
    let percentage = (current / max * 100.0) as u32;
    let bar_length = 20;
    let filled = (percentage as usize * bar_length / 100).min(bar_length);

    let bar = format!(
        "[{}{}] {}/{}",
        "█".repeat(filled),
        "░".repeat(bar_length - filled),
        current as u32,
        max as u32,
    );

    if let Some(text) = world.get_hud_text_mut(health_text) {
        text.text = bar;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fps-counter-1"><a class="header" href="#fps-counter-1">FPS Counter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FpsCounter {
    samples: Vec&lt;f32&gt;,
    text_entity: Entity,
}

impl FpsCounter {
    fn update(&amp;mut self, world: &amp;mut World) {
        let fps = world.resources.window.timing.frames_per_second;
        self.samples.push(fps);

        if self.samples.len() &gt; 60 {
            self.samples.remove(0);
        }

        let avg: f32 = self.samples.iter().sum::&lt;f32&gt;() / self.samples.len() as f32;

        if let Some(text) = world.get_hud_text_mut(self.text_entity) {
            text.text = format!("FPS: {:.0}", avg);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spawning-patterns"><a class="header" href="#spawning-patterns">Spawning Patterns</a></h2>
<h3 id="random-position-in-area"><a class="header" href="#random-position-in-area">Random Position in Area</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn random_position_in_box(center: Vec3, half_extents: Vec3) -&gt; Vec3 {
    Vec3::new(
        center.x + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.x,
        center.y + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.y,
        center.z + (rand::random::&lt;f32&gt;() - 0.5) * 2.0 * half_extents.z,
    )
}

fn random_position_on_circle(center: Vec3, radius: f32) -&gt; Vec3 {
    let angle = rand::random::&lt;f32&gt;() * std::f32::consts::TAU;
    Vec3::new(
        center.x + angle.cos() * radius,
        center.y,
        center.z + angle.sin() * radius,
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wave-spawner"><a class="header" href="#wave-spawner">Wave Spawner</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WaveSpawner {
    wave: u32,
    enemies_remaining: u32,
    spawn_timer: f32,
    spawn_interval: f32,
}

impl WaveSpawner {
    fn update(&amp;mut self, world: &amp;mut World, dt: f32) {
        if self.enemies_remaining == 0 {
            self.start_next_wave();
            return;
        }

        self.spawn_timer -= dt;

        if self.spawn_timer &lt;= 0.0 {
            self.spawn_enemy(world);
            self.spawn_timer = self.spawn_interval;
        }
    }

    fn start_next_wave(&amp;mut self) {
        self.wave += 1;
        self.enemies_remaining = 5 + self.wave * 2;
        self.spawn_interval = (2.0 - self.wave as f32 * 0.1).max(0.3);
    }

    fn spawn_enemy(&amp;mut self, world: &amp;mut World) {
        let position = random_position_on_circle(Vec3::zeros(), 20.0);
        spawn_primitive(world, Primitive::Cube);
        self.enemies_remaining -= 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-patterns"><a class="header" href="#audio-patterns">Audio Patterns</a></h2>
<h3 id="footstep-system-1"><a class="header" href="#footstep-system-1">Footstep System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FootstepSystem {
    step_timer: f32,
    step_interval: f32,
    sounds: Vec&lt;String&gt;,
    last_index: usize,
}

impl FootstepSystem {
    fn update(&amp;mut self, world: &amp;mut World, is_moving: bool, is_running: bool, dt: f32) {
        if !is_moving {
            self.step_timer = 0.0;
            return;
        }

        let interval = if is_running {
            self.step_interval * 0.6
        } else {
            self.step_interval
        };

        self.step_timer += dt;

        if self.step_timer &gt;= interval {
            self.step_timer = 0.0;
            self.play_footstep(world);
        }
    }

    fn play_footstep(&amp;mut self, world: &amp;mut World) {
        let mut index = rand::random::&lt;usize&gt;() % self.sounds.len();
        if index == self.last_index &amp;&amp; self.sounds.len() &gt; 1 {
            index = (index + 1) % self.sounds.len();
        }
        self.last_index = index;

        play_sound(world, &amp;self.sounds[index]);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="savingloading"><a class="header" href="#savingloading">Saving/Loading</a></h2>
<h3 id="simple-save-data"><a class="header" href="#simple-save-data">Simple Save Data</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct SaveData {
    player_position: [f32; 3],
    player_health: f32,
    score: u32,
    level: u32,
}

fn save_game(data: &amp;SaveData, path: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    let json = serde_json::to_string_pretty(data)?;
    std::fs::write(path, json)?;
    Ok(())
}

fn load_game(path: &amp;str) -&gt; std::io::Result&lt;SaveData&gt; {
    let json = std::fs::read_to_string(path)?;
    let data: SaveData = serde_json::from_str(&amp;json)?;
    Ok(data)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debug-visualization-2"><a class="header" href="#debug-visualization-2">Debug Visualization</a></h2>
<h3 id="draw-collision-shapes"><a class="header" href="#draw-collision-shapes">Draw Collision Shapes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_draw_colliders(world: &amp;mut World, lines_entity: Entity) {
    let mut lines = vec![];

    for entity in world.query(COLLIDER_COMPONENT | GLOBAL_TRANSFORM) {
        let Some(collider) = world.get_collider(entity) else { continue };
        let Some(transform) = world.get_global_transform(entity) else { continue };

        let pos = transform.translation();
        let color = [0.0, 1.0, 0.0, 1.0];

        match &amp;collider.shape {
            ColliderShape::Box { half_extents } =&gt; {
                draw_wire_box(&amp;mut lines, pos, *half_extents, color);
            }
            ColliderShape::Sphere { radius } =&gt; {
                draw_wire_sphere(&amp;mut lines, pos, *radius, color);
            }
            _ =&gt; {}
        }
    }

    world.set_lines(lines_entity, LinesComponent { lines });
}

fn draw_wire_box(lines: &amp;mut Vec&lt;Line&gt;, center: Vec3, half: Vec3, color: [f32; 4]) {
    let corners = [
        center + Vec3::new(-half.x, -half.y, -half.z),
        center + Vec3::new( half.x, -half.y, -half.z),
        center + Vec3::new( half.x, -half.y,  half.z),
        center + Vec3::new(-half.x, -half.y,  half.z),
        center + Vec3::new(-half.x,  half.y, -half.z),
        center + Vec3::new( half.x,  half.y, -half.z),
        center + Vec3::new( half.x,  half.y,  half.z),
        center + Vec3::new(-half.x,  half.y,  half.z),
    ];

    let edges = [
        (0,1), (1,2), (2,3), (3,0),
        (4,5), (5,6), (6,7), (7,4),
        (0,4), (1,5), (2,6), (3,7),
    ];

    for (a, b) in edges {
        lines.push(Line { start: corners[a], end: corners[b], color });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="timer-utilities"><a class="header" href="#timer-utilities">Timer Utilities</a></h2>
<h3 id="cooldown-timer"><a class="header" href="#cooldown-timer">Cooldown Timer</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cooldown {
    duration: f32,
    remaining: f32,
}

impl Cooldown {
    fn new(duration: f32) -&gt; Self {
        Self { duration, remaining: 0.0 }
    }

    fn update(&amp;mut self, dt: f32) {
        self.remaining = (self.remaining - dt).max(0.0);
    }

    fn ready(&amp;self) -&gt; bool {
        self.remaining &lt;= 0.0
    }

    fn trigger(&amp;mut self) {
        self.remaining = self.duration;
    }

    fn progress(&amp;self) -&gt; f32 {
        1.0 - (self.remaining / self.duration)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="repeating-timer"><a class="header" href="#repeating-timer">Repeating Timer</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RepeatingTimer {
    interval: f32,
    elapsed: f32,
}

impl RepeatingTimer {
    fn new(interval: f32) -&gt; Self {
        Self { interval, elapsed: 0.0 }
    }

    fn tick(&amp;mut self, dt: f32) -&gt; bool {
        self.elapsed += dt;

        if self.elapsed &gt;= self.interval {
            self.elapsed -= self.interval;
            true
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Common terms used in game development and Nightshade.</p>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<p><strong>Alpha Blending</strong>
Technique for rendering transparent objects by mixing colors based on alpha (transparency) values.</p>
<p><strong>Alpha Cutoff</strong>
Threshold for alpha testing. Pixels with alpha below this value are discarded entirely.</p>
<p><strong>Ambient Light</strong>
Constant, directionless light that illuminates all surfaces equally. Simulates indirect illumination.</p>
<p><strong>Ambient Occlusion (AO)</strong>
Technique that darkens creases and corners where ambient light would be blocked. See SSAO.</p>
<p><strong>Animation Blending</strong>
Smoothly transitioning between two animations by interpolating their transforms.</p>
<p><strong>Animation Clip</strong>
A single named animation (e.g., "walk", "run", "idle") containing keyframed transforms.</p>
<p><strong>Aspect Ratio</strong>
Width divided by height of the viewport (e.g., 16:9 = 1.777).</p>
<h2 id="b"><a class="header" href="#b">B</a></h2>
<p><strong>Billboard</strong>
A sprite that always faces the camera, commonly used for particles and distant objects.</p>
<p><strong>Bind Pose</strong>
The default pose of a skeletal mesh before any animation is applied.</p>
<p><strong>Bloom</strong>
Post-processing effect that creates a glow around bright areas.</p>
<p><strong>Bone</strong>
A joint in a skeletal hierarchy used for animation. Also called a joint.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<p><strong>Cascaded Shadow Maps (CSM)</strong>
Technique using multiple shadow maps at different resolutions for different distances.</p>
<p><strong>CCD (Continuous Collision Detection)</strong>
Physics technique to prevent fast-moving objects from passing through thin surfaces.</p>
<p><strong>Character Controller</strong>
A kinematic physics body designed for player movement with special handling for steps and slopes.</p>
<p><strong>Collider</strong>
A simplified shape used for physics collision detection (box, sphere, capsule, etc.).</p>
<p><strong>Component</strong>
Data attached to an entity in an ECS. Contains no logic, only state.</p>
<p><strong>Culling</strong>
Excluding objects from rendering if they're outside the view or occluded.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<p><strong>Delta Time (dt)</strong>
Time elapsed since the previous frame. Used to make movement frame-rate independent.</p>
<p><strong>Depth Buffer (Z-Buffer)</strong>
Texture storing the distance of each pixel from the camera. Used for depth testing.</p>
<p><strong>Diffuse</strong>
The base color of a surface, independent of view angle.</p>
<p><strong>Dynamic Body</strong>
A physics body affected by forces, gravity, and collisions.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<p><strong>ECS (Entity Component System)</strong>
Architecture where entities are IDs, components are data, and systems are logic.</p>
<p><strong>Emission/Emissive</strong>
Light that a surface produces itself, independent of external lighting.</p>
<p><strong>Entity</strong>
A unique identifier that groups related components together. Has no data itself.</p>
<p><strong>Euler Angles</strong>
Representation of rotation as three angles (pitch, yaw, roll). Can suffer from gimbal lock.</p>
<p><strong>Exposure</strong>
Brightness adjustment simulating camera exposure settings.</p>
<h2 id="f"><a class="header" href="#f">F</a></h2>
<p><strong>Far Plane</strong>
Maximum distance from the camera at which objects are rendered.</p>
<p><strong>FFT (Fast Fourier Transform)</strong>
Algorithm to convert audio from time domain to frequency domain.</p>
<p><strong>Field of View (FOV)</strong>
Angle of the visible area. Typically 60-90 degrees for games.</p>
<p><strong>Forward Rendering</strong>
Rendering each object completely in one pass. Simple but expensive with many lights.</p>
<p><strong>Frame</strong>
One complete update and render cycle.</p>
<p><strong>Frustum</strong>
The 3D region visible to the camera, shaped like a truncated pyramid.</p>
<h2 id="g"><a class="header" href="#g">G</a></h2>
<p><strong>G-Buffer</strong>
Textures storing geometry information (normals, depth, albedo) for deferred rendering.</p>
<p><strong>Gimbal Lock</strong>
Loss of one degree of freedom when two rotation axes align. Quaternions avoid this.</p>
<p><strong>glTF/GLB</strong>
Standard 3D model format. glTF is JSON + binary, GLB is single binary file.</p>
<p><strong>Global Transform</strong>
World-space transformation after parent transforms are applied.</p>
<h2 id="h"><a class="header" href="#h">H</a></h2>
<p><strong>HDR (High Dynamic Range)</strong>
Color values exceeding 0-1 range, allowing for realistic lighting before tonemapping.</p>
<p><strong>Heightfield</strong>
A 2D grid of height values representing terrain or other surfaces.</p>
<p><strong>Hierarchy</strong>
Parent-child relationships between entities where child transforms are relative to parents.</p>
<h2 id="i"><a class="header" href="#i">I</a></h2>
<p><strong>Index Buffer</strong>
List of vertex indices defining triangles. Allows vertex reuse.</p>
<p><strong>Instancing</strong>
Rendering many copies of the same mesh efficiently in a single draw call.</p>
<p><strong>Interpolation</strong>
Smoothly blending between two values. Linear interpolation (lerp) is most common.</p>
<h2 id="j"><a class="header" href="#j">J</a></h2>
<p><strong>Joint</strong>
Connection point between physics bodies with constraints on movement.</p>
<h2 id="k"><a class="header" href="#k">K</a></h2>
<p><strong>Keyframe</strong>
A specific value at a specific time in an animation. Values are interpolated between keyframes.</p>
<p><strong>Kinematic Body</strong>
A physics body moved by code that affects dynamic bodies but isn't affected by physics.</p>
<h2 id="l"><a class="header" href="#l">L</a></h2>
<p><strong>LDR (Low Dynamic Range)</strong>
Standard 0-1 color range suitable for display.</p>
<p><strong>Lerp (Linear Interpolation)</strong>
Blending between two values: <code>result = a + (b - a) * t</code> where t is 0-1.</p>
<p><strong>LOD (Level of Detail)</strong>
Using simpler meshes for distant objects to improve performance.</p>
<p><strong>Local Transform</strong>
Position, rotation, scale relative to the parent entity (or world if no parent).</p>
<h2 id="m"><a class="header" href="#m">M</a></h2>
<p><strong>Material</strong>
Defines how a surface looks: color, roughness, metallic, textures, etc.</p>
<p><strong>Mesh</strong>
Geometry defined by vertices and indices forming triangles.</p>
<p><strong>Metallic</strong>
PBR property indicating whether a surface is metal (1.0) or dielectric (0.0).</p>
<p><strong>Mipmaps</strong>
Pre-calculated, progressively smaller versions of a texture for efficient sampling at distance.</p>
<p><strong>Morph Targets</strong>
Vertex positions for blending between shapes (facial expressions, etc.). Also called blend shapes.</p>
<h2 id="n"><a class="header" href="#n">N</a></h2>
<p><strong>NavMesh (Navigation Mesh)</strong>
Simplified geometry representing walkable areas for AI pathfinding.</p>
<p><strong>Near Plane</strong>
Minimum distance from camera at which objects are rendered. Objects closer are clipped.</p>
<p><strong>Normal Map</strong>
Texture encoding surface direction variations to simulate detail without geometry.</p>
<h2 id="o"><a class="header" href="#o">O</a></h2>
<p><strong>Occlusion</strong>
When one object blocks another from view or light.</p>
<p><strong>Orthographic Projection</strong>
Parallel projection with no perspective. Objects don't get smaller with distance.</p>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<p><strong>PBR (Physically Based Rendering)</strong>
Material model based on real-world physics for consistent, realistic lighting.</p>
<p><strong>Perspective Projection</strong>
Projection where distant objects appear smaller, simulating human vision.</p>
<p><strong>Pitch</strong>
Rotation around the X (left-right) axis. Looking up/down.</p>
<p><strong>Point Light</strong>
Light emitting equally in all directions from a point.</p>
<p><strong>Prefab</strong>
Pre-configured entity template that can be instantiated multiple times.</p>
<h2 id="q"><a class="header" href="#q">Q</a></h2>
<p><strong>Quaternion</strong>
4D number representing rotation without gimbal lock. Used for smooth interpolation.</p>
<p><strong>Query</strong>
Finding entities that have specific components.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<p><strong>Raycast</strong>
Tracing a line through space to find intersections with geometry.</p>
<p><strong>Render Graph</strong>
Declarative system for defining rendering passes and their dependencies.</p>
<p><strong>Render Pass</strong>
A single stage of rendering (shadow pass, color pass, post-processing pass).</p>
<p><strong>Rigid Body</strong>
Physics object that doesn't deform. Can be dynamic, kinematic, or static.</p>
<p><strong>Roll</strong>
Rotation around the Z (forward) axis. Tilting sideways.</p>
<p><strong>Roughness</strong>
PBR property controlling how scattered light reflections are. 0=mirror, 1=diffuse.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><strong>Skinning</strong>
Deforming mesh vertices based on bone positions. Used for character animation.</p>
<p><strong>Skybox</strong>
Cubemap texture surrounding the scene representing distant environment.</p>
<p><strong>Slerp (Spherical Linear Interpolation)</strong>
Interpolation for quaternions that maintains constant angular velocity.</p>
<p><strong>Specular</strong>
Mirror-like reflection of light. Intensity depends on view angle.</p>
<p><strong>Spot Light</strong>
Light emitting in a cone shape, like a flashlight.</p>
<p><strong>SSAO (Screen-Space Ambient Occlusion)</strong>
Post-processing technique approximating ambient occlusion from depth buffer.</p>
<p><strong>Static Body</strong>
Physics body that never moves. Used for floors, walls, terrain.</p>
<p><strong>System</strong>
Logic that operates on entities with specific components.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<p><strong>Tessellation</strong>
Subdividing geometry into smaller triangles for detail.</p>
<p><strong>Texture</strong>
2D image mapped onto 3D geometry.</p>
<p><strong>Tonemapping</strong>
Converting HDR colors to displayable LDR range.</p>
<p><strong>Transform</strong>
Position, rotation, and scale of an object in 3D space.</p>
<p><strong>Transparency</strong>
See Alpha Blending.</p>
<p><strong>Trimesh (Triangle Mesh)</strong>
Collision shape using actual mesh geometry. Accurate but expensive.</p>
<h2 id="u"><a class="header" href="#u">U</a></h2>
<p><strong>UV Coordinates</strong>
2D texture coordinates mapping texture pixels to mesh vertices.</p>
<p><strong>Uniform</strong>
Shader constant that's the same for all vertices/pixels in a draw call.</p>
<h2 id="v"><a class="header" href="#v">V</a></h2>
<p><strong>Vertex</strong>
Point in 3D space with position, normal, texture coordinates, etc.</p>
<p><strong>Vertex Buffer</strong>
GPU memory containing vertex data.</p>
<p><strong>Vignette</strong>
Post-processing effect darkening screen edges.</p>
<p><strong>Vulkan</strong>
Low-level graphics API. Used by wgpu on Windows/Linux.</p>
<h2 id="w"><a class="header" href="#w">W</a></h2>
<p><strong>WebGPU</strong>
Modern web graphics API. Used by wgpu for cross-platform rendering.</p>
<p><strong>World Space</strong>
Global coordinate system. Contrast with local/object space.</p>
<p><strong>wgpu</strong>
Rust graphics library providing cross-platform GPU access.</p>
<h2 id="y"><a class="header" href="#y">Y</a></h2>
<p><strong>Yaw</strong>
Rotation around the Y (up) axis. Looking left/right.</p>
<h2 id="z"><a class="header" href="#z">Z</a></h2>
<p><strong>Z-Buffer</strong>
See Depth Buffer.</p>
<p><strong>Z-Fighting</strong>
Visual artifacts when two surfaces are at nearly the same depth.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>Common issues and their solutions.</p>
<h2 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h2>
<h3 id="feature-x-is-not-enabled"><a class="header" href="#feature-x-is-not-enabled">"feature <code>X</code> is not enabled"</a></h3>
<p>You're using a feature that isn't enabled in your <code>Cargo.toml</code>. Add the required feature:</p>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "physics", "audio"] }
</code></pre>
<p>See <a href="appendix-features.html">Feature Flags</a> for the complete list.</p>
<h3 id="cannot-find-function-spawn_primitive"><a class="header" href="#cannot-find-function-spawn_primitive">"cannot find function <code>spawn_primitive</code>"</a></h3>
<p>Import the prelude:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nightshade::prelude::*;
<span class="boring">}</span></code></pre></pre>
<h3 id="the-trait-state-is-not-implemented"><a class="header" href="#the-trait-state-is-not-implemented">"the trait <code>State</code> is not implemented"</a></h3>
<p>Ensure your game struct implements all required methods:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State for MyGame {
    fn title(&amp;self) -&gt; &amp;str { "My Game" }
    fn initialize(&amp;mut self, world: &amp;mut World) {}
    fn run_systems(&amp;mut self, world: &amp;mut World) {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nalgebra_glm-vs-glam-conflict"><a class="header" href="#nalgebra_glm-vs-glam-conflict">"nalgebra_glm vs glam conflict"</a></h3>
<p>Nightshade uses <code>nalgebra_glm</code> exclusively. Don't mix with <code>glam</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Correct
use nalgebra_glm::Vec3;

// Wrong - will cause type mismatches
use glam::Vec3;
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h2>
<h3 id="no-suitable-adapter-found"><a class="header" href="#no-suitable-adapter-found">"No suitable adapter found"</a></h3>
<p>Your GPU doesn't support the required graphics API.</p>
<p><strong>Windows:</strong></p>
<ul>
<li>Update graphics drivers</li>
<li>Install Vulkan Runtime from https://vulkan.lunarg.com/</li>
<li>Try forcing DX12: <code>WGPU_BACKEND=dx12 ./game.exe</code></li>
</ul>
<p><strong>Linux:</strong></p>
<ul>
<li>Install Vulkan drivers: <code>sudo apt install mesa-vulkan-drivers</code></li>
<li>Verify with <code>vulkaninfo</code></li>
</ul>
<p><strong>macOS:</strong></p>
<ul>
<li>Ensure macOS 10.13+ (Metal required)</li>
<li>Check System Report &gt; Graphics for Metal support</li>
</ul>
<h3 id="entity-not-found"><a class="header" href="#entity-not-found">"Entity not found"</a></h3>
<p>You're accessing an entity that was despawned or never existed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check entity exists before access
if world.has_entity(entity) {
    if let Some(transform) = world.get_local_transform(entity) {
        // Safe to use
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="texture-not-found"><a class="header" href="#texture-not-found">"Texture not found"</a></h3>
<p>The texture path is incorrect or the file doesn't exist:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Paths are relative to the executable
load_gltf(world, "assets/models/character.glb");  // Correct
load_gltf(world, "/home/user/game/assets/models/character.glb");  // Avoid absolute paths
<span class="boring">}</span></code></pre></pre>
<h3 id="physics-objects-fall-through-floor"><a class="header" href="#physics-objects-fall-through-floor">Physics objects fall through floor</a></h3>
<p>Common causes:</p>
<ol>
<li><strong>Missing collider on floor:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add_collider(world, floor, ColliderShape::Box {
    half_extents: Vec3::new(50.0, 0.5, 50.0),
});
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Objects spawned inside each other:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spawn above the floor, not at y=0
transform.translation = Vec3::new(0.0, 2.0, 0.0);
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>High velocity causing tunneling:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable CCD for fast objects
world.set_rigid_body(entity, RigidBodyComponent {
    ccd_enabled: true,
    ..Default::default()
});
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-not-playing"><a class="header" href="#animation-not-playing">Animation not playing</a></h3>
<ol>
<li><strong>Check animation name exists:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(player) = world.get_animation_player_mut(entity) {
    // List available animations
    for name in player.available_animations() {
        println!("Animation: {}", name);
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Call update each frame:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_systems(&amp;mut self, world: &amp;mut World) {
    update_animation_players(world, dt);
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Animation player is on child entity:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// glTF animations are often on child nodes
for child in world.get_children(model_root) {
    if let Some(player) = world.get_animation_player_mut(child) {
        player.play("idle");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="no-audio-output"><a class="header" href="#no-audio-output">No audio output</a></h3>
<ol>
<li><strong>Load sound before playing:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_sound(world, "shoot", "assets/audio/shoot.wav");
play_sound(world, "shoot");
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Check audio feature is enabled:</strong></li>
</ol>
<pre><code class="language-toml">nightshade = { git = "...", features = ["engine", "audio"] }
</code></pre>
<ol start="3">
<li><strong>Verify file format:</strong> Supported formats are WAV, OGG, MP3, FLAC.</li>
</ol>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="low-frame-rate"><a class="header" href="#low-frame-rate">Low frame rate</a></h3>
<ol>
<li><strong>Check entity count:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Entities: {}", world.entity_count());
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Disable expensive effects:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.ssao_enabled = false;
world.resources.graphics.bloom_enabled = false;
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Reduce shadow quality:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.shadow_map_size = 1024; // Default is 2048
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li><strong>Use simpler colliders:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefer boxes/spheres over trimesh
add_collider(world, entity, ColliderShape::Box { ... });
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-usage-high"><a class="header" href="#memory-usage-high">Memory usage high</a></h3>
<ol>
<li><strong>Despawn unused entities:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.despawn(entity);
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Unload unused textures:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.texture_cache.clear_unused();
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Use smaller textures for distant objects.</strong></li>
</ol>
<h3 id="stuttering--hitching"><a class="header" href="#stuttering--hitching">Stuttering / hitching</a></h3>
<ol>
<li><strong>Avoid allocations in run_systems:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - allocates every frame
let entities: Vec&lt;Entity&gt; = world.query(TRANSFORM).collect();

// Good - iterate directly
for entity in world.query(TRANSFORM) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Preload assets in initialize:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    load_gltf(world, "assets/models/enemy.glb");
    load_sound(world, "explosion", "assets/audio/explosion.wav");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visual-issues"><a class="header" href="#visual-issues">Visual Issues</a></h2>
<h3 id="objects-are-black"><a class="header" href="#objects-are-black">Objects are black</a></h3>
<p>Missing or incorrect lighting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_directional_light(world, Vec3::new(-1.0, -1.0, -1.0));
world.resources.graphics.ambient_intensity = 0.1;
<span class="boring">}</span></code></pre></pre>
<h3 id="objects-are-too-bright--washed-out"><a class="header" href="#objects-are-too-bright--washed-out">Objects are too bright / washed out</a></h3>
<p>Adjust exposure and tonemapping:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.exposure = 1.0;
world.resources.graphics.tonemap_method = TonemapMethod::Aces;
<span class="boring">}</span></code></pre></pre>
<h3 id="textures-look-wrong"><a class="header" href="#textures-look-wrong">Textures look wrong</a></h3>
<ol>
<li>
<p><strong>Normal maps inverted:</strong> Some tools export Y-flipped normals. Check your export settings.</p>
</li>
<li>
<p><strong>sRGB vs Linear:</strong> Base color textures should be sRGB. Normal/metallic/roughness should be linear.</p>
</li>
<li>
<p><strong>Texture coordinates flipped:</strong> glTF uses top-left origin. Some models may need UV adjustment.</p>
</li>
</ol>
<h3 id="z-fighting-flickering-surfaces"><a class="header" href="#z-fighting-flickering-surfaces">Z-fighting (flickering surfaces)</a></h3>
<p>Surfaces too close together:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increase near plane
camera.near = 0.1;  // Instead of 0.01

// Or separate surfaces more
floor_transform.translation.y = 0.0;
decal_transform.translation.y = 0.01;  // Slight offset
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-issues"><a class="header" href="#webassembly-issues">WebAssembly Issues</a></h2>
<h3 id="webgpu-not-supported"><a class="header" href="#webgpu-not-supported">"WebGPU not supported"</a></h3>
<ul>
<li>Use Chrome 113+ or Edge 113+</li>
<li>Firefox requires enabling <code>dom.webgpu.enabled</code> in about:config</li>
<li>Safari support is limited</li>
</ul>
<h3 id="assets-fail-to-load"><a class="header" href="#assets-fail-to-load">Assets fail to load</a></h3>
<p>WASM can't access the filesystem. Serve assets via HTTP:</p>
<pre><code class="language-html">&lt;script&gt;
// Assets must be fetched, not loaded from disk
fetch('assets/model.glb')
    .then(response =&gt; response.arrayBuffer())
    .then(data =&gt; { /* use data */ });
&lt;/script&gt;
</code></pre>
<h3 id="performance-worse-than-native"><a class="header" href="#performance-worse-than-native">Performance worse than native</a></h3>
<p>Expected. WebGPU has overhead. Reduce quality settings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
{
    world.resources.graphics.ssao_enabled = false;
    world.resources.graphics.shadow_map_size = 512;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<p>If your issue isn't listed here:</p>
<ol>
<li>Check the <a href="https://github.com/matthewjberger/nightshade/issues">GitHub Issues</a></li>
<li>Search existing issues for similar problems</li>
<li>Create a new issue with:
<ul>
<li>Nightshade version</li>
<li>Platform (OS, GPU)</li>
<li>Minimal code to reproduce</li>
<li>Error message or screenshot</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
