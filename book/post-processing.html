<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Post-Processing - Nightshade Game Engine</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nightshade Game Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="post-processing"><a class="header" href="#post-processing">Post-Processing</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/bloom">Bloom</a> | <a href="https://matthewberger.dev/nightshade/ssao">SSAO</a> | <a href="https://matthewberger.dev/nightshade/depth_of_field">Depth of Field</a></p>
</blockquote>
<p>Post-processing passes read the HDR scene color, depth, and normals to produce the final image. These passes are added in <code>configure_render_graph()</code>.</p>
<h2 id="available-passes"><a class="header" href="#available-passes">Available Passes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pass</th><th>Description</th><th>Reads</th><th>Writes</th></tr></thead><tbody>
<tr><td><code>SsaoPass</code></td><td>Screen-space ambient occlusion</td><td>depth, normals</td><td>ssao_raw</td></tr>
<tr><td><code>SsaoBlurPass</code></td><td>Bilateral blur for SSAO</td><td>ssao_raw</td><td>ssao</td></tr>
<tr><td><code>SsgiPass</code></td><td>Screen-space global illumination (half-res)</td><td>scene_color, depth, normals</td><td>ssgi_raw</td></tr>
<tr><td><code>SsgiBlurPass</code></td><td>Bilateral blur for SSGI</td><td>ssgi_raw</td><td>ssgi</td></tr>
<tr><td><code>SsrPass</code></td><td>Screen-space reflections</td><td>scene_color, depth, normals</td><td>ssr_raw</td></tr>
<tr><td><code>SsrBlurPass</code></td><td>Blur for SSR</td><td>ssr_raw</td><td>ssr</td></tr>
<tr><td><code>BloomPass</code></td><td>HDR bloom with mip chain</td><td>scene_color</td><td>bloom</td></tr>
<tr><td><code>DepthOfFieldPass</code></td><td>Bokeh depth of field</td><td>scene_color, depth</td><td>scene_color</td></tr>
<tr><td><code>PostProcessPass</code></td><td>Final tonemapping and compositing</td><td>scene_color, bloom, ssao</td><td>output</td></tr>
<tr><td><code>EffectsPass</code></td><td>Custom shader effects</td><td>scene_color</td><td>scene_color</td></tr>
<tr><td><code>OutlinePass</code></td><td>Selection outline</td><td>selection_mask</td><td>scene_color</td></tr>
<tr><td><code>BlitPass</code></td><td>Simple texture copy</td><td>input</td><td>output</td></tr>
<tr><td><code>ComputeGrayscalePass</code></td><td>Grayscale conversion</td><td>input</td><td>output</td></tr>
</tbody></table>
</div>
<h2 id="enabling-effects"><a class="header" href="#enabling-effects">Enabling Effects</a></h2>
<p>Control post-processing through <code>world.resources.graphics</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize(&amp;mut self, world: &amp;mut World) {
    world.resources.graphics.bloom_enabled = true;
    world.resources.graphics.bloom_intensity = 0.3;

    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.ssao_radius = 0.5;
    world.resources.graphics.ssao_intensity = 1.0;

    world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ssao-screen-space-ambient-occlusion"><a class="header" href="#ssao-screen-space-ambient-occlusion">SSAO (Screen-Space Ambient Occlusion)</a></h2>
<p>In the real world, corners, crevices, and enclosed spaces receive less ambient light because surrounding geometry occludes incoming light from many directions. SSAO approximates this effect in screen space by analyzing the depth buffer.</p>
<h3 id="how-ssao-works"><a class="header" href="#how-ssao-works">How SSAO Works</a></h3>
<p>For each pixel, the shader reconstructs the 3D position from the depth buffer, then samples several random points in a hemisphere oriented along the surface normal. Each sample point is projected back into screen space to check the depth buffer: if the stored depth is closer than the sample point, that direction is occluded. The ratio of occluded samples to total samples gives the occlusion factor.</p>
<p>The key inputs are:</p>
<ul>
<li><strong>Depth buffer</strong> - Provides the 3D position of each pixel</li>
<li><strong>View-space normals</strong> - Orients the sampling hemisphere along the surface</li>
<li><strong>Random noise</strong> - Rotates the sample kernel per-pixel to avoid banding patterns</li>
</ul>
<p>The raw SSAO output is noisy because of the limited sample count (typically 16-64 samples per pixel). A bilateral blur pass smooths the result while preserving edges (it avoids blurring across depth discontinuities, which would cause halos around objects).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.ssao_enabled = true;
world.resources.graphics.ssao_radius = 0.5;
world.resources.graphics.ssao_intensity = 1.0;
world.resources.graphics.ssao_bias = 0.025;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>ssao_radius</code> - The hemisphere radius in world units. Larger values detect occlusion from farther geometry but can cause over-darkening.</li>
<li><code>ssao_bias</code> - A small depth offset to prevent self-occlusion artifacts on flat surfaces.</li>
<li><code>ssao_intensity</code> - Multiplier for the final occlusion factor.</li>
</ul>
<h2 id="ssgi-screen-space-global-illumination"><a class="header" href="#ssgi-screen-space-global-illumination">SSGI (Screen-Space Global Illumination)</a></h2>
<p>In real-world lighting, light bounces between surfaces. A red wall next to a white floor tints the floor red. Traditional rasterization only computes direct lighting (light source to surface to camera). Global illumination (GI) adds these indirect bounces.</p>
<p>SSGI approximates one bounce of indirect light using only screen-space information. For each pixel, the shader traces short rays through the depth buffer to find nearby surfaces, then samples the color at those hit points as incoming indirect light. This is conceptually similar to SSAO but samples color instead of just occlusion.</p>
<p>SSGI is computed at half resolution for performance (the indirect illumination is low-frequency and doesn't need full resolution), then bilaterally blurred and upsampled.</p>
<h2 id="ssr-screen-space-reflections"><a class="header" href="#ssr-screen-space-reflections">SSR (Screen-Space Reflections)</a></h2>
<p>SSR adds dynamic reflections by ray-marching through the depth buffer. For each reflective pixel, the shader computes the reflection vector from the camera direction and the surface normal, then steps along that vector in screen space, checking the depth buffer at each step. When the ray intersects a surface (the ray's depth exceeds the depth buffer value), the color at that screen position becomes the reflection.</p>
<p>This technique works well for reflections of on-screen geometry but has inherent limitations: off-screen objects cannot be reflected, and reflections at grazing angles stretch across large screen areas. The blur pass hides artifacts from these limitations, and a fallback to environment maps or IBL fills in where SSR has no data.</p>
<h2 id="bloom"><a class="header" href="#bloom">Bloom</a></h2>
<p>Bloom simulates the light scattering that occurs in real cameras and the human eye when bright light sources bleed into surrounding areas. In HDR rendering, pixels can have values above 1.0 (the displayable range). Bloom extracts these bright pixels and spreads their light outward.</p>
<h3 id="how-bloom-works"><a class="header" href="#how-bloom-works">How Bloom Works</a></h3>
<p>The bloom pipeline uses a progressive downsample/upsample approach (similar to the technique described in the Call of Duty: Advanced Warfare presentation):</p>
<ol>
<li><strong>Threshold</strong> - Extract pixels brighter than a threshold from the HDR scene color</li>
<li><strong>Downsample chain</strong> - Progressively halve the resolution through multiple mip levels (e.g., 1920x1080 -&gt; 960x540 -&gt; 480x270 -&gt; ...), applying a blur at each step. This is much cheaper than blurring at full resolution because each mip level has 1/4 the pixels.</li>
<li><strong>Upsample chain</strong> - Walk back up the mip chain, additively blending each level with the one above it. This produces a smooth, wide blur that spans many pixels without requiring a massive blur kernel.</li>
<li><strong>Composite</strong> - Add the bloom result to the scene color during the final post-process pass.</li>
</ol>
<p>The mip-chain approach produces natural-looking bloom because it captures both tight glow (from the high-resolution mips) and wide glow (from the low-resolution mips) simultaneously.</p>
<p>Bloom creates a glow effect around bright pixels using this mip-chain downsample/upsample approach:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.bloom_enabled = true;
world.resources.graphics.bloom_intensity = 0.5;
<span class="boring">}</span></code></pre></pre>
<p>Materials with high emissive values produce the strongest bloom:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let glowing = Material {
    base_color: [0.2, 0.8, 1.0, 1.0],
    emissive_factor: [2.0, 8.0, 10.0],
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="depth-of-field"><a class="header" href="#depth-of-field">Depth of Field</a></h2>
<p>Depth of field simulates the optical behavior of a physical camera lens. A real lens can only focus at one distance; objects nearer or farther than the focal plane appear blurred. The amount of blur (the circle of confusion, or CoC) increases with distance from the focal plane and is controlled by the aperture size.</p>
<h3 id="how-dof-works"><a class="header" href="#how-dof-works">How DoF Works</a></h3>
<ol>
<li><strong>CoC computation</strong> - For each pixel, compute the circle of confusion from the depth buffer value, the focus distance, and the aperture. The CoC is the diameter (in pixels) of the blur disc for that pixel.</li>
<li><strong>Blur</strong> - Apply a variable-radius blur where the kernel size is proportional to the CoC. Pixels with large CoC values (far from focus) get blurred heavily; pixels near the focal plane remain sharp.</li>
<li><strong>Bokeh</strong> - Bright out-of-focus highlights form characteristic shapes (circles, hexagons) called bokeh. The shader can emphasize bright pixels during the blur to simulate this optical effect.</li>
</ol>
<p>Focus blur based on distance from a focus plane:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.depth_of_field.enabled = true;
world.resources.graphics.depth_of_field.focus_distance = 10.0;
world.resources.graphics.depth_of_field.focus_range = 5.0;
world.resources.graphics.depth_of_field.max_blur_radius = 10.0;
world.resources.graphics.depth_of_field.bokeh_threshold = 1.0;
world.resources.graphics.depth_of_field.bokeh_intensity = 1.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>HDR rendering computes lighting in a physically linear color space where values can range from 0 to thousands. But displays can only show values between 0 and 1. Tonemapping is the process of compressing the HDR range into the displayable LDR range while preserving the perception of brightness differences and color relationships.</p>
<p>Different tonemapping curves make different trade-offs:</p>
<ul>
<li><strong>Reinhard</strong> - Simple <code>color / (color + 1)</code> mapping. Preserves highlights but can look washed out.</li>
<li><strong>ACES</strong> (Academy Color Encoding System) - Film-industry standard curve with good contrast and a slight warm tint. Widely used in games.</li>
<li><strong>AgX</strong> - A more recent curve designed to handle highly saturated colors better than ACES (which can produce hue shifts in bright saturated regions).</li>
<li><strong>Neutral</strong> - Minimal color manipulation, useful when color grading is handled externally.</li>
</ul>
<p>The <code>PostProcessPass</code> performs HDR-to-LDR tonemapping:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TonemapAlgorithm {
    Reinhard,
    Aces,
    ReinhardExtended,
    Uncharted2,
    AgX,
    Neutral,
    None,
}

world.resources.graphics.color_grading.tonemap_algorithm = TonemapAlgorithm::Aces;
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.resources.graphics.color_grading.saturation = 1.0;
world.resources.graphics.color_grading.contrast = 1.0;
world.resources.graphics.color_grading.brightness = 0.0;
<span class="boring">}</span></code></pre></pre>
<h2 id="effects-pass"><a class="header" href="#effects-pass">Effects Pass</a></h2>
<p>The <code>EffectsPass</code> runs custom WGSL shader effects for specialized visual treatments:</p>
<ul>
<li>Color grading presets</li>
<li>Chromatic aberration</li>
<li>Film grain</li>
<li>Custom shader effects</li>
</ul>
<p>See <a href="effects-pass.html">Effects Pass</a> for details.</p>
<h2 id="custom-post-processing"><a class="header" href="#custom-post-processing">Custom Post-Processing</a></h2>
<p>Add custom post-processing passes via the render graph. See <a href="render-graph-custom.html">Custom Passes</a> for implementation examples.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Effect</th><th>Cost</th><th>Notes</th></tr></thead><tbody>
<tr><td>Bloom</td><td>Medium</td><td>Multiple blur passes at half resolution</td></tr>
<tr><td>SSAO</td><td>High</td><td>Many depth samples per pixel</td></tr>
<tr><td>SSGI</td><td>High</td><td>Half resolution helps, but still expensive</td></tr>
<tr><td>SSR</td><td>High</td><td>Ray tracing through depth buffer</td></tr>
<tr><td>DoF</td><td>Medium</td><td>Gaussian blur</td></tr>
<tr><td>Tonemapping</td><td>Low</td><td>Per-pixel math</td></tr>
<tr><td>Color Grading</td><td>Low</td><td>Per-pixel math</td></tr>
</tbody></table>
</div>
<p>Disable expensive effects for better performance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_quality_low(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = false;
    world.resources.graphics.bloom_enabled = false;
}

fn set_quality_high(world: &amp;mut World) {
    world.resources.graphics.ssao_enabled = true;
    world.resources.graphics.bloom_enabled = true;
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="geometry-passes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="cameras.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="geometry-passes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="cameras.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
