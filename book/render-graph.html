<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Render Graph - Nightshade Game Engine</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nightshade Game Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-render-graph"><a class="header" href="#the-render-graph">The Render Graph</a></h1>
<blockquote>
<p><strong>Live Demos:</strong> <a href="https://matthewberger.dev/nightshade/custom_pass">Custom Pass</a> | <a href="https://matthewberger.dev/nightshade/custom_multipass">Custom Multipass</a> | <a href="https://matthewberger.dev/nightshade/render_layers">Render Layers</a></p>
</blockquote>
<p>The render graph is a dependency-driven frame graph that automatically schedules GPU work. Instead of manually ordering render passes, you declare what each pass reads and writes, and the graph figures out the rest.</p>
<h2 id="the-problem-manual-pass-ordering"><a class="header" href="#the-problem-manual-pass-ordering">The Problem: Manual Pass Ordering</a></h2>
<p>A modern renderer has dozens of passes: shadow maps, geometry, SSAO, SSR, bloom, tonemapping, UI. Each reads from and writes to intermediate textures. Without automation, you must:</p>
<ol>
<li><strong>Manually order passes</strong> - Shadow maps before geometry, geometry before SSAO, SSAO before compositing. Add one pass and you must figure out where it fits in the chain. Reorder one pass and you break three others.</li>
<li><strong>Manually manage textures</strong> - Allocate intermediate textures, track which ones are alive when, decide when to clear vs load, when to store vs discard. Get it wrong and you see black screens or stale data from previous frames.</li>
<li><strong>Manually optimize memory</strong> - SSAO's intermediate texture and SSR's intermediate texture might never be alive at the same time. Without aliasing, you waste VRAM on textures that could share the same memory.</li>
<li><strong>Manually handle dynamic passes</strong> - Disabling bloom shouldn't require rewriting the compositing pass's inputs. But with hardcoded ordering, every conditional pass is an <code>if</code> statement that must be threaded through the entire pipeline.</li>
</ol>
<p>A render graph (also called a frame graph, as described in the Frostbite GDC 2017 talk "FrameGraph: Extensible Rendering Architecture in Frostbite") solves all of this. You describe what each pass needs, and the graph handles ordering, memory, and lifecycle.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>The render graph models the frame as a <strong>directed acyclic graph (DAG)</strong> where:</p>
<ul>
<li><strong>Nodes</strong> are render passes</li>
<li><strong>Edges</strong> are resource dependencies (an edge from A to B means "A produces data that B consumes")</li>
</ul>
<p>This is the same abstraction as a build system (Make, Bazel) or a task scheduler. Given the dependency edges, a topological sort produces a valid execution order. The graph can then analyze resource lifetimes across that order to alias memory, compute load/store operations, and cull unused passes.</p>
<p>The key insight is that passes declare their dependencies <strong>declaratively</strong> through named slots, not <strong>imperatively</strong> through explicit ordering. This makes the system composable: adding a new pass means declaring what it reads and writes, not editing every other pass that touches the same resources.</p>
<h2 id="why-a-render-graph"><a class="header" href="#why-a-render-graph">Why a Render Graph?</a></h2>
<ul>
<li><strong>Automatic ordering</strong> - Passes are topologically sorted based on read/write dependencies</li>
<li><strong>Automatic memory management</strong> - Transient textures with non-overlapping lifetimes share GPU memory</li>
<li><strong>Automatic load/store ops</strong> - The graph determines whether to Clear, Load, Store, or Discard each attachment</li>
<li><strong>Dead pass culling</strong> - Passes that don't contribute to any external output are automatically skipped</li>
<li><strong>Runtime toggling</strong> - Passes can be enabled/disabled at runtime without recompiling the graph</li>
</ul>
<h2 id="the-rendergraph-struct"><a class="header" href="#the-rendergraph-struct">The RenderGraph Struct</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderGraph&lt;C = ()&gt; {
    graph: DiGraph&lt;GraphNode&lt;C&gt;, ResourceId&gt;,  // petgraph directed graph
    pass_nodes: HashMap&lt;String, NodeIndex&gt;,     // pass name -&gt; graph node
    resources: RenderGraphResources,            // texture/buffer descriptors and handles
    execution_order: Vec&lt;NodeIndex&gt;,            // topologically sorted pass order
    store_ops: HashMap&lt;ResourceId, StoreOp&gt;,    // per-resource store operations
    clear_ops: HashSet&lt;(NodeIndex, ResourceId)&gt;,// which passes clear which resources
    aliasing_info: Option&lt;ResourceAliasingInfo&gt;,// memory sharing between transients
    culled_passes: HashSet&lt;NodeIndex&gt;,          // passes removed by dead-pass culling
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The generic parameter <code>C</code> is the "configs" type passed to passes during execution. Nightshade uses <code>RenderGraph&lt;World&gt;</code> so passes can read ECS state.</p>
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<h3 id="1-setup-phase-once-at-startup"><a class="header" href="#1-setup-phase-once-at-startup">1. Setup Phase (once at startup)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut graph = RenderGraph::new();

// Declare textures
let depth = graph.add_depth_texture("depth")
    .size(1920, 1080)
    .clear_depth(0.0)
    .transient();

let scene_color = graph.add_color_texture("scene_color")
    .format(wgpu::TextureFormat::Rgba16Float)
    .size(1920, 1080)
    .clear_color(wgpu::Color::BLACK)
    .transient();

let swapchain = graph.add_color_texture("swapchain")
    .format(surface_format)
    .external();

// Add passes with slot bindings
graph.add_pass(
    Box::new(clear_pass),
    &amp;[("color", scene_color), ("depth", depth)],
)?;

graph.add_pass(
    Box::new(mesh_pass),
    &amp;[("color", scene_color), ("depth", depth)],
)?;

graph.add_pass(
    Box::new(blit_pass),
    &amp;[("input", scene_color), ("output", swapchain)],
)?;

// Compile: build edges, sort, compute aliasing
graph.compile()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-per-frame-execution"><a class="header" href="#2-per-frame-execution">2. Per-Frame Execution</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Provide the swapchain texture for this frame
graph.set_external_texture(swapchain_id, swapchain_view, width, height);

// Execute all passes, get command buffers
let command_buffers = graph.execute(&amp;device, &amp;queue, &amp;world)?;

// Submit to GPU
queue.submit(command_buffers);
<span class="boring">}</span></code></pre></pre>
<h2 id="key-methods"><a class="header" href="#key-methods">Key Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>Create an empty graph</td></tr>
<tr><td><code>add_color_texture()</code></td><td>Declare a color render target (returns builder)</td></tr>
<tr><td><code>add_depth_texture()</code></td><td>Declare a depth buffer (returns builder)</td></tr>
<tr><td><code>add_buffer()</code></td><td>Declare a GPU buffer (returns builder)</td></tr>
<tr><td><code>add_pass()</code></td><td>Add a pass with slot-to-resource bindings</td></tr>
<tr><td><code>pass()</code></td><td>Fluent pass builder (alternative to <code>add_pass</code>)</td></tr>
<tr><td><code>compile()</code></td><td>Build dependency graph, topological sort, compute aliasing</td></tr>
<tr><td><code>execute()</code></td><td>Prepare and run all passes, return command buffers</td></tr>
<tr><td><code>set_external_texture()</code></td><td>Provide an external texture (e.g. swapchain) each frame</td></tr>
<tr><td><code>set_pass_enabled()</code></td><td>Enable/disable a pass at runtime</td></tr>
<tr><td><code>get_pass_mut()</code></td><td>Access a pass for runtime configuration</td></tr>
<tr><td><code>resize_transient_resource()</code></td><td>Change dimensions of a transient texture</td></tr>
</tbody></table>
</div>
<h2 id="compilation-steps"><a class="header" href="#compilation-steps">Compilation Steps</a></h2>
<p>When <code>compile()</code> is called:</p>
<ol>
<li><strong>Build dependency edges</strong> - For each resource, the graph creates an edge from writer to reader</li>
<li><strong>Topological sort</strong> - Passes are sorted so every pass executes after its dependencies</li>
<li><strong>Compute store ops</strong> - Determine Store vs Discard for each resource write</li>
<li><strong>Compute clear ops</strong> - Determine which pass performs the initial Clear for each resource</li>
<li><strong>Compute resource lifetimes</strong> - Track first_use and last_use for each transient resource</li>
<li><strong>Compute resource aliasing</strong> - Transient resources with non-overlapping lifetimes share GPU memory</li>
<li><strong>Dead pass culling</strong> - Passes that don't contribute to external outputs are marked for skipping</li>
</ol>
<h2 id="sub-chapters"><a class="header" href="#sub-chapters">Sub-Chapters</a></h2>
<ul>
<li><a href="render-graph-resources.html">Resources &amp; Textures</a> - Resource types, builders, external vs transient</li>
<li><a href="render-graph-passes.html">Passes &amp; the PassNode Trait</a> - Implementing custom passes</li>
<li><a href="render-graph-scheduling.html">Dependency Resolution &amp; Scheduling</a> - How passes are ordered</li>
<li><a href="render-graph-aliasing.html">Resource Aliasing &amp; Memory</a> - GPU memory sharing</li>
<li><a href="render-graph-custom.html">Custom Passes</a> - Full examples of custom rendering</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="rendering-architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="render-graph-resources.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="rendering-architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="render-graph-resources.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
